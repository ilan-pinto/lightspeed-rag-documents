<!DOCTYPE html>
<html lang="en" dir="ltr" prefix="og: https://ogp.me/ns#">
  <head>
    <meta charset="utf-8" />
<link rel="canonical" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="shortlink" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/index" />
<meta property="og:site_name" content="Red Hat Customer Portal" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/index" />
<meta property="og:title" content="Storage OpenShift Container Platform 4.13 | Red Hat Customer Portal" />
<meta property="og:description" content="This document provides instructions for configuring persistent volumes from various storage back ends and managing dynamic allocation from Pods." />
<meta property="og:image" content="https://access.redhat.com/webassets/avalon/g/shadowman-200.png" />
<meta name="twitter:card" content="summary" />
<meta name="twitter:description" content="This document provides instructions for configuring persistent volumes from various storage back ends and managing dynamic allocation from Pods." />
<meta name="twitter:title" content="Storage OpenShift Container Platform 4.13 | Red Hat Customer Portal" />
<meta name="twitter:url" content="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/index" />
<meta name="twitter:image" content="https://access.redhat.com/webassets/avalon/g/shadowman-200.png" />
<meta name="title" content="Storage OpenShift Container Platform 4.13 | Red Hat Customer Portal" />
<link rel="alternate" hreflang="en" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="ko" href="https://access.redhat.com/documentation/ko-kr/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="zh-hans" href="https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="ja" href="https://access.redhat.com/documentation/ja-jp/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="es" href="https://access.redhat.com/documentation/es-es/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="ru" href="https://access.redhat.com/documentation/ru-ru/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="pt-br" href="https://access.redhat.com/documentation/pt-br/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="it" href="https://access.redhat.com/documentation/it-it/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="de" href="https://access.redhat.com/documentation/de-de/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="fr" href="https://access.redhat.com/documentation/fr-fr/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="zh-hant" href="https://access.redhat.com/documentation/zh-tw/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="id" href="https://access.redhat.com/documentation/id-id/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="th" href="https://access.redhat.com/documentation/th-th/openshift_container_platform/4.13/html-single/storage/index" />
<link rel="alternate" hreflang="vi" href="https://access.redhat.com/documentation/vi-vn/openshift_container_platform/4.13/html-single/storage/index" />
<meta name="Generator" content="Drupal 9 (https://www.drupal.org)" />
<meta name="MobileOptimized" content="width" />
<meta name="HandheldFriendly" content="true" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="revision" product="b0738f19-59ac-47eb-9512-8a439cd6dfb0" title="b6b5ecd5-d9a9-4810-a9b9-e25c5a96bbff" page="8de80faa-314c-4454-884b-11cf11f36aef" revision="dccd48b1f252cc22dad43e9ae6252b9287d98ca1:en-us" body="ad81445179831601acc66af9615ec1c6.html" toc="0b437090b34a37d4a76dcd2eedabd0d2.json" />

    <title>Storage OpenShift Container Platform 4.13 | Red Hat Customer Portal</title>
    <link rel="stylesheet" media="all" href="/sites/dxp-docs/files/css/css_87GMcmxT1ib8ziQiU2KUAnTDFtZQV6iP-KGslA9LigM.css" />
<link rel="stylesheet" media="all" href="/sites/dxp-docs/files/css/css__Xq4GfgPDJw9K_yYJFmlRZGJeCENu3R3r4s0K7Tr_9g.css" />

    
    <script type="application/json" data-drupal-selector="drupal-settings-json">{"path":{"baseUrl":"\/","scriptPath":null,"pathPrefix":"","currentPath":"documentation\/en-us\/openshift_container_platform\/4.13\/html-single\/storage\/index","currentPathIsAdmin":false,"isFront":false,"currentLanguage":"en"},"pluralDelimiter":"\u0003","suppressDeprecationErrors":true,"red_hat_jwt":{"client_id":"customer-portal","cookie_name":"rh_jwt","leeway":"0","realm":"redhat-external","sso_host":"https:\/\/sso.redhat.com\/","user_integration":1,"user_plugin":"drupal_user_auth","use_external_js":0,"use_internal_js":0,"use_in_admin":0},"user":{"uid":0,"permissionsHash":"d8ea0bce2d740dacbdfe0257cf55baa0e33f7fb8468a26d055ce75daaaa2d315"}}</script>
<script src="/sites/dxp-docs/files/js/js_EQWKo9EokWkWS99x_e1oM-NEM0zlKyTkp_83mGdm5Ks.js"></script>

    <!-- CP_PRIMER_HEAD -->  <!-- TrustArc & DTM -->
  <script src="//static.redhat.com/libs/redhat/marketing/latest/trustarc/trustarc.js"></script>
  <script src="//www.redhat.com/dtm.js"></script><meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<!--[if IEMobile]><meta http-equiv="cleartype" content="on"><![endif]-->

<!-- metaInclude -->
<meta name="avalon-host-info" content="dxp-kbase-prod-139-77b4fb8768-25dr9" />
<meta name="avalon-version" content="27861f77" />
<meta name="cp-chrome-build-date" content="2023-10-06T19:17:59.039Z" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<!-- Chrome, Firefox OS and Opera -->
<meta name="theme-color" content="#000000">
<!-- Windows Phone -->
<meta name="msapplication-navbutton-color" content="#000000">
<!-- iOS Safari -->
<meta name="apple-mobile-web-app-status-bar-style" content="#000000">
<link rel="manifest" href="https://access.redhat.com/webassets/avalon/j/manifest.json">
<!-- Open Search - Tap to search -->
<link rel="search" type="application/opensearchdescription+xml" title="Red Hat Customer Portal" href="https://access.redhat.com/webassets/avalon/j/opensearch.xml" />
<!-- title -->
<title>Red Hat Customer Portal - Access to 24x7 support and knowledge</title>
<!-- /title -->
<script type="text/javascript">
    window.portal = {
        analytics : {},
        host      : "https://access.redhat.com",
        idp_url   : "https://sso.redhat.com",
        lang      : "en", 
        version   : "27861f77",
        builddate : "2023-10-06T19:17:59.039Z",        fetchdate : "2023-10-10T17:45:08-0400",        nrid      : "NOLONGERSUPPORTED",
        nrlk      : "NOLONGERSUPPORTED"
    };
</script>
<script type="text/javascript">
    if (!/\/logout.*/.test(location.pathname) && portal.host === location.origin && document.cookie.indexOf('rh_sso_session') >= 0 && !(document.cookie.indexOf('rh_jwt') >= 0)) window.location = '/login?redirectTo=' + encodeURIComponent(window.location.href);
</script>
<!-- cssInclude -->

<link rel="shortcut icon" href="https://access.redhat.com/webassets/avalon/g/favicon.ico" /><link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/chrome_themes/nimbus/css/bootstrap.css?v=27861f77" />
<link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/chrome_themes/nimbus/css/bootstrap-grid.css?v=27861f77" />
<link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/chrome_themes/nimbus/css/main.css?v=27861f77" />
<link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/chrome_themes/nimbus/css/components.css?v=27861f77" />
<link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/chrome_themes/nimbus/css/pages.css?v=27861f77" />

<link href="https://access.redhat.com/webassets/avalon/s/chosen.css?v=27861f77" rel="stylesheet" type="text/css" />

<!--[if lte IE 9]>
<link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/chrome_themes/nimbus/css/ie.css" />
<![endif]--><noscript>
    <style type="text/css" media="screen"> .primary-nav { display: block; } </style>
</noscript>
<link media="all" rel="stylesheet" type="text/css" href="https://access.redhat.com/webassets/avalon/j/public_modules/node_modules/@cpelements/pfe-navigation/dist/pfe-navigation--lightdom.min.css" />
<!-- /cssInclude -->
<script src="https://access.redhat.com/webassets/avalon/j/public_modules/node_modules/@cpelements/pfe-navigation/dist/ie-polyfills.js?v=27861f77"></script>

<script async>
  if (!HTMLScriptElement.supports || !HTMLScriptElement.supports('importmap')) {
    import("https://www.redhatstatic.com/dx/v1-alpha/es-module-shims@1.7.3.js");
  }
</script>
<script type="importmap">
{
  "imports": {
    "@patternfly/elements/" : "https://www.redhatstatic.com/dx/v1-alpha/@patternfly/elements@2.2.2/",
    "@rhds/elements/":"https://www.redhatstatic.com/dx/v1-alpha/@rhds/elements@1.1.0/elements/",
    "@rhds/elements/lib/":"https://www.redhatstatic.com/dx/v1-alpha/@rhds/elements@1.1.0/lib/",
    "@cpelements/elements/":"https://www.redhatstatic.com/dx/v1-alpha/@cpelements/elements@2.0.0-alpha.7/elements/"
  }
}
</script><script type="text/javascript" src="https://access.redhat.com/webassets/avalon/j/lib/require.js?v=27861f77" data-main="/webassets/avalon/j/"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<script src="https://access.redhat.com/chrome_themes/nimbus/js/ie8.js"></script>
<![endif]-->
<script type="text/javascript" src="https://access.redhat.com/chrome_themes/nimbus/js/new-nav.js?v=27861f77" ></script>
<!-- /CP_PRIMER_HEAD -->

  </head>
  <body>
    
      <div class="dialog-off-canvas-main-canvas" data-off-canvas-main-canvas>
      <!-- CP_PRIMER_HEADER -->
<div id="page-wrap" class="page-wrap">
    <div id="pers-top-page-wrap" class="top-page-wrap pers-loader-bg">

      <div id="hero-bg-top-left" class="summit-bg-shapes"></div>
      <div id="hero-bg-top-right" class="summit-bg-shapes"></div>

        <!--googleoff: all-->
        <header class="masthead" id="masthead">

            <a href="#pfe-navigation" id="global-skip-to-nav" class="skip-link visually-hidden">Skip to navigation</a>
            <a href="#cp-main" class="skip-link visually-hidden">Skip to main content</a>            <nav id="portal-utility-nav" class="utility-navigation utility-navigation--bar hidden-at-mobile" data-analytics-region="utility" aria-labelledby="nav__utility-nav--desktop">
                <h3 id="nav__utility-nav--desktop" class="element-invisible">Utilities
                </h3>
                <ul aria-labelledby="nav__utility-nav--desktop">
                    <li id="nav-subscription" data-portal-tour-1="1">
                        <a class="top-nav-subscriptions" data-analytics-level="2" data-analytics-category="Utilities" data-analytics-text="Subscription" href="https://access.redhat.com/management/" >Subscriptions
                        </a>
                    </li>
                    <li id="nav-downloads" data-portal-tour-1="2">
                        <a class="top-nav-downloads" data-analytics-level="2" data-analytics-category="Utilities" data-analytics-text="Downloads" href="https://access.redhat.com/downloads/" >Downloads
                        </a>
                    </li>
                    <li id="nav-containers">
                        <a class="top-nav-containers" data-analytics-level="2" data-analytics-category="Utilities" data-analytics-text="Containers" href="https://catalog.redhat.com/software/containers/explore/" >Containers
                        </a>
                    </li>
                    <li id="nav-support" data-portal-tour-1="3">
                        <a class="top-nav-support-cases" data-analytics-level="2" data-analytics-category="Utilities" data-analytics-text="Support Cases" href="https://access.redhat.com/support/cases/" >Support Cases
                        </a>
                    </li>
                </ul>
            </nav>

            <pfe-navigation id="pfe-navigation" data-analytics-region="mega menu">
                <div class="pfe-navigation__logo-wrapper" id="pfe-navigation__logo-wrapper">
                    <a href="https://access.redhat.com/" class="pfe-navigation__logo-link" data-analytics-text="logo" data-analytics-category="MM|logo">
                        <img class="pfe-navigation__logo-image" alt="Red Hat Customer Portal" src="https://access.redhat.com/chrome_themes/nimbus/img/red-hat-customer-portal.svg" />
                    </a>
                </div>

                <nav class="pfe-navigation" aria-label="Main Navigation" data-analytics-region="main nav">
                    <ul class="pfe-navigation__menu" id="pfe-navigation__menu">                        <li class="pfe-navigation__menu-item hidden-at-tablet hidden-at-desktop" id="nav-subscription--mobile" data-portal-tour-1="1">
                            <a class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Subscription" href="https://access.redhat.com/management/" >Subscriptions
                            </a>
                        </li>
                        <li class="pfe-navigation__menu-item hidden-at-tablet hidden-at-desktop" id="nav-downloads--mobile" data-portal-tour-1="2">
                            <a class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Downloads" href="https://access.redhat.com/downloads/" >Downloads
                            </a>
                        </li>
                        <li class="pfe-navigation__menu-item hidden-at-tablet hidden-at-desktop" id="nav-containers--mobile">
                            <a class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Containers" href="https://catalog.redhat.com/software/containers/explore/" >Containers
                            </a>
                        </li>
                        <li class="pfe-navigation__menu-item hidden-at-tablet hidden-at-desktop" id="nav-support--mobile" data-portal-tour-1="3">
                            <a class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Support Cases" href="https://access.redhat.com/support/cases/" >Support Cases
                            </a>
                        </li>                        <li class="pfe-navigation__menu-item">
                            <a href="https://access.redhat.com/products/" class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Products and Services">Products &amp; Services
                            </a>
                            <div class="pfe-navigation__dropdown has-primary-detail">                                <div class="desktop-col-span-2 tablet-col-span-all">
                                    <h3>
                                        <a data-analytics-level="2" data-analytics-category="Products and Services" data-analytics-text="Products" href="https://access.redhat.com/products/">Products
                                        </a>
                                    </h3>
                                    <slot name="main-menu__dropdown--product__product-listing"></slot>
                                </div>                                <div>
                                    <h3 id="nav__products__support">
                                        <a data-analytics-level="2" data-analytics-category="Products and Services" data-analytics-text="Support" href="https://access.redhat.com/support">Support
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__products__support">
                                        <li><a data-analytics-level="3" data-analytics-category="Products and Services|Support" data-analytics-text="Production Support" href="https://access.redhat.com/support/offerings/production/">Production Support
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Products and Services|Support" data-analytics-text="Development Support" href="https://access.redhat.com/support/offerings/developer/">Development Support
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Products and Services|Support" data-analytics-text="Product Life Cycles" href="https://access.redhat.com/product-life-cycles/">Product Life Cycles
                                                    </a></li>
                                    </ul>

                                    <h3 id="nav__products__services">
                                        <a data-analytics-level="2" data-analytics-category="Products and Services" data-analytics-text="Services" href="https://www.redhat.com/en/services">Services
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__products__services">
                                        <li><a data-analytics-level="3" data-analytics-category="Products and Services|Services" data-analytics-text="Consulting" href="https://www.redhat.com/en/services/consulting">Consulting
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Products and Services|Services" data-analytics-text="Technical Account Management" href="https://access.redhat.com/support/offerings/tam/">Technical Account Management
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Products and Services|Services" data-analytics-text="Training and Certifications" href="https://www.redhat.com/en/services/training-and-certification">Training &amp; Certifications
                                                    </a></li>
                                    </ul>
                                </div>                                <div>
                                    <h3 id="nav__products__documentation">
                                        <a data-analytics-level="2" data-analytics-category="Products and Services" data-analytics-text="Documentation" href="https://access.redhat.com/documentation">Documentation
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__products__documentation">
                                        <li><a data-analytics-level="3" data-analytics-category="Products and Services|Documentation" data-analytics-text="Red Hat Enterprise Linux" href="https://access.redhat.com/documentation/en/red_hat_enterprise_linux">Red Hat Enterprise Linux
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Products and Services|Documentation" data-analytics-text="Red Hat JBoss Enterprise Application Platform" href="https://access.redhat.com/documentation/en/red_hat_jboss_enterprise_application_platform">Red Hat JBoss Enterprise Application Platform
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Products and Services|Documentation" data-analytics-text="Red Hat OpenStack Platform" href="https://access.redhat.com/documentation/en/red_hat_openstack_platform">Red Hat OpenStack Platform
                                                    </a></li>
                                                    <li><a data-analytics-level="3" data-analytics-category="Products and Services|Documentation" data-analytics-text="Red Hat OpenShift Container Platform" href="https://access.redhat.com/documentation/en/openshift_container_platform">Red Hat OpenShift Container Platform
                                                        </a></li>
                                    </ul>
                                    <pfe-cta>
                                        <a data-analytics-level="3" data-analytics-category="Products and Services|Documentation" data-analytics-text="All Documentation" data-analytics-linkType="cta" href="https://access.redhat.com/documentation">All Documentation
                                        </a>
                                    </pfe-cta>

                                    <h3 id="nav__products__catalog"><a data-analytics-level="2" data-analytics-category="Products and Services" data-analytics-text="Ecosystem Catalog" href="https://catalog.redhat.com/">Ecosystem Catalog
                                        </a></h3>
                                        <ul aria-labelledby="nav__products__catalog">
                                            <li><a data-analytics-level="3" data-analytics-category="Products and Services|Ecosystem Catalog" data-analytics-text="Red Hat Partner Ecosystem" href="https://access.redhat.com/ecosystem/">Red Hat Partner Ecosystem
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Products and Services|Ecosystem Catalog" data-analytics-text="Partner Resources" href="https://access.redhat.com/ecosystem/partner-resources">Partner Resources
                                                    </a></li>
                                        </ul>
                                </div>
                            </div>
                        </li>                        <li class="pfe-navigation__menu-item">
                            <a class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Tools" href="https://access.redhat.com/labs/">Tools
                            </a>
                            <div class="pfe-navigation__dropdown pfe-navigation__dropdown--3-column">                                <div>
                                    <h3 id="nav__tools__tools" data-analytics-level="2" data-analytics-text="Tools" data-analytics-category="Tools">Tools
                                    </h3>
                                    <ul aria-labelledby="nav__tools__tools">
                                        <li><a data-analytics-level="3" data-analytics-category="Tools|Tools" data-analytics-text="Solution Engine" href="https://access.redhat.com/support/cases/#/troubleshoot">Troubleshoot a product issue
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Tools|Tools" data-analytics-text="Packages" href="https://access.redhat.com/downloads/content/package-browser">Packages
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Tools|Tools" data-analytics-text="Errata" href="https://access.redhat.com/errata/">Errata
                                                    </a></li>
                                    </ul>
                                </div>                                <div>
                                    <h3 id="nav__tools__labs">
                                        <a data-analytics-level="2" data-analytics-category="Tools" data-analytics-text="Customer Portal Labs" href="https://access.redhat.com/labs/">Customer Portal Labs
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__tools__labs">
                                        <li><a data-analytics-level="3" data-analytics-category="Tools|Customer Portal Labs" data-analytics-text="Configuration" href="https://access.redhat.com/labs/#!?type=config">Configuration
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Tools|Customer Portal Labs" data-analytics-text="Deployment" href="https://access.redhat.com/labs/#!?type=deploy">Deployment
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Tools|Customer Portal Labs" data-analytics-text="Security" href="https://access.redhat.com/labs/#!?type=security">Security
                                                    </a></li>                                                    <li><a data-analytics-level="3" data-analytics-category="Tools|Customer Portal Labs" data-analytics-text="Troubleshooting" href="https://access.redhat.com/labs/#!?type=troubleshoot">Troubleshoot
                                                        </a></li>
                                    </ul>
                                    <pfe-cta>
                                        <a data-analytics-level="3" data-analytics-category="Tools|Customer Portal Labs" data-analytics-text="All Labs" data-analytics-linkType="cta" href="https://access.redhat.com/labs/">All labs
                                        </a>
                                    </pfe-cta>
                                </div>                                <div>
                                    <h4 id="nav__tools__red-hat-insights">
                                        <a data-analytics-level="2" data-analytics-category="Tools" data-analytics-text="Red Hat Insights" href="//www.redhat.com/en/technologies/management/insights">Red Hat Insights
                                        </a>
                                    </h4>
                                    <p>Increase visibility into IT operations to detect and resolve technical issues before they impact your business.</p>
                                    <a data-analytics-level="3" data-analytics-category="Tools|Red Hat Insights" data-analytics-text="Learn more" href="https://www.redhat.com/en/technologies/management/insights">Learn More
                                    </a>
                                    <br>
                                    <a data-analytics-level="3" data-analytics-category="Tools|Red Hat Insights" data-analytics-text="Go to Insights" href="https://cloud.redhat.com/insights">Go to Insights
                                    </a>
                                </div>
                            </div>
                        </li>                        <li class="pfe-navigation__menu-item">
                            <a class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Security" href="https://access.redhat.com/security/">Security
                            </a>
                            <div class="pfe-navigation__dropdown pfe-navigation__dropdown--3-column">                                <div>
                                    <h3 id="security__security-center">
                                        <a data-analytics-level="2" data-analytics-category="Security" data-analytics-text="Red Hat Product Security Center" href="https://access.redhat.com/security">Red Hat Product Security Center
                                        </a>
                                    </h3>
                                    <p>Engage with our Red Hat Product Security team, access security updates, and ensure your environments are not exposed to any known security vulnerabilities.
                                    </p>
                                    <pfe-cta pfe-priority="primary">
                                        <a data-analytics-level="3" data-analytics-category="Security|Red Hat Product Security Center" data-analytics-text="Product Security Center" data-analytics-linkType="cta" href="https://access.redhat.com/security/">Product Security Center
                                        </a>
                                    </pfe-cta>
                                </div>                                <div>
                                    <h3 id="nav__security__updates" data-analytics-level="2" data-analytics-text="Security Updates" data-analytics-category="Security">
                                        <a data-analytics-level="2" data-analytics-category="Security" data-analytics-text="Security Updates" href="/security">Security Updates
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__security__updates">
                                        <li><a data-analytics-level="3" data-analytics-category="Security|Security Updates" data-analytics-text="Security Advisories" href="https://access.redhat.com/security/security-updates/#/security-advisories">Security Advisories
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Security|Security Updates" data-analytics-text="Red Hat CVE Database" href="https://access.redhat.com/security/security-updates/#/cve">Red Hat CVE Database
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Security|Security Updates" data-analytics-text="Security Labs" href="https://access.redhat.com/security/security-updates/#/security-labs">Security Labs
                                                    </a></li>
                                    </ul>
                                    <p class="margin-top-xl">Keep your systems secure with Red Hat&#039;s specialized responses to security vulnerabilities.
                                    </p>
                                    <pfe-cta>
                                        <a data-analytics-level="3" data-analytics-category="Security|Security Updates" data-analytics-text="View Responses" data-analytics-linkType="cta" href="https://access.redhat.com/security/vulnerability">View Responses
                                        </a>
                                    </pfe-cta>
                                </div>                                <div>
                                    <h3 id="nav__security__resources">
                                        <a data-analytics-level="2" data-analytics-category="Security" data-analytics-text="Resources" href="https://access.redhat.com/security/overview">Resources
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__security__resources">                                            <li><a data-analytics-level="3" data-analytics-category="Security|Resources" data-analytics-text="Security Blog" href="//redhat.com/en/blog/channel/security">Security Blog
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Security|Resources" data-analytics-text="Security Measurement" href="https://www.redhat.com/security/data/metrics/">Security Measurement
                                                    </a></li>
                                                    <li><a data-analytics-level="3" data-analytics-category="Security|Resources" data-analytics-text="Severity Ratings" href="https://access.redhat.com/security/updates/classification/">Severity Ratings
                                                        </a></li>
                                                        <li><a data-analytics-level="3" data-analytics-category="Security|Resources" data-analytics-text="Backporting Policies" href="https://access.redhat.com/security/updates/backporting/">Backporting Policies
                                                            </a></li>
                                                            <li><a data-analytics-level="3" data-analytics-category="Security|Resources" data-analytics-text="Product Signing (GPG) Keys" href="https://access.redhat.com/security/team/key/">Product Signing (GPG) Keys
                                                                </a></li>
                                    </ul>
                                </div>

                            </div>
                        </li>                        <li class="pfe-navigation__menu-item">
                            <a href="https://access.redhat.com/community/" class="pfe-navigation__menu-link" data-analytics-level="1" data-analytics-text="Community">Community
                            </a>
                            <div class="pfe-navigation__dropdown pfe-navigation__dropdown--3-column">                                <div>
                                    <h3 id="nav__community__cp-community">
                                        <a href="https://access.redhat.com/community" data-analytics-level="2" data-analytics-text="Customer Portal Community" data-analytics-text="Customer Portal Community" data-analytics-category="Community">Customer Portal Community
                                        </a>
                                    </h3>
                                    <ul aria-labelledby="nav__community__cp-community">
                                        <li><a data-analytics-level="3" data-analytics-category="Community|Customer Portal Community" data-analytics-text="Discussions" href="https://access.redhat.com/discussions">Discussions
                                            </a></li>                                                <li><a data-analytics-level="3" data-analytics-category="Community|Customer Portal Community" data-analytics-text="Private Groups" href="https://access.redhat.com/groups/">Private Groups
                                                    </a></li>
                                    </ul>

                                    <pfe-cta pfe-priority="primary">
                                        <a data-analytics-level="3" data-analytics-category="Community|Customer Portal Community" data-analytics-text="Community Activity" data-analytics-linkType="cta" href="https://access.redhat.com/community/">Community Activity
                                        </a>
                                    </pfe-cta>
                                </div>                                <div>
                                    <h3 id="nav__community__events" data-analytics-level="2" data-analytics-text="Customer Events" data-analytics-category="Community">Customer Events
                                    </h3>
                                    <ul aria-labelledby="nav__community__events">
                                        <li><a data-analytics-level="3" data-analytics-category="Community|Customer Events" data-analytics-text="Red Hat Convergence" href="https://access.redhat.com/convergence/">Red Hat Convergence
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-category="Community|Customer Events" data-analytics-text="Red Hat Summit" href="http://www.redhat.com/summit/">Red Hat Summit
                                                </a></li>
                                    </ul>
                                </div>                                <div>
                                    <h3 id="nav__community__stories" data-analytics-level="2" data-analytics-text="Stories" data-analytics-category="Community">Stories
                                    </h3>
                                    <ul aria-labelledby="nav__community__stories">
                                        <li><a data-analytics-level="3" data-analytics-category="Community|Stories" data-analytics-text="Red Hat Subscription Value" href="https://access.redhat.com/subscription-value/">Red Hat Subscription Value
                                            </a></li>
                                            <li><a data-analytics-level="3" data-analytics-text="You Asked. We Acted." data-analytics-category="Community|Stories" href="https://access.redhat.com/you-asked-we-acted/">You Asked. We Acted.
                                                </a></li>
                                                <li><a data-analytics-level="3" data-analytics-category="Community|Stories" data-analytics-text="Open Source Communities" href="http://www.redhat.com/en/open-source">Open Source Communities
                                                    </a></li>
                                    </ul>
                                </div>
                            </div>
                        </li>
                    </ul>                </nav>                <div id="site-search" slot="search" class="utility-link site-search">
                    <div class="content">
                        <form class="ng-pristine ng-valid topSearchForm" id="topSearchForm" name="topSearchForm" action="/search/browse/search/" method="get" enctype="application/x-www-form-urlencoded">
                            <cp-search-autocomplete class="push-bottom" path="/webassets/avalon/j/data.json"></cp-search-autocomplete>                            <div>Or <a href="/support/cases/#/troubleshoot">troubleshoot an issue</a>.
                            </div>
                        </form>
                    </div>
                </div>


                <div slot="secondary-links" id="localesMenu">
                    <button class="pfe-navigation__secondary-link">
                        <pfe-icon icon="web-icon-globe" size="sm" aria-hidden="true"></pfe-icon>English
                    </button>

                    <pfe-navigation-dropdown dropdown-width="single">
                        <h2 class="utility-header">Select Your Language
                        </h2>
                        <ul class="reset">
                            <li><a href="https://access.redhat.com/changeLanguage?language=en" data-lang="en" id="en" data-analytics-text="English">English</a></li>
                            <li><a href="https://access.redhat.com/changeLanguage?language=ko" data-lang="ko" id="ko" data-analytics-text="Korean">한국어</a></li>
                            <li><a href="https://access.redhat.com/changeLanguage?language=ja"    data-lang="ja"    id="ja" data-analytics-text="Japanese">日本語</a></li>
                            <li><a href="https://access.redhat.com/changeLanguage?language=zh_CN" data-lang="zh_CN" id="zh_CN" data-analytics-text="Chinese">中文 (中国)</a></li>
                        </ul>

                    </pfe-navigation-dropdown>
                </div>                <rh-account-dropdown slot="account"></rh-account-dropdown>                <pfe-primary-detail breakpoint-width="600" class="main-menu__dropdown--product__product-listing" slot="main-menu__dropdown--product__product-listing" consistent-height>
                    <h3 slot="details-nav">Infrastructure and Management                    </h3>
                    <div slot="details">
                        <ul>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Infrastructure and Management" data-analytics-text="Red Hat Enterprise Linux" href="https://access.redhat.com/products/red-hat-enterprise-linux/">Red Hat Enterprise Linux
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Infrastructure and Management" data-analytics-text="Red Hat Satellite" href="https://access.redhat.com/products/red-hat-satellite/">Red Hat Satellite
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Infrastructure and Management" data-analytics-text="Red Hat Subscription Management" href="https://access.redhat.com/products/red-hat-subscription-management/">Red Hat Subscription Management
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Infrastructure and Management" data-analytics-text="Red Hat Insights" href="https://access.redhat.com/products/red-hat-insights/">Red Hat Insights
                                </a>
                            </li>
                            <li><a data-analytics-level="3" data-analytics-category="Products and Services|Products:Infrastructure and Management" data-analytics-text="Red Hat Ansible Automation Platform" href="https://access.redhat.com/products/red-hat-ansible-automation-platform/">Red Hat Ansible Automation Platform
                                </a></li>
                        </ul>
                    </div>

                    <h3 slot="details-nav">Cloud Computing                    </h3>
                    <div slot="details">
                        <ul>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat OpenShift" href="https://access.redhat.com/products/openshift">Red Hat OpenShift
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat OpenStack Platform" href="https://access.redhat.com/products/red-hat-openstack-platform/">Red Hat OpenStack Platform
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing Platform" data-analytics-text="Red Hat OpenShift Container Platform" href="https://access.redhat.com/products/red-hat-openshift-container-platform/">Red Hat OpenShift Container Platform
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing Platform" data-analytics-text="Red Hat OpenShift Data Science" href="https://access.redhat.com/products/red-hat-openshift-data-science/">Red Hat OpenShift Data Science
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat OpenShift Dedicated" href="https://access.redhat.com/products/openshift-dedicated-red-hat/">Red Hat OpenShift Dedicated
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing Platform" data-analytics-text="Red Hat Advanced Cluster Security for Kubernetes" href="https://access.redhat.com/products/red-hat-advanced-cluster-security-for-kubernetes/">Red Hat Advanced Cluster Security for Kubernetes
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat Advanced Cluster Management for Kubernetes" href="https://access.redhat.com/products/red-hat-advanced-cluster-management-for-kubernetes/">Red Hat Advanced Cluster Management for Kubernetes
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat Quay" href="https://access.redhat.com/products/red-hat-quay/">Red Hat Quay
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat CodeReady Workspaces" href="https://access.redhat.com/products/red-hat-codeready-workspaces/">OpenShift Dev Spaces
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Cloud Computing" data-analytics-text="Red Hat OpenShift Service on AWS" href="https://access.redhat.com/products/red-hat-openshift-service-aws">Red Hat OpenShift Service on AWS
                                </a>
                            </li>
                        </ul>
                    </div>

                    <h3 slot="details-nav">Storage                    </h3>
                    <div slot="details">
                        <ul>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Storage" data-analytics-text="Red Hat Gluster Storage" href="https://access.redhat.com/products/red-hat-storage/">Red Hat Gluster Storage
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Storage" data-analytics-text="Red Hat Hyperconverged Infrastructure" href="https://access.redhat.com/products/red-hat-hyperconverged-infrastructure/">Red Hat Hyperconverged Infrastructure
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Storage" data-analytics-text="Red Hat Ceph Storage" href="https://access.redhat.com/products/red-hat-ceph-storage/">Red Hat Ceph Storage
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Storage" data-analytics-text="Red Hat Openshift Container Storage" href="https://access.redhat.com/products/red-hat-openshift-data-foundation">Red Hat OpenShift Data Foundation
                                </a>
                            </li>
                        </ul>
                    </div>

                    <h3 slot="details-nav">Runtimes                    </h3>
                    <div slot="details">
                        <ul>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat Runtimes" href="https://access.redhat.com/products/red-hat-runtimes/">Red Hat Runtimes
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat JBoss Enterprise Application Platform" href="https://access.redhat.com/products/red-hat-jboss-enterprise-application-platform/">Red Hat JBoss Enterprise Application Platform
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat Data Grid" href="https://access.redhat.com/products/red-hat-data-grid/">Red Hat Data Grid
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat JBoss Web Server" href="https://access.redhat.com/products/red-hat-jboss-web-server/">Red Hat JBoss Web Server
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat Single Sign On" href="https://access.redhat.com/products/red-hat-single-sign-on/">Red Hat Single Sign On
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat support for Spring Boot" href="https://access.redhat.com/products/spring-boot/">Red Hat support for Spring Boot
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat build of Node.js" href="https://access.redhat.com/products/nodejs/">Red Hat build of Node.js
                                </a>
                            </li>                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Runtimes" data-analytics-text="Red Hat build of Quarkus" href="https://access.redhat.com/products/quarkus/">Red Hat build of Quarkus
                                </a>
                            </li>
                        </ul>
                    </div>

                    <h3 slot="details-nav">Integration and Automation                    </h3>
                    <div slot="details">
                        <ul class="border-bottom" id="portal-menu-border-bottom">
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Integration and Automation" data-analytics-text="Red Hat Application Foundations" href="https://access.redhat.com/products/red-hat-application-foundations/">Red Hat Application Foundations
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Integration and Automation" data-analytics-text="Red Hat Fuse" href="https://access.redhat.com/products/red-hat-fuse/">Red Hat Fuse
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Integration and Automation" data-analytics-text="Red Hat AMQ" href="https://access.redhat.com/products/red-hat-amq/">Red Hat AMQ
                                </a>
                            </li>
                            <li>
                                <a data-analytics-level="3" data-analytics-category="Products and Services|Products:Integration and Automation" data-analytics-text="Red Hat 3scale API Management" href="https://access.redhat.com/products/red-hat-3scale/">Red Hat 3scale API Management
                                </a>
                            </li>
                        </ul>
                    </div>
                    <div slot="details-nav--footer">
                        <pfe-cta pfe-priority="primary">
                            <a href="https://access.redhat.com/products/" class="pfe-navigation__menu-link" data-analytics-level="2" data-analytics-text="All Products" data-analytics-category="Products and Services|Products:" data-analytics-linkType="cta">All Products
                            </a>
                        </pfe-cta>
                    </div>
                </pfe-primary-detail>

            </pfe-navigation>

            <div id="scroll-anchor"></div>

            <!--[if IE 8]>
                <div class="portal-messages">
                <div class="alert alert-warning alert-portal alert-w-icon">
                <span class="icon-warning alert-icon" aria-hidden="true"></span>
                You are using an unsupported web browser. Update to a supported browser for the best experience. <a href="/announcements/2120951">Read the announcement</a>.
                </div>
                </div>
            <![endif]-->
            <!--[if IE 9]>
                <div class="portal-messages">
                <div class="alert alert-warning alert-portal alert-w-icon">
                <span class="icon-warning alert-icon" aria-hidden="true"></span>As of March 1, 2016, the Red Hat Customer Portal will no longer support Internet Explorer 9. See our new <a href="/help/browsers">browser support policy</a> for more information.
                </div>
                </div>
            <![endif]-->
            <div id="site-section"></div>
        </header>
        <!--googleon: all-->

        <main id="cp-main" class="portal-content-area">
            <div id="cp-content" class="main-content">                            <!-- /CP_PRIMER_HEADER -->

      <div class="container">
        

                                                                                                        <script>breadcrumbs = [["Products & Services","\/products\/"],["Product Documentation","\/documentation"],["OpenShift Container Platform","\/documentation\/en-us\/openshift_container_platform"],["4.13","\/documentation\/en-us\/openshift_container_platform\/4.13"],["Storage","\/documentation\/en-us\/openshift_container_platform\/4.13\/html\/storage"],["Storage","\/documentation\/en-us\/openshift_container_platform\/4.13\/html\/storage\/--single-page-document--"]]</script>

<div data-drupal-messages-fallback class="hidden"></div>


    </div>
        <div class="container">
        

  

  


  <article class="pvof-doc__content-wrapper__outer pvof-doc__content-wrapper__outer--css-not-removed">
    <script>
      'use strict';

            var $outerWrapper = document.querySelector('.pvof-doc__content-wrapper__outer');
      if ($outerWrapper && $outerWrapper.closest) {
        var $containerWrapper = $outerWrapper.closest('.container');
        if ($containerWrapper) {
          $containerWrapper.classList.remove('container');
          $containerWrapper.classList.add('j-chrome-content-container');
        }
      }

            var cssRemoved = false;
      try {
        var $crapCss = document.querySelectorAll(
          'link[href*="/chrome_themes/nimbus/css/pages.css"], link[href*="/chrome_themes/nimbus/css/components.css"]'
        );
        if ($crapCss.length) {
          for (let index = 0; index < $crapCss.length; index++) {
            const $stylesheet = $crapCss[index];
            $stylesheet.remove();
          }
        }
        cssRemoved = true;
      }
      catch (error) {
        console.error('Ran into an issue while trying to retheme page', error);
        cssRemoved = false;
      }

            if (cssRemoved) {
        var $pvofOuterWrapper = document.querySelector('.pvof-doc__content-wrapper__outer--css-not-removed');
        if ($pvofOuterWrapper) {
          $pvofOuterWrapper.classList.remove('pvof-doc__content-wrapper__outer--css-not-removed');
        }
      }
    </script>
    <div itemscope="" itemtype="https://schema.org/TechArticle" itemref="techArticle-md1 techArticle-md2 techArticle-md3"></div>
    <div itemscope="" itemtype="https://schema.org/SoftwareApplication" itemref="softwareApplication-md1 softwareApplication-md2 softwareApplication-md3 softwareApplication-md4"></div>
    <div class="pvof-doc__content-wrapper pvof-doc__content-wrapper--has-sidebar">
                                <div class="pvof-doc__content-wrapper__inner j-superdoc j-superdoc--has-nav">
                            <div class="pvof-sidebar__wrapper j-doc-nav j-superdoc__nav">
            <div class="j-sidebar__menu-container">
              <button class="j-sidebar__menu-trigger content-expander__trigger">
                <span class="j-sidebar__menu-trigger__open-text">Jump To</span>
                <span class="j-sidebar__menu-trigger__close-text">Close</span>
              </button>

              <div class="pvof-sidebar__inner-wrapper j-doc-nav__wrapper content-expander">
                <div class="j-sidebar__menu-details-container">
                  <button class="j-sidebar__menu-details-button j-sidebar__menu-details-button--expand">
                    Expand all
                  </button>
                  <button class="j-sidebar__menu-details-button j-sidebar__menu-details-button--collapse">
                    Collapse all
                  </button>
                </div>
                

  <nav id="pvof-doc__toc" class="pvof-doc__toc">
  <h2 class="j-doc-nav__title" id="j-doc-nav__title">
    Table of contents
  </h2>
  <div class="pvof-doc__toc-inner">
              <ol class="j-doc-nav__list" aria-labelledby="j-doc-nav__title">
                  <li class="j-doc-nav__list-item">
                                    

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage" class="j-doc-nav__link ">
    Storage
  </a>
  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-overview" class="j-doc-nav__link j-doc-nav__link--has-children">
    1. OpenShift Container Platform storage overview
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "1. OpenShift Container Platform storage overview"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "1. OpenShift Container Platform storage overview"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#openshift-storage-common-terms_storage-overview" class="j-doc-nav__link ">
    1.1. Glossary of common terms for OpenShift Container Platform storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-types" class="j-doc-nav__link j-doc-nav__link--has-children">
    1.2. Storage types
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "1.2. Storage types"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "1.2. Storage types"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage" class="j-doc-nav__link ">
    1.2.1. Ephemeral storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage" class="j-doc-nav__link ">
    1.2.2. Persistent storage
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#container-storage-interface" class="j-doc-nav__link ">
    1.3. Container Storage Interface (CSI)
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#dynamic-provisioning-overview" class="j-doc-nav__link ">
    1.4. Dynamic Provisioning
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#understanding-ephemeral-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    2. Understanding ephemeral storage
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "2. Understanding ephemeral storage"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "2. Understanding ephemeral storage"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-ephemeral-storage-overview_understanding-ephemeral-storage" class="j-doc-nav__link ">
    2.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-ephemeral-storage-types_understanding-ephemeral-storage" class="j-doc-nav__link ">
    2.2. Types of ephemeral storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-ephemeral-storage-manage_understanding-ephemeral-storage" class="j-doc-nav__link ">
    2.3. Ephemeral storage management
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-ephemeral-storage-monitoring_understanding-ephemeral-storage" class="j-doc-nav__link ">
    2.4. Monitoring ephemeral storage
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#understanding-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    3. Understanding persistent storage
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "3. Understanding persistent storage"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "3. Understanding persistent storage"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-overview_understanding-persistent-storage" class="j-doc-nav__link ">
    3.1. Persistent storage overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lifecycle-volume-claim_understanding-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    3.2. Lifecycle of a volume and claim
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "3.2. Lifecycle of a volume and claim"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "3.2. Lifecycle of a volume and claim"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#provisioning_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.1. Provision storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#binding_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.2. Bind claims
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#using-pods_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.3. Use pods and claimed PVs
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pvcprotection_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.4. Storage Object in Use Protection
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#releasing_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.5. Release a persistent volume
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#reclaiming_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.6. Reclaim policy for persistent volumes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#reclaim-manual_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.7. Reclaiming a persistent volume manually
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#reclaim-policy_understanding-persistent-storage" class="j-doc-nav__link ">
    3.2.8. Changing the reclaim policy of a persistent volume
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-volumes_understanding-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    3.3. Persistent volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "3.3. Persistent volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "3.3. Persistent volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#types-of-persistent-volumes_understanding-persistent-storage" class="j-doc-nav__link ">
    3.3.1. Types of PVs
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pv-capacity_understanding-persistent-storage" class="j-doc-nav__link ">
    3.3.2. Capacity
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pv-access-modes_understanding-persistent-storage" class="j-doc-nav__link ">
    3.3.3. Access modes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pv-phase_understanding-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    3.3.4. Phase
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "3.3.4. Phase"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "3.3.4. Phase"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pv-mount-options_understanding-persistent-storage" class="j-doc-nav__link ">
    3.3.4.1. Mount options
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-volume-claims_understanding-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    3.4. Persistent volume claims
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "3.4. Persistent volume claims"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "3.4. Persistent volume claims"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pvc-storage-class_understanding-persistent-storage" class="j-doc-nav__link ">
    3.4.1. Storage classes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pvc-access-modes_understanding-persistent-storage" class="j-doc-nav__link ">
    3.4.2. Access modes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pvc-resources_understanding-persistent-storage" class="j-doc-nav__link ">
    3.4.3. Resources
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#pvc-claims-as-volumes_understanding-persistent-storage" class="j-doc-nav__link ">
    3.4.4. Claims as volumes
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#block-volume-support_understanding-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    3.5. Block volume support
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "3.5. Block volume support"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "3.5. Block volume support"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#block-volume-examples_understanding-persistent-storage" class="j-doc-nav__link ">
    3.5.1. Block volume examples
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#using_fsGroup_understanding-persistent-storage" class="j-doc-nav__link ">
    3.6. Using fsGroup to reduce pod timeouts
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#configuring-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4. Configuring persistent storage
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4. Configuring persistent storage"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4. Configuring persistent storage"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-aws" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.1. Persistent storage using AWS Elastic Block Store
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.1. Persistent storage using AWS Elastic Block Store"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.1. Persistent storage using AWS Elastic Block Store"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-create-storage-class_persistent-storage-aws" class="j-doc-nav__link ">
    4.1.1. Creating the EBS storage class
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#creating-the-persistent-volume-claim" class="j-doc-nav__link ">
    4.1.2. Creating the persistent volume claim
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#volume-format-AWS_persistent-storage-aws" class="j-doc-nav__link ">
    4.1.3. Volume format
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#maximum-number-of-ebs-volumes-on-a-node_persistent-storage-aws" class="j-doc-nav__link ">
    4.1.4. Maximum number of EBS volumes on a node
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#aws-container-persistent-volumes-encrypt_persistent-storage-aws" class="j-doc-nav__link ">
    4.1.5. Encrypting container persistent volumes on AWS with a KMS key
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources_persistent-storage-aws" class="j-doc-nav__link ">
    4.1.6. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-azure" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.2. Persistent storage using Azure
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.2. Persistent storage using Azure"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.2. Persistent storage using Azure"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-create-azure-storage-class_persistent-storage-azure" class="j-doc-nav__link ">
    4.2.1. Creating the Azure storage class
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#creating-the-persistent-volume-claim-2" class="j-doc-nav__link ">
    4.2.2. Creating the persistent volume claim
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#volume-format-azure_persistent-storage-azure" class="j-doc-nav__link ">
    4.2.3. Volume format
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#machineset-azure-ultra-disk_persistent-storage-azure" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.2.4. Machine sets that deploy machines with ultra disks using PVCs
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.2.4. Machine sets that deploy machines with ultra disks using PVCs"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.2.4. Machine sets that deploy machines with ultra disks using PVCs"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#machineset-creating-azure-ultra-disk_persistent-storage-azure" class="j-doc-nav__link ">
    4.2.4.1. Creating machines with ultra disks by using machine sets
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#machineset-troubleshooting-azure-ultra-disk_persistent-storage-azure" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.2.4.2. Troubleshooting resources for machine sets that enable ultra disks
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.2.4.2. Troubleshooting resources for machine sets that enable ultra disks"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.2.4.2. Troubleshooting resources for machine sets that enable ultra disks"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ts-pvc-mounting-ultra_persistent-storage-azure" class="j-doc-nav__link ">
    4.2.4.2.1. Unable to mount a persistent volume claim backed by an ultra disk
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-azure-file" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.3. Persistent storage using Azure File
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.3. Persistent storage using Azure File"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.3. Persistent storage using Azure File"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#create-azure-file-secret_persistent-storage-azure-file" class="j-doc-nav__link ">
    4.3.1. Create the Azure File share persistent volume claim
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#create-azure-file-pod_persistent-storage-azure-file" class="j-doc-nav__link ">
    4.3.2. Mount the Azure File share in a pod
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-cinder" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.4. Persistent storage using Cinder
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.4. Persistent storage using Cinder"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.4. Persistent storage using Cinder"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-cinder-provisioning_persistent-storage-cinder" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.4.1. Manual provisioning with Cinder
  </a>
                              <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.4.1. Manual provisioning with Cinder"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.4.1. Manual provisioning with Cinder"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-cinder-creating-pv_persistent-storage-cinder" class="j-doc-nav__link ">
    4.4.1.1. Creating the persistent volume
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-cinder-pv-format_persistent-storage-cinder" class="j-doc-nav__link ">
    4.4.1.2. Persistent volume formatting
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-cinder-volume-security_persistent-storage-cinder" class="j-doc-nav__link ">
    4.4.1.3. Cinder volume security
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-fibre" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.5. Persistent storage using Fibre Channel
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.5. Persistent storage using Fibre Channel"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.5. Persistent storage using Fibre Channel"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#provisioning-fibre_persistent-storage-fibre" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.5.1. Provisioning
  </a>
                              <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.5.1. Provisioning"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.5.1. Provisioning"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#enforcing-disk-quota_persistent-storage-fibre" class="j-doc-nav__link ">
    4.5.1.1. Enforcing disk quotas
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#fibre-volume-security_persistent-storage-fibre" class="j-doc-nav__link ">
    4.5.1.2. Fibre Channel volume security
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-flexvolume" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.6. Persistent storage using FlexVolume
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.6. Persistent storage using FlexVolume"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.6. Persistent storage using FlexVolume"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#flexvolume-drivers_persistent-storage-flexvolume" class="j-doc-nav__link ">
    4.6.1. About FlexVolume drivers
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#flexvolume-driver-example_persistent-storage-flexvolume" class="j-doc-nav__link ">
    4.6.2. FlexVolume driver example
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#flexvolume-installing_persistent-storage-flexvolume" class="j-doc-nav__link ">
    4.6.3. Installing FlexVolume drivers
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#flexvolume-driver-consuming_persistent-storage-flexvolume" class="j-doc-nav__link ">
    4.6.4. Consuming storage using FlexVolume drivers
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-gce" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.7. Persistent storage using GCE Persistent Disk
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.7. Persistent storage using GCE Persistent Disk"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.7. Persistent storage using GCE Persistent Disk"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-create-storage-class_persistent-storage-gce" class="j-doc-nav__link ">
    4.7.1. Creating the GCE storage class
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#creating-the-persistent-volume-claim-3" class="j-doc-nav__link ">
    4.7.2. Creating the persistent volume claim
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#volume-format-GCE_persistent-storage-gce" class="j-doc-nav__link ">
    4.7.3. Volume format
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-iscsi" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.8. Persistent storage using iSCSI
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.8. Persistent storage using iSCSI"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.8. Persistent storage using iSCSI"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-iscsi-provisioning_persistent-storage-iscsi" class="j-doc-nav__link ">
    4.8.1. Provisioning
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#enforcing-disk-quotas-iscsi_persistent-storage-iscsi" class="j-doc-nav__link ">
    4.8.2. Enforcing disk quotas
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#volume-security-iscsi_persistent-storage-iscsi" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.8.3. iSCSI volume security
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.8.3. iSCSI volume security"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.8.3. iSCSI volume security"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#challenge-handshake-authentication-protocol-chap-configuration" class="j-doc-nav__link ">
    4.8.3.1. Challenge Handshake Authentication Protocol (CHAP) configuration
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#iscsi-multipath_persistent-storage-iscsi" class="j-doc-nav__link ">
    4.8.4. iSCSI multipathing
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#iscsi-custom-iqn_persistent-storage-iscsi" class="j-doc-nav__link ">
    4.8.5. iSCSI custom initiator IQN
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-nfs" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.9. Persistent storage using NFS
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.9. Persistent storage using NFS"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.9. Persistent storage using NFS"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-nfs-provisioning_persistent-storage-nfs" class="j-doc-nav__link ">
    4.9.1. Provisioning
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#nfs-enforcing-disk-quota_persistent-storage-nfs" class="j-doc-nav__link ">
    4.9.2. Enforcing disk quotas
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#nfs-volume-security_persistent-storage-nfs" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.9.3. NFS volume security
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.9.3. NFS volume security"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.9.3. NFS volume security"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-persistent-storage-nfs-group-ids_persistent-storage-nfs" class="j-doc-nav__link ">
    4.9.3.1. Group IDs
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#nfs-user-id_persistent-storage-nfs" class="j-doc-nav__link ">
    4.9.3.2. User IDs
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#nfs-selinux_persistent-storage-nfs" class="j-doc-nav__link ">
    4.9.3.3. SELinux
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#export-settings" class="j-doc-nav__link ">
    4.9.3.4. Export settings
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#nfs-reclaiming-resources_persistent-storage-nfs" class="j-doc-nav__link ">
    4.9.4. Reclaiming resources
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-configuration-and-troubleshooting" class="j-doc-nav__link ">
    4.9.5. Additional configuration and troubleshooting
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#red-hat-openshift-data-foundation" class="j-doc-nav__link ">
    4.10. Red Hat OpenShift Data Foundation
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-vsphere" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.11. Persistent storage using VMware vSphere volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.11. Persistent storage using VMware vSphere volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.11. Persistent storage using VMware vSphere volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#dynamically-provisioning-vmware-vsphere-volumes" class="j-doc-nav__link ">
    4.11.1. Dynamically provisioning VMware vSphere volumes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#prerequisites" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.11.2. Prerequisites
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.11.2. Prerequisites"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.11.2. Prerequisites"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-dynamic-provisioning_persistent-storage-efs" class="j-doc-nav__link ">
    4.11.2.1. Dynamically provisioning VMware vSphere volumes using the UI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-dynamic-provisioning-cli_persistent-storage-efs" class="j-doc-nav__link ">
    4.11.2.2. Dynamically provisioning VMware vSphere volumes using the CLI
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-static-provisioning_persistent-storage-efs" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.11.3. Statically provisioning VMware vSphere volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.11.3. Statically provisioning VMware vSphere volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.11.3. Statically provisioning VMware vSphere volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-formatting-volumes_persistent-storage-efs" class="j-doc-nav__link ">
    4.11.3.1. Formatting VMware vSphere volumes
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-local-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12. Persistent storage using local storage
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12. Persistent storage using local storage"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12. Persistent storage using local storage"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-local-volume" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.1. Persistent storage using local volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.1. Persistent storage using local volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.1. Persistent storage using local volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-storage-install_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.1. Installing the Local Storage Operator
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-volume-cr_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.2. Provisioning local volumes by using the Local Storage Operator
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-create-cr-manual_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.3. Provisioning local volumes without the Local Storage Operator
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#create-local-pvc_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.4. Creating the local volume persistent volume claim
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-pod_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.5. Attach the local claim
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-storage-discovery_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.6. Automating discovery and provisioning for local storage devices
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-tolerations_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.7. Using tolerations with Local Storage Operator pods
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-storage-metrics_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.8. Local Storage Operator Metrics
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#deleting-the-local-storage-operator-resources" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.1.9. Deleting the Local Storage Operator resources
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.1.9. Deleting the Local Storage Operator resources"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.1.9. Deleting the Local Storage Operator resources"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-removing-device_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.9.1. Removing a local volume or local volume set
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#local-storage-uninstall_persistent-storage-local" class="j-doc-nav__link ">
    4.12.1.9.2. Uninstalling the Local Storage Operator
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-hostpath" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.2. Persistent storage using hostPath
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.2. Persistent storage using hostPath"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.2. Persistent storage using hostPath"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-hostpath-about_persistent-storage-hostpath" class="j-doc-nav__link ">
    4.12.2.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#hostpath-static-provisioning_persistent-storage-hostpath" class="j-doc-nav__link ">
    4.12.2.2. Statically provisioning hostPath volumes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-hostpath-pod_persistent-storage-hostpath" class="j-doc-nav__link ">
    4.12.2.3. Mounting the hostPath share in a privileged pod
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-using-lvms" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.3. Persistent storage using logical volume manager storage
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.3. Persistent storage using logical volume manager storage"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.3. Persistent storage using logical volume manager storage"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-preface-sno-ran_logical-volume-manager-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.3.1. Deploying LVM Storage on single-node OpenShift clusters
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.3.1. Deploying LVM Storage on single-node OpenShift clusters"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.3.1. Deploying LVM Storage on single-node OpenShift clusters"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-deployment-requirements-for-sno-ran_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.1. Requirements
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-deployment-limitations-for-sno-ran_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.2. Limitations
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#install-lvms-operator-cli_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.3. Installing LVM Storage with the CLI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-installing-lvms-with-web-console_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.4. Installing LVM Storage with the web console
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-unstalling-lvms-with-web-console_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.5. Uninstalling LVM Storage installed using the OpenShift Web Console
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-installing-lvms-disconnected-env_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.6. Installing LVM Storage in a disconnected environment
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-installing-odf-logical-volume-manager-operator-using-rhacm_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.7. Installing LVM Storage using RHACM
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-uninstalling-lvms-rhacm_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.1.8. Uninstalling LVM Storage installed using RHACM
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-creating-lvms-cluster_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.2. Creating a Logical Volume Manager cluster on a single-node OpenShift worker node
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-provisioning-storage-using-lvms_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.3. Provisioning storage using LVM Storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-monitoring-using-lvms_logical-volume-manager-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.3.4. Monitoring LVM Storage
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.3.4. Monitoring LVM Storage"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.3.4. Monitoring LVM Storage"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-monitoring-using-lvms-metrics_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.4.1. Metrics
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-monitoring-using-lvms-alerts_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.4.2. Alerts
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-scaling-storage-of-single-node-openshift-cluster-con_logical-volume-manager-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.3.5. Scaling storage of single-node OpenShift clusters
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.3.5. Scaling storage of single-node OpenShift clusters"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.3.5. Scaling storage of single-node OpenShift clusters"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-scaling-storage-of-single-node-openshift-cluster_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.5.1. Scaling up storage by adding capacity to your single-node OpenShift cluster
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-scaling-storage-of-single-node-openshift-cluster-using-rhacm_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.5.2. Scaling up storage by adding capacity to your single-node OpenShift cluster using RHACM
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-scaling-expand-pvc_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.5.3. Expanding PVCs
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-upgrading-lvms-on-sno_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.6. Upgrading LVM Storage on single-node OpenShift clusters
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-volume-snapsot-for-sno_logical-volume-manager-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.3.7. Volume snapshots for single-node OpenShift
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.3.7. Volume snapshots for single-node OpenShift"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.3.7. Volume snapshots for single-node OpenShift"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-creating-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.7.1. Creating volume snapshots in single-node OpenShift
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-restoring-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.7.2. Restoring volume snapshots in single-node OpenShift
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-deleting-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.7.3. Deleting volume snapshots in single-node OpenShift
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-volume-cloning-for-single-node-openshift-cluster_logical-volume-manager-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.3.8. Volume cloning for single-node OpenShift
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.3.8. Volume cloning for single-node OpenShift"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.3.8. Volume cloning for single-node OpenShift"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-creating-volume-clones-in-single-node-openshift_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.8.1. Creating volume clones in single-node OpenShift
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-deleting-cloned-volumes-in-single-node-openshift_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.8.2. Deleting cloned volumes in single-node OpenShift
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-dowloading-log-files-and-diagnostics_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.9. Downloading log files and diagnostic information using must-gather
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#lvms-reference-file_logical-volume-manager-storage" class="j-doc-nav__link ">
    4.12.3.10. LVM Storage reference YAML file
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#troubleshooting-local-persistent-storage" class="j-doc-nav__link j-doc-nav__link--has-children">
    4.12.4. Troubleshooting local persistent storage using LVMS
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "4.12.4. Troubleshooting local persistent storage using LVMS"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "4.12.4. Troubleshooting local persistent storage using LVMS"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#investigating-a-pvc-stuck-in-the-pending-state_troubleshooting-local-persistent-storage-using-lvms" class="j-doc-nav__link ">
    4.12.4.1. Investigating a PVC stuck in the Pending state
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#recovering-from-missing-lvms-or-operator-components_troubleshooting-local-persistent-storage-using-lvms" class="j-doc-nav__link ">
    4.12.4.2. Recovering from missing LVMS or Operator components
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#recovering-from-node-failure_troubleshooting-local-persistent-storage-using-lvms" class="j-doc-nav__link ">
    4.12.4.3. Recovering from node failure
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#recovering-from-disk-failure_troubleshooting-local-persistent-storage-using-lvms" class="j-doc-nav__link ">
    4.12.4.4. Recovering from disk failure
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms" class="j-doc-nav__link ">
    4.12.4.5. Performing a forced cleanup
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#using-container-storage-interface-csi" class="j-doc-nav__link j-doc-nav__link--has-children">
    5. Using Container Storage Interface (CSI)
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5. Using Container Storage Interface (CSI)"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5. Using Container Storage Interface (CSI)"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.1. Configuring CSI volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.1. Configuring CSI volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.1. Configuring CSI volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-architecture_persistent-storage-csi" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.1.1. CSI architecture
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.1.1. CSI architecture"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.1.1. CSI architecture"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#external-csi-contollers_persistent-storage-csi" class="j-doc-nav__link ">
    5.1.1.1. External CSI controllers
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-driver-daemonset_persistent-storage-csi" class="j-doc-nav__link ">
    5.1.1.2. CSI driver daemon set
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-drivers-supported_persistent-storage-csi" class="j-doc-nav__link ">
    5.1.2. CSI drivers supported by OpenShift Container Platform
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-dynamic-provisioning_persistent-storage-csi" class="j-doc-nav__link ">
    5.1.3. Dynamic provisioning
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-example-usage_persistent-storage-csi" class="j-doc-nav__link ">
    5.1.4. Example using the CSI driver
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vol-populator_persistent-storage-csi" class="j-doc-nav__link ">
    5.1.5. Volume populators
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-csi-inline" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.2. CSI inline ephemeral volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.2. CSI inline ephemeral volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.2. CSI inline ephemeral volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-csi-inline-overview_ephemeral-storage-csi-inline" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.2.1. Overview of CSI inline ephemeral volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.2.1. Overview of CSI inline ephemeral volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.2.1. Overview of CSI inline ephemeral volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#support-limitations" class="j-doc-nav__link ">
    5.2.1.1. Support limitations
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-csi-overview-admin-plugin_ephemeral-storage-csi-inline" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.2.2. CSI Volume Admission plugin
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.2.2. CSI Volume Admission plugin"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.2.2. CSI Volume Admission plugin"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-admission-plugin" class="j-doc-nav__link ">
    5.2.2.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#security-profile-enforcement" class="j-doc-nav__link ">
    5.2.2.2. Pod security profile enforcement
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#security-profile-warning" class="j-doc-nav__link ">
    5.2.2.3. Pod security profile warning
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#security-profile-audit" class="j-doc-nav__link ">
    5.2.2.4. Pod security profile audit
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#admission-plugin-default-behavior" class="j-doc-nav__link ">
    5.2.2.5. Default behavior for the CSI Volume Admission plugin
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-csi-inline-pod_ephemeral-storage-csi-inline" class="j-doc-nav__link ">
    5.2.3. Embedding a CSI inline ephemeral volume in the pod specification
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources_ephemeral-storage-csi-inline" class="j-doc-nav__link ">
    5.2.4. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.3. Shared Resource CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.3. Shared Resource CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.3. Shared Resource CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.1. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-sharing-secrets-across-namespaces_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.2. Sharing secrets across namespaces
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-using-a-sharedsecrets-resource-in-a-pod_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.3. Using a SharedSecret instance in a pod
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-sharing-configmaps-across-namespaces_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.4. Sharing a config map across namespaces
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-using-a-sharedconfigmap-object-in-a-pod_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.5. Using a SharedConfigMap instance in a pod
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-additional-support-limitations-for-shared-resource-csi-driver_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.6. Additional support limitations for the Shared Resource CSI Driver
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-additional-details-about-volumeattributes-on-shared-resource-pod-volumes_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.3.7. Additional details about VolumeAttributes on shared resource pod volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.3.7. Additional details about VolumeAttributes on shared resource pod volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.3.7. Additional details about VolumeAttributes on shared resource pod volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#the-literal-refreshresource-literal-attribute" class="j-doc-nav__link ">
    5.3.7.1. The refreshResource attribute
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#the-literal-refreshresources-literal-attribute" class="j-doc-nav__link ">
    5.3.7.2. The refreshResources attribute
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#validation-of-volumeattributes-before-provisioning-a-shared-resource-volume-for-a-pod" class="j-doc-nav__link ">
    5.3.7.3. Validation of volumeAttributes before provisioning a shared resource volume for a pod
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-integration-between-shared-resources-insights-operator-and-openshift-builds_ephemeral-storage-shared-resource-csi-driver-operator" class="j-doc-nav__link ">
    5.3.8. Integration between shared resources, Insights Operator, and OpenShift Container Platform Builds
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.4. CSI volume snapshots
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.4. CSI volume snapshots"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.4. CSI volume snapshots"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-overview_persistent-storage-csi-snapshots" class="j-doc-nav__link ">
    5.4.1. Overview of CSI volume snapshots
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-controller-sidecar_persistent-storage-csi-snapshots" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.4.2. CSI snapshot controller and sidecar
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.4.2. CSI snapshot controller and sidecar"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.4.2. CSI snapshot controller and sidecar"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#external-controller" class="j-doc-nav__link ">
    5.4.2.1. External controller
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#external-sidecar" class="j-doc-nav__link ">
    5.4.2.2. External sidecar
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-operator_persistent-storage-csi-snapshots" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.4.3. About the CSI Snapshot Controller Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.4.3. About the CSI Snapshot Controller Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.4.3. About the CSI Snapshot Controller Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#volume-snapshot-crds" class="j-doc-nav__link ">
    5.4.3.1. Volume snapshot CRDs
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-provision_persistent-storage-csi-snapshots" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.4.4. Volume snapshot provisioning
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.4.4. Volume snapshot provisioning"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.4.4. Volume snapshot provisioning"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#snapshots-dynamic-provisioning_persistent-storage-csi-snapshots" class="j-doc-nav__link ">
    5.4.4.1. Dynamic provisioning
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#snapshots-manual-provisioning_persistent-storage-csi-snapshots" class="j-doc-nav__link ">
    5.4.4.2. Manual provisioning
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-create_persistent-storage-csi-snapshots" class="j-doc-nav__link ">
    5.4.5. Creating a volume snapshot
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-delete_persistent-storage-csi-snapshots" class="j-doc-nav__link ">
    5.4.6. Deleting a volume snapshot
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-snapshots-restore_persistent-storage-csi-snapshots" class="j-doc-nav__link ">
    5.4.7. Restoring a volume snapshot
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-cloning" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.5. CSI volume cloning
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.5. CSI volume cloning"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.5. CSI volume cloning"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-cloning-overview_persistent-storage-csi-cloning" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.5.1. Overview of CSI volume cloning
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.5.1. Overview of CSI volume cloning"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.5.1. Overview of CSI volume cloning"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#support-limitations-2" class="j-doc-nav__link ">
    5.5.1.1. Support limitations
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-cloning-provisioning_persistent-storage-csi-cloning" class="j-doc-nav__link ">
    5.5.2. Provisioning a CSI volume clone
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-sc-manage" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.6. Managing the default storage class
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.6. Managing the default storage class"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.6. Managing the default storage class"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview" class="j-doc-nav__link ">
    5.6.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-sc-managing_persistent-storage-csi-sc-manage" class="j-doc-nav__link ">
    5.6.2. Managing the default storage class using the web console
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-sc-managing-cli_persistent-storage-csi-sc-manage" class="j-doc-nav__link ">
    5.6.3. Managing the default storage class using the CLI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-sc-multiple-none_persistent-storage-csi-sc-manage" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.6.4. Absent or multiple default storage classes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.6.4. Absent or multiple default storage classes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.6.4. Absent or multiple default storage classes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#multiple-default-storage-classes" class="j-doc-nav__link ">
    5.6.4.1. Multiple default storage classes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#absent-default-storage-class" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.6.4.2. Absent default storage class
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.6.4.2. Absent default storage class"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.6.4.2. Absent default storage class"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#procedure" class="j-doc-nav__link ">
    5.6.4.2.1. Procedure
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#change-default-storage-class_persistent-storage-csi-sc-manage" class="j-doc-nav__link ">
    5.6.5. Changing the default storage class
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-migration" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.7. CSI automatic migration
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.7. CSI automatic migration"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.7. CSI automatic migration"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-migration-overview_persistent-storage-csi-migration" class="j-doc-nav__link ">
    5.7.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-migration-sc-implications_persistent-storage-csi-migration" class="j-doc-nav__link ">
    5.7.2. Storage class implications
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-migration-sc-vsphere_persistent-storage-csi-migration" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.7.3. vSphere automatic migration
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.7.3. vSphere automatic migration"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.7.3. vSphere automatic migration"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#new-installations-of-openshift-container-platform" class="j-doc-nav__link ">
    5.7.3.1. New installations of OpenShift Container Platform
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#upgrading-openshift_persistent-storage-csi-migration" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.7.3.2. Upgrading OpenShift Container Platform
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.7.3.2. Upgrading OpenShift Container Platform"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.7.3.2. Upgrading OpenShift Container Platform"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#using-the-web-console-to-opt-in-to-automatic-csi-migration" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.7.3.2.1. Using the web console to opt in to automatic CSI migration
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.7.3.2.1. Using the web console to opt in to automatic CSI migration"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.7.3.2.1. Using the web console to opt in to automatic CSI migration"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#prerequisites-2" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.7.3.2.1.1. Prerequisites
  </a>
                              <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.7.3.2.1.1. Prerequisites"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.7.3.2.1.1. Prerequisites"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#procedure-2" class="j-doc-nav__link ">
    5.7.3.2.1.1.1. Procedure
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#using-the-cli-to-opt-in-to-automatic-csi-migration" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.7.3.2.2. Using the CLI to opt in to automatic CSI migration
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.7.3.2.2. Using the CLI to opt in to automatic CSI migration"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.7.3.2.2. Using the CLI to opt in to automatic CSI migration"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#prerequisites-3" class="j-doc-nav__link ">
    5.7.3.2.2.1. Prerequisites
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#procedure-3" class="j-doc-nav__link ">
    5.7.3.2.2.2. Procedure
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ephemeral-storage-csi-vol-detach-non-graceful-shutdown" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.8. Detach CSI volumes after non-graceful node shutdown
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.8. Detach CSI volumes after non-graceful node shutdown"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.8. Detach CSI volumes after non-graceful node shutdown"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vol-detach-non-graceful-overview_ephemeral-storage-csi-vol-detach-non-graceful-shutdown" class="j-doc-nav__link ">
    5.8.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vol-detach-non-graceful-shutdown-procedure_ephemeral-storage-csi-vol-detach-non-graceful-shutdown" class="j-doc-nav__link ">
    5.8.2. Adding an out-of-service taint manually for automatic volume detachment
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-alicloud-disk" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.9. AliCloud Disk CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.9. AliCloud Disk CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.9. AliCloud Disk CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-alicloud-disk-overview" class="j-doc-nav__link ">
    5.9.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-alicloud-disk" class="j-doc-nav__link ">
    5.9.2. About CSI
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-ebs" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.10. AWS Elastic Block Store CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.10. AWS Elastic Block Store CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.10. AWS Elastic Block Store CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-2" class="j-doc-nav__link ">
    5.10.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-ebs" class="j-doc-nav__link ">
    5.10.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#byok_persistent-storage-csi-ebs" class="j-doc-nav__link ">
    5.10.3. User-managed encryption
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-aws-efs" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.11. AWS Elastic File Service CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.11. AWS Elastic File Service CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.11. AWS Elastic File Service CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-3" class="j-doc-nav__link ">
    5.11.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-efs-csi-driver-operator-setup_persistent-storage-csi-aws-efs" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.11.3. Setting up the AWS EFS CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.11.3. Setting up the AWS EFS CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.11.3. Setting up the AWS EFS CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-olm-operator-install_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.3.1. Installing the AWS EFS CSI Driver Operator
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#efs-sts_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.3.2. Configuring AWS EFS CSI Driver Operator with Security Token Service
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-efs-driver-install_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.3.3. Installing the AWS EFS CSI Driver
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-create-storage-class_persistent-storage-csi-aws-efs" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.11.4. Creating the AWS EFS storage class
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.11.4. Creating the AWS EFS storage class"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.11.4. Creating the AWS EFS storage class"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-create-storage-class-console_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.4.1. Creating the AWS EFS storage class using the console
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-create-storage-class-cli_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.4.2. Creating the AWS EFS storage class using the CLI
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-efs-cross-account_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.5. AWS EFS CSI cross account support
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#efs-create-volume_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.6. Creating and configuring access to EFS volumes in AWS
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-dynamic-provisioning-aws-efs_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.7. Dynamic provisioning for Amazon Elastic File Storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#efs-create-static-pv_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.8. Creating static PVs with Amazon Elastic File Storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#efs-security_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.9. Amazon Elastic File Storage security
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#efs-troubleshooting_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.10. Amazon Elastic File Storage troubleshooting
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-olm-operator-uninstall_persistent-storage-csi-aws-efs" class="j-doc-nav__link ">
    5.11.11. Uninstalling the AWS EFS CSI Driver Operator
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources" class="j-doc-nav__link ">
    5.11.12. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-azure-disk" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.12. Azure Disk CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.12. Azure Disk CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.12. Azure Disk CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-4" class="j-doc-nav__link ">
    5.12.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-azure" class="j-doc-nav__link ">
    5.12.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-azure-disk-sc-zrs_persistent-storage-csi-azure" class="j-doc-nav__link ">
    5.12.3. Creating a storage class with storage account type
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#byok_persistent-storage-csi-azure" class="j-doc-nav__link ">
    5.12.4. User-managed encryption
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#machineset-azure-ultra-disk_persistent-storage-csi-azure" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.12.5. Machine sets that deploy machines with ultra disks using PVCs
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.12.5. Machine sets that deploy machines with ultra disks using PVCs"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.12.5. Machine sets that deploy machines with ultra disks using PVCs"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#machineset-creating-azure-ultra-disk_persistent-storage-csi-azure" class="j-doc-nav__link ">
    5.12.5.1. Creating machines with ultra disks by using machine sets
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#machineset-troubleshooting-azure-ultra-disk_persistent-storage-csi-azure" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.12.5.2. Troubleshooting resources for machine sets that enable ultra disks
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.12.5.2. Troubleshooting resources for machine sets that enable ultra disks"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.12.5.2. Troubleshooting resources for machine sets that enable ultra disks"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ts-pvc-mounting-ultra_persistent-storage-csi-azure" class="j-doc-nav__link ">
    5.12.5.2.1. Unable to mount a persistent volume claim backed by an ultra disk
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources_persistent-storage-csi-azure" class="j-doc-nav__link ">
    5.12.6. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-azure-file" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.13. Azure File CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.13. Azure File CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.13. Azure File CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-5" class="j-doc-nav__link ">
    5.13.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-azure-file" class="j-doc-nav__link ">
    5.13.2. About CSI
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-azure-stack-hub" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.14. Azure Stack Hub CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.14. Azure Stack Hub CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.14. Azure Stack Hub CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-6" class="j-doc-nav__link ">
    5.14.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-azure-stack-hub" class="j-doc-nav__link ">
    5.14.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources-2" class="j-doc-nav__link ">
    5.14.3. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-gcp-pd" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.15. GCP PD CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.15. GCP PD CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.15. GCP PD CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-7" class="j-doc-nav__link ">
    5.15.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-gcp-pd" class="j-doc-nav__link ">
    5.15.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-gcp-pd-storage-class-ref_persistent-storage-csi-gcp-pd" class="j-doc-nav__link ">
    5.15.3. GCP PD CSI driver storage class parameters
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-gcp-pd-encrypted-pv_persistent-storage-csi-gcp-pd" class="j-doc-nav__link ">
    5.15.4. Creating a custom-encrypted persistent volume
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#byok_persistent-storage-csi-gcp-pd" class="j-doc-nav__link ">
    5.15.5. User-managed encryption
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources-3" class="j-doc-nav__link ">
    5.15.6. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-google-cloud-file" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.16. Google Compute Platform Filestore CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.16. Google Compute Platform Filestore CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.16. Google Compute Platform Filestore CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-google-cloud-file-overview" class="j-doc-nav__link ">
    5.16.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-google-cloud-file" class="j-doc-nav__link ">
    5.16.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-olm-operator-install_persistent-storage-csi-google-cloud-file" class="j-doc-nav__link ">
    5.16.3. Installing the GCP Filestore CSI Driver Operator
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-google-cloud-file-create-sc_persistent-storage-csi-google-cloud-file" class="j-doc-nav__link ">
    5.16.4. Creating a storage class for GCP Filestore Storage
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-gcp-cloud-file-delete-instances_persistent-storage-csi-google-cloud-file" class="j-doc-nav__link ">
    5.16.5. Destroying clusters and GCP Filestore
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources-4" class="j-doc-nav__link ">
    5.16.6. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-ibm-vpc-block" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.17. IBM VPC Block CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.17. IBM VPC Block CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.17. IBM VPC Block CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-8" class="j-doc-nav__link ">
    5.17.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-ibm-vpc-block" class="j-doc-nav__link ">
    5.17.2. About CSI
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-ibm-powervs-block" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.18. IBM Power Virtual Server Block CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.18. IBM Power Virtual Server Block CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.18. IBM Power Virtual Server Block CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-ibm-powervs-block-introduction_persistent-storage-csi-ibm-powervs-block" class="j-doc-nav__link ">
    5.18.1. Introduction
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-ibm-powervs-block-overview_persistent-storage-csi-ibm-powervs-block" class="j-doc-nav__link ">
    5.18.2. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-ibm-powervs-block" class="j-doc-nav__link ">
    5.18.3. About CSI
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-cinder" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.19. OpenStack Cinder CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.19. OpenStack Cinder CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.19. OpenStack Cinder CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-9" class="j-doc-nav__link ">
    5.19.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-cinder" class="j-doc-nav__link ">
    5.19.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-cinder_persistent-storage-csi-cinder" class="j-doc-nav__link ">
    5.19.3. Making OpenStack Cinder CSI the default storage class
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-manila" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.20. OpenStack Manila CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.20. OpenStack Manila CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.20. OpenStack Manila CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-10" class="j-doc-nav__link ">
    5.20.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-manila" class="j-doc-nav__link ">
    5.20.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-manila-limitations_persistent-storage-csi-manila" class="j-doc-nav__link ">
    5.20.3. Manila CSI Driver Operator limitations
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-manila-dynamic-provisioning_persistent-storage-csi-manila" class="j-doc-nav__link ">
    5.20.4. Dynamically provisioning Manila CSI volumes
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-ovirt" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.21. Red Hat Virtualization CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.21. Red Hat Virtualization CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.21. Red Hat Virtualization CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-11" class="j-doc-nav__link ">
    5.21.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-ovirt" class="j-doc-nav__link ">
    5.21.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#ovirt-csi-driver-storage-class_persistent-storage-csi-ovirt" class="j-doc-nav__link ">
    5.21.3. Red Hat Virtualization (RHV) CSI driver storage class
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-rhv_persistent-storage-csi-ovirt" class="j-doc-nav__link ">
    5.21.4. Creating a persistent volume on RHV
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-vsphere" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.22. VMware vSphere CSI Driver Operator
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.22. VMware vSphere CSI Driver Operator"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.22. VMware vSphere CSI Driver Operator"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#overview-12" class="j-doc-nav__link ">
    5.22.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#csi-about_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.2. About CSI
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-stor-policy_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.3. vSphere storage policy
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-rwx_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.4. ReadWriteMany vSphere volume support
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-csi-driver-reqs_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.5. VMware vSphere CSI Driver Operator requirements
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-install-issues_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.6. Removing a third-party vSphere CSI Operator Driver
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-pv-encryption" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.22.7. vSphere persistent disks encryption
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.22.7. vSphere persistent disks encryption"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.22.7. vSphere persistent disks encryption"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-encryption-datastore-url_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.7.1. Using datastore URL
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-encryption-tag-based_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.7.2. Using tag-based placement
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-top-aware-overview_persistent-storage-csi-vsphere" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.22.8. vSphere CSI topology overview
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.22.8. vSphere CSI topology overview"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.22.8. vSphere CSI topology overview"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-top-aware-during-install_persistent-storage-csi-vsphere" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.22.8.1. Creating vSphere storage topology during installation
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.22.8.1. Creating vSphere storage topology during installation"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.22.8.1. Creating vSphere storage topology during installation"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#procedure-4" class="j-doc-nav__link ">
    5.22.8.1.1. Procedure
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-top-aware-post-install_persistent-storage-csi-vsphere" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.22.8.2. Creating vSphere storage topology post-installation
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.22.8.2. Creating vSphere storage topology post-installation"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.22.8.2. Creating vSphere storage topology post-installation"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#procedure-5" class="j-doc-nav__link ">
    5.22.8.2.1. Procedure
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-top-aware-infra-top_persistent-storage-csi-vsphere" class="j-doc-nav__link j-doc-nav__link--has-children">
    5.22.8.3. Creating vSphere storage topology without an infra topology
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "5.22.8.3. Creating vSphere storage topology without an infra topology"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "5.22.8.3. Creating vSphere storage topology without an infra topology"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#procedure-6" class="j-doc-nav__link ">
    5.22.8.3.1. Procedure
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#persistent-storage-csi-vsphere-top-aware-results_persistent-storage-csi-vsphere" class="j-doc-nav__link ">
    5.22.8.4. Results
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#additional-resources-5" class="j-doc-nav__link ">
    5.22.9. Additional resources
  </a>
  
          </li>
              </ol>

  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#generic-ephemeral-volumes" class="j-doc-nav__link j-doc-nav__link--has-children">
    6. Generic ephemeral volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "6. Generic ephemeral volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "6. Generic ephemeral volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#generic-ephemeral-vols-overview_generic-ephemeral-volumes" class="j-doc-nav__link ">
    6.1. Overview
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#generic-ephemeral-vols-lifecycle_generic-ephemeral-volumes" class="j-doc-nav__link ">
    6.2. Lifecycle and persistent volume claims
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#generic-ephemeral-security_generic-ephemeral-volumes" class="j-doc-nav__link ">
    6.3. Security
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#generic-ephemeral-vols-pvc-naming_generic-ephemeral-volumes" class="j-doc-nav__link ">
    6.4. Persistent volume claim naming
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#generic-ephemeral-vols-procedure_generic-ephemeral-volumes" class="j-doc-nav__link ">
    6.5. Creating generic ephemeral volumes
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#expanding-persistent-volumes" class="j-doc-nav__link j-doc-nav__link--has-children">
    7. Expanding persistent volumes
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "7. Expanding persistent volumes"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "7. Expanding persistent volumes"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#add-volume-expansion_expanding-persistent-volumes" class="j-doc-nav__link ">
    7.1. Enabling volume expansion support
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#expanding-csi-volumes_expanding-persistent-volumes" class="j-doc-nav__link ">
    7.2. Expanding CSI volumes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#expanding-flexvolume_expanding-persistent-volumes" class="j-doc-nav__link ">
    7.3. Expanding FlexVolume with a supported driver
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#expanding-local-volumes_expanding-persistent-volumes" class="j-doc-nav__link ">
    7.4. Expanding local volumes
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#expanding-pvc-filesystem_expanding-persistent-volumes" class="j-doc-nav__link ">
    7.5. Expanding persistent volume claims (PVCs) with a file system
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#expanding-recovering-from-failure_expanding-persistent-volumes" class="j-doc-nav__link ">
    7.6. Recovering from failure when expanding volumes
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                      

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#dynamic-provisioning" class="j-doc-nav__link j-doc-nav__link--has-children">
    8. Dynamic provisioning
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "8. Dynamic provisioning"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "8. Dynamic provisioning"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#about_dynamic-provisioning" class="j-doc-nav__link ">
    8.1. About dynamic provisioning
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#available-plug-ins_dynamic-provisioning" class="j-doc-nav__link ">
    8.2. Available dynamic provisioning plugins
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#defining-storage-classes_dynamic-provisioning" class="j-doc-nav__link j-doc-nav__link--has-children">
    8.3. Defining a storage class
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "8.3. Defining a storage class"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "8.3. Defining a storage class"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#basic-storage-class-definition_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.1. Basic StorageClass object definition
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#storage-class-annotations_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.2. Storage class annotations
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#openstack-cinder-storage-class_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.3. RHOSP Cinder object definition
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#openstack-manila-csi-definition_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.4. RHOSP Manila Container Storage Interface (CSI) object definition
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#aws-definition_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.5. AWS Elastic Block Store (EBS) object definition
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#azure-disk-definition_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.6. Azure Disk object definition
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                          

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#azure-file-definition_dynamic-provisioning" class="j-doc-nav__link j-doc-nav__link--has-children">
    8.3.7. Azure File object definition
  </a>
                    <button class="j-doc-nav__children-toggle content-expander__trigger">
        <span class="visually-hidden j-doc-nav__children-toggle__expand-text">
          Expand section "8.3.7. Azure File object definition"
        </span>
        <span class="visually-hidden  j-doc-nav__children-toggle__collapse-text">
          Collapse section "8.3.7. Azure File object definition"
        </span>
      </button>

      <ol class="j-doc-nav__subnav j-superdoc-subnav content-expander">
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#azure-file-considerations_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.7.1. Considerations when using Azure File
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#gce-persistentdisk-storage-class_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.8. GCE PersistentDisk (gcePD) object definition
  </a>
  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#vsphere-definition_dynamic-provisioning" class="j-doc-nav__link ">
    8.3.9. VMware vSphere object definition
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-superdoc-subnav__item">
                        

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#change-default-storage-class_dynamic-provisioning" class="j-doc-nav__link ">
    8.4. Changing the default storage class
  </a>
  
          </li>
              </ol>

  
          </li>
                  <li class="j-doc-nav__list-item">
                                    

    <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage#idm140001865540400" class="j-doc-nav__link ">
    Legal Notice
  </a>
  
          </li>
              </ol>
    
  </div>
</nav>


              </div>
            </div>
            <div class="j-options-container j-options-container--mobile">
              <button class="j-sidebar__menu-trigger j-sidebar__menu-trigger--options content-expander__trigger">
                <span class="j-sidebar__menu-trigger__open-headline">
                  Settings
                </span>
                <span class="j-sidebar__menu-trigger__close-text">Close</span>
              </button>
              

  <ul class="j-doc-options__list content-expander">
    <li class="j-doc-options__item">
          <label class="j-doc-option__label j-doc-option__label--language" for="j-doc-language">
        Language:
      </label>
      <select id="j-doc-language" class="j-doc-option__select">
                  <option value="/documentation/en-us/openshift_container_platform/4.13/html-single/storage" selected=''>
            English
          </option>
                  <option value="/documentation/ja-jp/openshift_container_platform/4.13/html-single/storage" >
            日本語
          </option>
                  <option value="/documentation/zh-cn/openshift_container_platform/4.13/html-single/storage" >
            简体中文
          </option>
                  <option value="/documentation/ko-kr/openshift_container_platform/4.13/html-single/storage" >
            한국어
          </option>
              </select>

            <noscript>
        <div class="j-doc-option__label j-doc-option__label--language" id="j-doc-option__label--language--nojs">
          Language:
        </div>
        <ul aria-labelledby="j-doc-option__label--language--nojs" class="j-doc-option__languages-list">
                      <li>
              <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage">English</a>
            </li>
                      <li>
              <a href="/documentation/ja-jp/openshift_container_platform/4.13/html-single/storage">日本語</a>
            </li>
                      <li>
              <a href="/documentation/zh-cn/openshift_container_platform/4.13/html-single/storage">简体中文</a>
            </li>
                      <li>
              <a href="/documentation/ko-kr/openshift_container_platform/4.13/html-single/storage">한국어</a>
            </li>
                  </ul>
      </noscript>

      </li>

    <li class="j-doc-options__item">
    <label for="j-doc-mode" class="j-doc-option__label j-doc-option__label--format">
      Format:
    </label>
    <select id="j-doc-mode" class="j-doc-option__select">
              <option value="/documentation/en-us/openshift_container_platform/4.13/html/storage"  class="j-doc-options__option j-doc-options__option--multi-page">
          Multi-page
        </option>
              <option value="/documentation/en-us/openshift_container_platform/4.13/html-single/storage" selected='' class="j-doc-options__option j-doc-options__option--single-page">
          Single-page
        </option>
              <option value="/documentation/en-us/openshift_container_platform/4.13/pdf/storage/OpenShift_Container_Platform-4.13-Storage-en-US.pdf"  class="j-doc-options__option j-doc-options__option--pdf">
          PDF
        </option>
          </select>

        <noscript>
      <div class="j-doc-option__label j-doc-option__label--format" id="j-doc-option__label--format--nojs">
        Format:
      </div>
      <ul class="j-doc-option__format-list" aria-labelledby="j-doc-option__label--format--nojs">
                  <li class="j-doc-mode-no-js__link j-doc-mode-no-js__link--multi-page"><a href="/documentation/en-us/openshift_container_platform/4.13/html/storage">Multi-page</a></li>
                  <li class="j-doc-mode-no-js__link j-doc-mode-no-js__link--single-page"><a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage">Single-page</a></li>
                  <li class="j-doc-mode-no-js__link j-doc-mode-no-js__link--pdf"><a href="/documentation/en-us/openshift_container_platform/4.13/pdf/storage/OpenShift_Container_Platform-4.13-Storage-en-US.pdf">PDF</a></li>
              </ul>
    </noscript>
  </li>
</ul>


              </div>
          </div>
                <div class="pvof-doc__tertiary-sidebar j-doc__tertiary-sidebar">
          <div class="pvof-doc__tertiary-sidebar__inner j-doc__tertiary-sidebar__inner">
            <div class="j-doc__doc-options">
              <div class="j-options-container j-options-container--desktop">
                <button class="j-sidebar__menu-trigger j-sidebar__menu-trigger--tablet content-expander__trigger">
                  <span class="j-sidebar__menu-trigger-icon"></span>
                  <h2 class="visually-hidden">Language and Page Formatting Options</h2>
                </button>
                  

  <ul class="j-doc-options__list content-expander">
    <li class="j-doc-options__item">
          <label class="j-doc-option__label j-doc-option__label--language" for="j-doc-language--2">
        Language:
      </label>
      <select id="j-doc-language--2" class="j-doc-option__select">
                  <option value="/documentation/en-us/openshift_container_platform/4.13/html-single/storage" selected=''>
            English
          </option>
                  <option value="/documentation/ja-jp/openshift_container_platform/4.13/html-single/storage" >
            日本語
          </option>
                  <option value="/documentation/zh-cn/openshift_container_platform/4.13/html-single/storage" >
            简体中文
          </option>
                  <option value="/documentation/ko-kr/openshift_container_platform/4.13/html-single/storage" >
            한국어
          </option>
              </select>

            <noscript>
        <div class="j-doc-option__label j-doc-option__label--language" id="j-doc-option__label--language--nojs">
          Language:
        </div>
        <ul aria-labelledby="j-doc-option__label--language--nojs" class="j-doc-option__languages-list">
                      <li>
              <a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage">English</a>
            </li>
                      <li>
              <a href="/documentation/ja-jp/openshift_container_platform/4.13/html-single/storage">日本語</a>
            </li>
                      <li>
              <a href="/documentation/zh-cn/openshift_container_platform/4.13/html-single/storage">简体中文</a>
            </li>
                      <li>
              <a href="/documentation/ko-kr/openshift_container_platform/4.13/html-single/storage">한국어</a>
            </li>
                  </ul>
      </noscript>

      </li>

    <li class="j-doc-options__item">
    <label for="j-doc-mode--2" class="j-doc-option__label j-doc-option__label--format">
      Format:
    </label>
    <select id="j-doc-mode--2" class="j-doc-option__select">
              <option value="/documentation/en-us/openshift_container_platform/4.13/html/storage"  class="j-doc-options__option j-doc-options__option--multi-page">
          Multi-page
        </option>
              <option value="/documentation/en-us/openshift_container_platform/4.13/html-single/storage" selected='' class="j-doc-options__option j-doc-options__option--single-page">
          Single-page
        </option>
              <option value="/documentation/en-us/openshift_container_platform/4.13/pdf/storage/OpenShift_Container_Platform-4.13-Storage-en-US.pdf"  class="j-doc-options__option j-doc-options__option--pdf">
          PDF
        </option>
          </select>

        <noscript>
      <div class="j-doc-option__label j-doc-option__label--format" id="j-doc-option__label--format--nojs">
        Format:
      </div>
      <ul class="j-doc-option__format-list" aria-labelledby="j-doc-option__label--format--nojs">
                  <li class="j-doc-mode-no-js__link j-doc-mode-no-js__link--multi-page"><a href="/documentation/en-us/openshift_container_platform/4.13/html/storage">Multi-page</a></li>
                  <li class="j-doc-mode-no-js__link j-doc-mode-no-js__link--single-page"><a href="/documentation/en-us/openshift_container_platform/4.13/html-single/storage">Single-page</a></li>
                  <li class="j-doc-mode-no-js__link j-doc-mode-no-js__link--pdf"><a href="/documentation/en-us/openshift_container_platform/4.13/pdf/storage/OpenShift_Container_Platform-4.13-Storage-en-US.pdf">PDF</a></li>
              </ul>
    </noscript>
  </li>
</ul>


                </div>
              </div>
          </div>
        </div>

                  <div class="doc-wrapper pvof-doc__wrapper j-superdoc__content-wrapper" id="doc-wrapper">
            

  <div class="pane-page-title">
    <h1 class="title" itemprop="name">Storage</h1>
  </div>


  <div xml:lang="en-US" class="book" id="idm140001874798672"><div class="titlepage"><div><div class="producttitle"><span class="productname">OpenShift Container Platform</span> <span class="productnumber">4.13</span></div><div><h2 class="subtitle">Configuring and managing storage in OpenShift Container Platform </h2></div><div><div xml:lang="en-US" class="authorgroup"><span class="orgname">Red Hat OpenShift Documentation Team</span></div></div><div><a href="#idm140001865540400">Legal Notice</a></div><div><div class="abstract"><p class="title"><strong>Abstract</strong></p><div class="para">
				This document provides instructions for configuring persistent volumes from various storage back ends and managing dynamic allocation from Pods.
			</div></div></div></div><hr/></div><section class="chapter" id="storage-overview"><div class="titlepage"><div><div><h1 class="title">Chapter 1. OpenShift Container Platform storage overview</h1></div></div></div><p>
			OpenShift Container Platform supports multiple types of storage, both for on-premise and cloud providers. You can manage container storage for persistent and non-persistent data in an OpenShift Container Platform cluster.
		</p><section class="section" id="openshift-storage-common-terms_storage-overview"><div class="titlepage"><div><div><h2 class="title">1.1. Glossary of common terms for OpenShift Container Platform storage</h2></div></div></div><p>
				This glossary defines common terms that are used in the storage content.
			</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Access modes</span></dt><dd><p class="simpara">
							Volume access modes describe volume capabilities. You can use access modes to match persistent volume claim (PVC) and persistent volume (PV). The following are the examples of access modes:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									ReadWriteOnce (RWO)
								</li><li class="listitem">
									ReadOnlyMany (ROX)
								</li><li class="listitem">
									ReadWriteMany (RWX)
								</li><li class="listitem">
									ReadWriteOncePod (RWOP)
								</li></ul></div></dd><dt><span class="term">Cinder</span></dt><dd>
							The Block Storage service for Red Hat OpenStack Platform (RHOSP) which manages the administration, security, and scheduling of all volumes.
						</dd><dt><span class="term">Config map</span></dt><dd>
							A config map provides a way to inject configuration data into pods. You can reference the data stored in a config map in a volume of type <code class="literal">ConfigMap</code>. Applications running in a pod can use this data.
						</dd><dt><span class="term">Container Storage Interface (CSI)</span></dt><dd>
							An API specification for the management of container storage across different container orchestration (CO) systems.
						</dd><dt><span class="term">Dynamic Provisioning</span></dt><dd>
							The framework allows you to create storage volumes on-demand, eliminating the need for cluster administrators to pre-provision persistent storage.
						</dd><dt><span class="term">Ephemeral storage</span></dt><dd>
							Pods and containers can require temporary or transient local storage for their operation. The lifetime of this ephemeral storage does not extend beyond the life of the individual pod, and this ephemeral storage cannot be shared across pods.
						</dd><dt><span class="term">Fiber channel</span></dt><dd>
							A networking technology that is used to transfer data among data centers, computer servers, switches and storage.
						</dd><dt><span class="term">FlexVolume</span></dt><dd>
							FlexVolume is an out-of-tree plugin interface that uses an exec-based model to interface with storage drivers. You must install the FlexVolume driver binaries in a pre-defined volume plugin path on each node and in some cases the control plane nodes.
						</dd><dt><span class="term">fsGroup</span></dt><dd>
							The fsGroup defines a file system group ID of a pod.
						</dd><dt><span class="term">iSCSI</span></dt><dd>
							Internet Small Computer Systems Interface (iSCSI) is an Internet Protocol-based storage networking standard for linking data storage facilities. An iSCSI volume allows an existing iSCSI (SCSI over IP) volume to be mounted into your Pod.
						</dd><dt><span class="term">hostPath</span></dt><dd>
							A hostPath volume in an OpenShift Container Platform cluster mounts a file or directory from the host node’s filesystem into your pod.
						</dd><dt><span class="term">KMS key</span></dt><dd>
							The Key Management Service (KMS) helps you achieve the required level of encryption of your data across different services. you can use the KMS key to encrypt, decrypt, and re-encrypt data.
						</dd><dt><span class="term">Local volumes</span></dt><dd>
							A local volume represents a mounted local storage device such as a disk, partition or directory.
						</dd><dt><span class="term">NFS</span></dt><dd>
							A Network File System (NFS) that allows remote hosts to mount file systems over a network and interact with those file systems as though they are mounted locally. This enables system administrators to consolidate resources onto centralized servers on the network.
						</dd><dt><span class="term">OpenShift Data Foundation</span></dt><dd>
							A provider of agnostic persistent storage for OpenShift Container Platform supporting file, block, and object storage, either in-house or in hybrid clouds
						</dd><dt><span class="term">Persistent storage</span></dt><dd>
							Pods and containers can require permanent storage for their operation. OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework to allow cluster administrators to provision persistent storage for a cluster. Developers can use PVC to request PV resources without having specific knowledge of the underlying storage infrastructure.
						</dd><dt><span class="term">Persistent volumes (PV)</span></dt><dd>
							OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework to allow cluster administrators to provision persistent storage for a cluster. Developers can use PVC to request PV resources without having specific knowledge of the underlying storage infrastructure.
						</dd><dt><span class="term">Persistent volume claims (PVCs)</span></dt><dd>
							You can use a PVC to mount a PersistentVolume into a Pod. You can access the storage without knowing the details of the cloud environment.
						</dd><dt><span class="term">Pod</span></dt><dd>
							One or more containers with shared resources, such as volume and IP addresses, running in your OpenShift Container Platform cluster. A pod is the smallest compute unit defined, deployed, and managed.
						</dd><dt><span class="term">Reclaim policy</span></dt><dd>
							A policy that tells the cluster what to do with the volume after it is released. A volume’s reclaim policy can be <code class="literal">Retain</code>, <code class="literal">Recycle</code>, or <code class="literal">Delete</code>.
						</dd><dt><span class="term">Role-based access control (RBAC)</span></dt><dd>
							Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.
						</dd><dt><span class="term">Stateless applications</span></dt><dd>
							A stateless application is an application program that does not save client data generated in one session for use in the next session with that client.
						</dd><dt><span class="term">Stateful applications</span></dt><dd>
							A stateful application is an application program that saves data to persistent disk storage. A server, client, and applications can use a persistent disk storage. You can use the <code class="literal">Statefulset</code> object in OpenShift Container Platform to manage the deployment and scaling of a set of Pods, and provides guarantee about the ordering and uniqueness of these Pods.
						</dd><dt><span class="term">Static provisioning</span></dt><dd>
							A cluster administrator creates a number of PVs. PVs contain the details of storage. PVs exist in the Kubernetes API and are available for consumption.
						</dd><dt><span class="term">Storage</span></dt><dd>
							OpenShift Container Platform supports many types of storage, both for on-premise and cloud providers. You can manage container storage for persistent and non-persistent data in an OpenShift Container Platform cluster.
						</dd><dt><span class="term">Storage class</span></dt><dd>
							A storage class provides a way for administrators to describe the classes of storage they offer. Different classes might map to quality of service levels, backup policies, arbitrary policies determined by the cluster administrators.
						</dd><dt><span class="term">VMware vSphere’s Virtual Machine Disk (VMDK) volumes</span></dt><dd>
							Virtual Machine Disk (VMDK) is a file format that describes containers for virtual hard disk drives that is used in virtual machines.
						</dd></dl></div></section><section class="section" id="storage-types"><div class="titlepage"><div><div><h2 class="title">1.2. Storage types</h2></div></div></div><p>
				OpenShift Container Platform storage is broadly classified into two categories, namely ephemeral storage and persistent storage.
			</p><section class="section" id="ephemeral-storage"><div class="titlepage"><div><div><h3 class="title">1.2.1. Ephemeral storage</h3></div></div></div><p>
					Pods and containers are ephemeral or transient in nature and designed for stateless applications. Ephemeral storage allows administrators and developers to better manage the local storage for some of their operations. For more information about ephemeral storage overview, types, and management, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-ephemeral-storage">Understanding ephemeral storage</a>.
				</p></section><section class="section" id="persistent-storage"><div class="titlepage"><div><div><h3 class="title">1.2.2. Persistent storage</h3></div></div></div><p>
					Stateful applications deployed in containers require persistent storage. OpenShift Container Platform uses a pre-provisioned storage framework called persistent volumes (PV) to allow cluster administrators to provision persistent storage. The data inside these volumes can exist beyond the lifecycle of an individual pod. Developers can use persistent volume claims (PVCs) to request storage requirements. For more information about persistent storage overview, configuration, and lifecycle, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">Understanding persistent storage</a>.
				</p></section></section><section class="section" id="container-storage-interface"><div class="titlepage"><div><div><h2 class="title">1.3. Container Storage Interface (CSI)</h2></div></div></div><p>
				CSI is an API specification for the management of container storage across different container orchestration (CO) systems. You can manage the storage volumes within the container native environments, without having specific knowledge of the underlying storage infrastructure. With the CSI, storage works uniformly across different container orchestration systems, regardless of the storage vendors you are using. For more information about CSI, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Using Container Storage Interface (CSI)</a>.
			</p></section><section class="section" id="dynamic-provisioning-overview"><div class="titlepage"><div><div><h2 class="title">1.4. Dynamic Provisioning</h2></div></div></div><p>
				Dynamic Provisioning allows you to create storage volumes on-demand, eliminating the need for cluster administrators to pre-provision storage. For more information about dynamic provisioning, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#dynamic-provisioning">Dynamic provisioning</a>.
			</p></section></section><section class="chapter" id="understanding-ephemeral-storage"><div class="titlepage"><div><div><h1 class="title">Chapter 2. Understanding ephemeral storage</h1></div></div></div><section class="section" id="storage-ephemeral-storage-overview_understanding-ephemeral-storage"><div class="titlepage"><div><div><h2 class="title">2.1. Overview</h2></div></div></div><p>
				In addition to persistent storage, pods and containers can require ephemeral or transient local storage for their operation. The lifetime of this ephemeral storage does not extend beyond the life of the individual pod, and this ephemeral storage cannot be shared across pods.
			</p><p>
				Pods use ephemeral local storage for scratch space, caching, and logs. Issues related to the lack of local storage accounting and isolation include the following:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Pods cannot detect how much local storage is available to them.
					</li><li class="listitem">
						Pods cannot request guaranteed local storage.
					</li><li class="listitem">
						Local storage is a best-effort resource.
					</li><li class="listitem">
						Pods can be evicted due to other pods filling the local storage, after which new pods are not admitted until sufficient storage is reclaimed.
					</li></ul></div><p>
				Unlike persistent volumes, ephemeral storage is unstructured and the space is shared between all pods running on a node, in addition to other uses by the system, the container runtime, and OpenShift Container Platform. The ephemeral storage framework allows pods to specify their transient local storage needs. It also allows OpenShift Container Platform to schedule pods where appropriate, and to protect the node against excessive use of local storage.
			</p><p>
				While the ephemeral storage framework allows administrators and developers to better manage local storage, I/O throughput and latency are not directly effected.
			</p></section><section class="section" id="storage-ephemeral-storage-types_understanding-ephemeral-storage"><div class="titlepage"><div><div><h2 class="title">2.2. Types of ephemeral storage</h2></div></div></div><p>
				Ephemeral local storage is always made available in the primary partition. There are two basic ways of creating the primary partition: root and runtime.
			</p><h4 id="root">Root</h4><p>
				This partition holds the kubelet root directory, <code class="literal">/var/lib/kubelet/</code> by default, and <code class="literal">/var/log/</code> directory. This partition can be shared between user pods, the OS, and Kubernetes system daemons. This partition can be consumed by pods through <code class="literal">EmptyDir</code> volumes, container logs, image layers, and container-writable layers. Kubelet manages shared access and isolation of this partition. This partition is ephemeral, and applications cannot expect any performance SLAs, such as disk IOPS, from this partition.
			</p><h4 id="runtime">Runtime</h4><p>
				This is an optional partition that runtimes can use for overlay file systems. OpenShift Container Platform attempts to identify and provide shared access along with isolation to this partition. Container image layers and writable layers are stored here. If the runtime partition exists, the <code class="literal">root</code> partition does not hold any image layer or other writable storage.
			</p></section><section class="section" id="storage-ephemeral-storage-manage_understanding-ephemeral-storage"><div class="titlepage"><div><div><h2 class="title">2.3. Ephemeral storage management</h2></div></div></div><p>
				Cluster administrators can manage ephemeral storage within a project by setting quotas that define the limit ranges and number of requests for ephemeral storage across all pods in a non-terminal state. Developers can also set requests and limits on this compute resource at the pod and container level.
			</p><p>
				You can manage local ephemeral storage by specifying requests and limits. Each container in a pod can specify the following:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<code class="literal">spec.containers[].resources.limits.ephemeral-storage</code>
					</li><li class="listitem">
						<code class="literal">spec.containers[].resources.requests.ephemeral-storage</code>
					</li></ul></div><p>
				Limits and requests for ephemeral storage are measured in byte quantities. You can express storage as a plain integer or as a fixed-point number using one of these suffixes: E, P, T, G, M, k. You can also use the power-of-two equivalents: Ei, Pi, Ti, Gi, Mi, Ki. For example, the following quantities all represent approximately the same value: 128974848, 129e6, 129M, and 123Mi. The case of the suffixes is significant. If you specify 400m of ephemeral storage, this requests 0.4 bytes, rather than 400 mebibytes (400Mi) or 400 megabytes (400M), which was probably what was intended.
			</p><p>
				The following example shows a pod with two containers. Each container requests 2GiB of local ephemeral storage. Each container has a limit of 4GiB of local ephemeral storage. Therefore, the pod has a request of 4GiB of local ephemeral storage, and a limit of 8GiB of local ephemeral storage.
			</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: frontend
spec:
  containers:
  - name: app
    image: images.my-company.example/app:v4
    resources:
      requests:
        ephemeral-storage: "2Gi" <span id="CO1-1"><!--Empty--></span><span class="callout">1</span>
      limits:
        ephemeral-storage: "4Gi" <span id="CO1-2"><!--Empty--></span><span class="callout">2</span>
    volumeMounts:
    - name: ephemeral
      mountPath: "/tmp"
  - name: log-aggregator
    image: images.my-company.example/log-aggregator:v6
    resources:
      requests:
        ephemeral-storage: "2Gi" <span id="CO1-3"><!--Empty--></span><span class="callout">3</span>
    volumeMounts:
    - name: ephemeral
      mountPath: "/tmp"
  volumes:
    - name: ephemeral
      emptyDir: {}</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO1-1"><span class="callout">1</span></a> <a href="#CO1-3"><span class="callout">3</span></a> </dt><dd><div class="para">
						Request for local ephemeral storage.
					</div></dd><dt><a href="#CO1-2"><span class="callout">2</span></a> </dt><dd><div class="para">
						Limit for local ephemeral storage.
					</div></dd></dl></div><p>
				This setting in the pod spec affects how the scheduler makes a decision on scheduling pods, and also how kubelet evict pods. First of all, the scheduler ensures that the sum of the resource requests of the scheduled containers is less than the capacity of the node. In this case, the pod can be assigned to a node only if its available ephemeral storage (allocatable resource) is more than 4GiB.
			</p><p>
				Secondly, at the container level, since the first container sets resource limit, kubelet eviction manager measures the disk usage of this container and evicts the pod if the storage usage of this container exceeds its limit (4GiB). At the pod level, kubelet works out an overall pod storage limit by adding up the limits of all the containers in that pod. In this case, the total storage usage at the pod level is the sum of the disk usage from all containers plus the pod’s <code class="literal">emptyDir</code> volumes. If this total usage exceeds the overall pod storage limit (4GiB), then the kubelet also marks the pod for eviction.
			</p><p>
				For information about defining quotas for projects, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/building_applications/#resource-quotas-per-project">Quota setting per project</a>.
			</p></section><section class="section" id="storage-ephemeral-storage-monitoring_understanding-ephemeral-storage"><div class="titlepage"><div><div><h2 class="title">2.4. Monitoring ephemeral storage</h2></div></div></div><p>
				You can use <code class="literal">/bin/df</code> as a tool to monitor ephemeral storage usage on the volume where ephemeral container data is located, which is <code class="literal">/var/lib/kubelet</code> and <code class="literal">/var/lib/containers</code>. The available space for only <code class="literal">/var/lib/kubelet</code> is shown when you use the <code class="literal">df</code> command if <code class="literal">/var/lib/containers</code> is placed on a separate disk by the cluster administrator.
			</p><p>
				To show the human-readable values of used and available space in <code class="literal">/var/lib</code>, enter the following command:
			</p><pre class="programlisting language-terminal">$ df -h /var/lib</pre><p>
				The output shows the ephemeral storage usage in <code class="literal">/var/lib</code>:
			</p><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
					
<pre class="programlisting language-terminal">Filesystem  Size  Used Avail Use% Mounted on
/dev/disk/by-partuuid/4cd1448a-01    69G   32G   34G  49% /</pre>

				</p></div></section></section><section class="chapter" id="understanding-persistent-storage"><div class="titlepage"><div><div><h1 class="title">Chapter 3. Understanding persistent storage</h1></div></div></div><section class="section" id="persistent-storage-overview_understanding-persistent-storage"><div class="titlepage"><div><div><h2 class="title">3.1. Persistent storage overview</h2></div></div></div><p>
				Managing storage is a distinct problem from managing compute resources. OpenShift Container Platform uses the Kubernetes persistent volume (PV) framework to allow cluster administrators to provision persistent storage for a cluster. Developers can use persistent volume claims (PVCs) to request PV resources without having specific knowledge of the underlying storage infrastructure.
			</p><p>
				PVCs are specific to a project, and are created and used by developers as a means to use a PV. PV resources on their own are not scoped to any single project; they can be shared across the entire OpenShift Container Platform cluster and claimed from any project. After a PV is bound to a PVC, that PV can not then be bound to additional PVCs. This has the effect of scoping a bound PV to a single namespace, that of the binding project.
			</p><p>
				PVs are defined by a <code class="literal">PersistentVolume</code> API object, which represents a piece of existing storage in the cluster that was either statically provisioned by the cluster administrator or dynamically provisioned using a <code class="literal">StorageClass</code> object. It is a resource in the cluster just like a node is a cluster resource.
			</p><p>
				PVs are volume plugins like <code class="literal">Volumes</code> but have a lifecycle that is independent of any individual pod that uses the PV. PV objects capture the details of the implementation of the storage, be that NFS, iSCSI, or a cloud-provider-specific storage system.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><p>
				PVCs are defined by a <code class="literal">PersistentVolumeClaim</code> API object, which represents a request for storage by a developer. It is similar to a pod in that pods consume node resources and PVCs consume PV resources. For example, pods can request specific levels of resources, such as CPU and memory, while PVCs can request specific storage capacity and access modes. For example, they can be mounted once read-write or many times read-only.
			</p></section><section class="section" id="lifecycle-volume-claim_understanding-persistent-storage"><div class="titlepage"><div><div><h2 class="title">3.2. Lifecycle of a volume and claim</h2></div></div></div><p>
				PVs are resources in the cluster. PVCs are requests for those resources and also act as claim checks to the resource. The interaction between PVs and PVCs have the following lifecycle.
			</p><section class="section" id="provisioning_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.1. Provision storage</h3></div></div></div><p>
					In response to requests from a developer defined in a PVC, a cluster administrator configures one or more dynamic provisioners that provision storage and a matching PV.
				</p><p>
					Alternatively, a cluster administrator can create a number of PVs in advance that carry the details of the real storage that is available for use. PVs exist in the API and are available for use.
				</p></section><section class="section" id="binding_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.2. Bind claims</h3></div></div></div><p>
					When you create a PVC, you request a specific amount of storage, specify the required access mode, and create a storage class to describe and classify the storage. The control loop in the master watches for new PVCs and binds the new PVC to an appropriate PV. If an appropriate PV does not exist, a provisioner for the storage class creates one.
				</p><p>
					The size of all PVs might exceed your PVC size. This is especially true with manually provisioned PVs. To minimize the excess, OpenShift Container Platform binds to the smallest PV that matches all other criteria.
				</p><p>
					Claims remain unbound indefinitely if a matching volume does not exist or can not be created with any available provisioner servicing a storage class. Claims are bound as matching volumes become available. For example, a cluster with many manually provisioned 50Gi volumes would not match a PVC requesting 100Gi. The PVC can be bound when a 100Gi PV is added to the cluster.
				</p></section><section class="section" id="using-pods_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.3. Use pods and claimed PVs</h3></div></div></div><p>
					Pods use claims as volumes. The cluster inspects the claim to find the bound volume and mounts that volume for a pod. For those volumes that support multiple access modes, you must specify which mode applies when you use the claim as a volume in a pod.
				</p><p>
					Once you have a claim and that claim is bound, the bound PV belongs to you for as long as you need it. You can schedule pods and access claimed PVs by including <code class="literal">persistentVolumeClaim</code> in the pod’s volumes block.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If you attach persistent volumes that have high file counts to pods, those pods can fail or can take a long time to start. For more information, see <a class="link" href="https://access.redhat.com/solutions/6221251">When using Persistent Volumes with high file counts in OpenShift, why do pods fail to start or take an excessive amount of time to achieve "Ready" state?</a>.
					</p></div></div></section><section class="section" id="pvcprotection_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.4. Storage Object in Use Protection</h3></div></div></div><p>
					The Storage Object in Use Protection feature ensures that PVCs in active use by a pod and PVs that are bound to PVCs are not removed from the system, as this can result in data loss.
				</p><p>
					Storage Object in Use Protection is enabled by default.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						A PVC is in active use by a pod when a <code class="literal">Pod</code> object exists that uses the PVC.
					</p></div></div><p>
					If a user deletes a PVC that is in active use by a pod, the PVC is not removed immediately. PVC removal is postponed until the PVC is no longer actively used by any pods. Also, if a cluster admin deletes a PV that is bound to a PVC, the PV is not removed immediately. PV removal is postponed until the PV is no longer bound to a PVC.
				</p></section><section class="section" id="releasing_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.5. Release a persistent volume</h3></div></div></div><p>
					When you are finished with a volume, you can delete the PVC object from the API, which allows reclamation of the resource. The volume is considered released when the claim is deleted, but it is not yet available for another claim. The previous claimant’s data remains on the volume and must be handled according to policy.
				</p></section><section class="section" id="reclaiming_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.6. Reclaim policy for persistent volumes</h3></div></div></div><p>
					The reclaim policy of a persistent volume tells the cluster what to do with the volume after it is released. A volume’s reclaim policy can be <code class="literal">Retain</code>, <code class="literal">Recycle</code>, or <code class="literal">Delete</code>.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">Retain</code> reclaim policy allows manual reclamation of the resource for those volume plugins that support it.
						</li><li class="listitem">
							<code class="literal">Recycle</code> reclaim policy recycles the volume back into the pool of unbound persistent volumes once it is released from its claim.
						</li></ul></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						The <code class="literal">Recycle</code> reclaim policy is deprecated in OpenShift Container Platform 4. Dynamic provisioning is recommended for equivalent and better functionality.
					</p></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<code class="literal">Delete</code> reclaim policy deletes both the <code class="literal">PersistentVolume</code> object from OpenShift Container Platform and the associated storage asset in external infrastructure, such as Amazon Elastic Block Store (Amazon EBS) or VMware vSphere.
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Dynamically provisioned volumes are always deleted.
					</p></div></div></section><section class="section" id="reclaim-manual_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.7. Reclaiming a persistent volume manually</h3></div></div></div><p>
					When a persistent volume claim (PVC) is deleted, the persistent volume (PV) still exists and is considered "released". However, the PV is not yet available for another claim because the data of the previous claimant remains on the volume.
				</p><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To manually reclaim the PV as a cluster administrator:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Delete the PV.
						</p><pre class="programlisting language-terminal">$ oc delete pv &lt;pv-name&gt;</pre><p class="simpara">
							The associated storage asset in the external infrastructure, such as an AWS EBS, GCE PD, Azure Disk, or Cinder volume, still exists after the PV is deleted.
						</p></li><li class="listitem">
							Clean up the data on the associated storage asset.
						</li><li class="listitem">
							Delete the associated storage asset. Alternately, to reuse the same storage asset, create a new PV with the storage asset definition.
						</li></ol></div><p>
					The reclaimed PV is now available for use by another PVC.
				</p></section><section class="section" id="reclaim-policy_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.2.8. Changing the reclaim policy of a persistent volume</h3></div></div></div><p>
					To change the reclaim policy of a persistent volume:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							List the persistent volumes in your cluster:
						</p><pre class="programlisting language-terminal">$ oc get pv</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
 pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     10s
 pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     6s
 pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim3    manual                     3s</pre>

							</p></div></li><li class="listitem"><p class="simpara">
							Choose one of your persistent volumes and change its reclaim policy:
						</p><pre class="programlisting language-terminal">$ oc patch pv &lt;your-pv-name&gt; -p '{"spec":{"persistentVolumeReclaimPolicy":"Retain"}}'</pre></li><li class="listitem"><p class="simpara">
							Verify that your chosen persistent volume has the right policy:
						</p><pre class="programlisting language-terminal">$ oc get pv</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME                                       CAPACITY   ACCESSMODES   RECLAIMPOLICY   STATUS    CLAIM             STORAGECLASS     REASON    AGE
 pvc-b6efd8da-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim1    manual                     10s
 pvc-b95650f8-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Delete          Bound     default/claim2    manual                     6s
 pvc-bb3ca71d-b7b5-11e6-9d58-0ed433a7dd94   4Gi        RWO           Retain          Bound     default/claim3    manual                     3s</pre>

							</p></div><p class="simpara">
							In the preceding output, the volume bound to claim <code class="literal">default/claim3</code> now has a <code class="literal">Retain</code> reclaim policy. The volume will not be automatically deleted when a user deletes claim <code class="literal">default/claim3</code>.
						</p></li></ol></div></section></section><section class="section" id="persistent-volumes_understanding-persistent-storage"><div class="titlepage"><div><div><h2 class="title">3.3. Persistent volumes</h2></div></div></div><p>
				Each PV contains a <code class="literal">spec</code> and <code class="literal">status</code>, which is the specification and status of the volume, for example:
			</p><div class="formalpara"><p class="title"><strong><code class="literal">PersistentVolume</code> object definition example</strong></p><p>
					
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 <span id="CO2-1"><!--Empty--></span><span class="callout">1</span>
spec:
  capacity:
    storage: 5Gi <span id="CO2-2"><!--Empty--></span><span class="callout">2</span>
  accessModes:
    - ReadWriteOnce <span id="CO2-3"><!--Empty--></span><span class="callout">3</span>
  persistentVolumeReclaimPolicy: Retain <span id="CO2-4"><!--Empty--></span><span class="callout">4</span>
  ...
status:
  ...</pre>

				</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO2-1"><span class="callout">1</span></a> </dt><dd><div class="para">
						Name of the persistent volume.
					</div></dd><dt><a href="#CO2-2"><span class="callout">2</span></a> </dt><dd><div class="para">
						The amount of storage available to the volume.
					</div></dd><dt><a href="#CO2-3"><span class="callout">3</span></a> </dt><dd><div class="para">
						The access mode, defining the read-write and mount permissions.
					</div></dd><dt><a href="#CO2-4"><span class="callout">4</span></a> </dt><dd><div class="para">
						The reclaim policy, indicating how the resource should be handled once it is released.
					</div></dd></dl></div><section class="section" id="types-of-persistent-volumes_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.3.1. Types of PVs</h3></div></div></div><p>
					OpenShift Container Platform supports the following persistent volume plugins:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							AliCloud Disk
						</li><li class="listitem">
							AWS Elastic Block Store (EBS)
						</li><li class="listitem">
							AWS Elastic File Store (EFS)
						</li><li class="listitem">
							Azure Disk
						</li><li class="listitem">
							Azure File
						</li><li class="listitem">
							Cinder
						</li><li class="listitem">
							Fibre Channel
						</li><li class="listitem">
							GCP Persistent Disk
						</li><li class="listitem">
							GCP Filestore
						</li><li class="listitem">
							IBM Power Virtual Server Block
						</li><li class="listitem">
							IBM VPC Block
						</li><li class="listitem">
							HostPath
						</li><li class="listitem">
							iSCSI
						</li><li class="listitem">
							Local volume
						</li><li class="listitem">
							NFS
						</li><li class="listitem">
							OpenStack Manila
						</li><li class="listitem">
							Red Hat OpenShift Data Foundation
						</li><li class="listitem">
							VMware vSphere
						</li></ul></div></section><section class="section" id="pv-capacity_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.3.2. Capacity</h3></div></div></div><p>
					Generally, a persistent volume (PV) has a specific storage capacity. This is set by using the <code class="literal">capacity</code> attribute of the PV.
				</p><p>
					Currently, storage capacity is the only resource that can be set or requested. Future attributes may include IOPS, throughput, and so on.
				</p></section><section class="section" id="pv-access-modes_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.3.3. Access modes</h3></div></div></div><p>
					A persistent volume can be mounted on a host in any way supported by the resource provider. Providers have different capabilities and each PV’s access modes are set to the specific modes supported by that particular volume. For example, NFS can support multiple read-write clients, but a specific NFS PV might be exported on the server as read-only. Each PV gets its own set of access modes describing that specific PV’s capabilities.
				</p><p>
					Claims are matched to volumes with similar access modes. The only two matching criteria are access modes and size. A claim’s access modes represent a request. Therefore, you might be granted more, but never less. For example, if a claim requests RWO, but the only volume available is an NFS PV (RWO+ROX+RWX), the claim would then match NFS because it supports RWO.
				</p><p>
					Direct matches are always attempted first. The volume’s modes must match or contain more modes than you requested. The size must be greater than or equal to what is expected. If two types of volumes, such as NFS and iSCSI, have the same set of access modes, either of them can match a claim with those modes. There is no ordering between types of volumes and no way to choose one type over another.
				</p><p>
					All volumes with the same modes are grouped, and then sorted by size, smallest to largest. The binder gets the group with matching modes and iterates over each, in size order, until one size matches.
				</p><p>
					The following table lists the access modes:
				</p><div class="table" id="idm140001865581280"><p class="title"><strong>Table 3.1. Access modes</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 20%; " class="col_1"><!--Empty--></col><col style="width: 20%; " class="col_2"><!--Empty--></col><col style="width: 60%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001869001424" scope="col">Access Mode</th><th align="left" valign="top" id="idm140001869000336" scope="col">CLI abbreviation</th><th align="left" valign="top" id="idm140001868999248" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001869001424"> <p>
									ReadWriteOnce
								</p>
								 </td><td align="left" valign="top" headers="idm140001869000336"> <p>
									<code class="literal">RWO</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001868999248"> <p>
									The volume can be mounted as read-write by a single node.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001869001424"> <p>
									ReadOnlyMany
								</p>
								 </td><td align="left" valign="top" headers="idm140001869000336"> <p>
									<code class="literal">ROX</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001868999248"> <p>
									The volume can be mounted as read-only by many nodes.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001869001424"> <p>
									ReadWriteMany
								</p>
								 </td><td align="left" valign="top" headers="idm140001869000336"> <p>
									<code class="literal">RWX</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001868999248"> <p>
									The volume can be mounted as read-write by many nodes.
								</p>
								 </td></tr></tbody></table></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Volume access modes are descriptors of volume capabilities. They are not enforced constraints. The storage provider is responsible for runtime errors resulting from invalid use of the resource.
					</p><p>
						For example, NFS offers <code class="literal">ReadWriteOnce</code> access mode. You must mark the claims as <code class="literal">read-only</code> if you want to use the volume’s ROX capability. Errors in the provider show up at runtime as mount errors.
					</p><p>
						iSCSI and Fibre Channel volumes do not currently have any fencing mechanisms. You must ensure the volumes are only used by one node at a time. In certain situations, such as draining a node, the volumes can be used simultaneously by two nodes. Before draining the node, first ensure the pods that use these volumes are deleted.
					</p></div></div><div class="table" id="idm140001867057184"><p class="title"><strong>Table 3.2. Supported access modes for PVs</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 25%; " class="col_1"><!--Empty--></col><col style="width: 25%; " class="col_2"><!--Empty--></col><col style="width: 25%; " class="col_3"><!--Empty--></col><col style="width: 25%; " class="col_4"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001868214896" scope="col">Volume plugin</th><th align="center" valign="top" id="idm140001868213808" scope="col">ReadWriteOnce <sup>[1]</sup></th><th align="center" valign="top" id="idm140001868212400" scope="col">ReadOnlyMany</th><th align="center" valign="top" id="idm140001868211312" scope="col">ReadWriteMany</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									AliCloud Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									AWS EBS <sup>[2]</sup>
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									AWS EFS
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									Azure File
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									Azure Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									Cinder
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									Fibre Channel
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									GCP Persistent Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									GCP Filestore
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									HostPath
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									IBM Power Virtual Server Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									IBM VPC Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									iSCSI
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									Local volume
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p>  -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									NFS
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									OpenStack Manila
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									Red Hat OpenShift Data Foundation
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868214896"> <p>
									VMware vSphere
								</p>
								 </td><td align="center" valign="top" headers="idm140001868213808">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001868212400">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001868211312">
<div class="literallayout"><p> ✅ <sup>[3]</sup></p></div>
								 </td></tr></tbody></table></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							ReadWriteOnce (RWO) volumes cannot be mounted on multiple nodes. If a node fails, the system does not allow the attached RWO volume to be mounted on a new node because it is already assigned to the failed node. If you encounter a multi-attach error message as a result, force delete the pod on a shutdown or crashed node to avoid data loss in critical workloads, such as when dynamic persistent volumes are attached.
						</li><li class="listitem">
							Use a recreate deployment strategy for pods that rely on Amazon EBS.
						</li><li class="listitem">
							If the underlying vSphere environment supports the vSAN file service, then the vSphere Container Storage Interface (CSI) Driver Operator installed by OpenShift Container Platform supports provisioning of ReadWriteMany (RWX) volumes. If you do not have vSAN file service configured, and you request RWX, the volume fails to get created and an error is logged. For more information, see "Using Container Storage Interface" → "VMware vSphere CSI Driver Operator".
						</li></ol></div></section><section class="section" id="pv-phase_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.3.4. Phase</h3></div></div></div><p>
					Volumes can be found in one of the following phases:
				</p><div class="table" id="idm140001867482944"><p class="title"><strong>Table 3.3. Volume phases</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"><!--Empty--></col><col style="width: 67%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001868518784" scope="col">Phase</th><th align="left" valign="top" id="idm140001868517696" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001868518784"> <p>
									Available
								</p>
								 </td><td align="left" valign="top" headers="idm140001868517696"> <p>
									A free resource not yet bound to a claim.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868518784"> <p>
									Bound
								</p>
								 </td><td align="left" valign="top" headers="idm140001868517696"> <p>
									The volume is bound to a claim.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868518784"> <p>
									Released
								</p>
								 </td><td align="left" valign="top" headers="idm140001868517696"> <p>
									The claim was deleted, but the resource is not yet reclaimed by the cluster.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001868518784"> <p>
									Failed
								</p>
								 </td><td align="left" valign="top" headers="idm140001868517696"> <p>
									The volume has failed its automatic reclamation.
								</p>
								 </td></tr></tbody></table></div></div><p>
					You can view the name of the PVC that is bound to the PV by running the following command:
				</p><pre class="programlisting language-terminal">$ oc get pv &lt;pv-claim&gt;</pre><section class="section" id="pv-mount-options_understanding-persistent-storage"><div class="titlepage"><div><div><h4 class="title">3.3.4.1. Mount options</h4></div></div></div><p>
						You can specify mount options while mounting a PV by using the attribute <code class="literal">mountOptions</code>.
					</p><p>
						For example:
					</p><div class="formalpara"><p class="title"><strong>Mount options example</strong></p><p>
							
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  mountOptions: <span id="CO3-1"><!--Empty--></span><span class="callout">1</span>
    - nfsvers=4.1
  nfs:
    path: /tmp
    server: 172.17.0.2
  persistentVolumeReclaimPolicy: Retain
  claimRef:
    name: claim1
    namespace: default</pre>

						</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO3-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Specified mount options are used while mounting the PV to the disk.
							</div></dd></dl></div><p>
						The following PV types support mount options:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								AWS Elastic Block Store (EBS)
							</li><li class="listitem">
								Azure Disk
							</li><li class="listitem">
								Azure File
							</li><li class="listitem">
								Cinder
							</li><li class="listitem">
								GCE Persistent Disk
							</li><li class="listitem">
								iSCSI
							</li><li class="listitem">
								Local volume
							</li><li class="listitem">
								NFS
							</li><li class="listitem">
								Red Hat OpenShift Data Foundation (Ceph RBD only)
							</li><li class="listitem">
								VMware vSphere
							</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Fibre Channel and HostPath PVs do not support mount options.
						</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-vsphere-rwx_persistent-storage-csi-vsphere">ReadWriteMany vSphere volume support</a>
							</li></ul></div></section></section></section><section class="section" id="persistent-volume-claims_understanding-persistent-storage"><div class="titlepage"><div><div><h2 class="title">3.4. Persistent volume claims</h2></div></div></div><p>
				Each <code class="literal">PersistentVolumeClaim</code> object contains a <code class="literal">spec</code> and <code class="literal">status</code>, which is the specification and status of the persistent volume claim (PVC), for example:
			</p><div class="formalpara"><p class="title"><strong><code class="literal">PersistentVolumeClaim</code> object definition example</strong></p><p>
					
<pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim <span id="CO4-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
    - ReadWriteOnce <span id="CO4-2"><!--Empty--></span><span class="callout">2</span>
  resources:
    requests:
      storage: 8Gi <span id="CO4-3"><!--Empty--></span><span class="callout">3</span>
  storageClassName: gold <span id="CO4-4"><!--Empty--></span><span class="callout">4</span>
status:
  ...</pre>

				</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO4-1"><span class="callout">1</span></a> </dt><dd><div class="para">
						Name of the PVC.
					</div></dd><dt><a href="#CO4-2"><span class="callout">2</span></a> </dt><dd><div class="para">
						The access mode, defining the read-write and mount permissions.
					</div></dd><dt><a href="#CO4-3"><span class="callout">3</span></a> </dt><dd><div class="para">
						The amount of storage available to the PVC.
					</div></dd><dt><a href="#CO4-4"><span class="callout">4</span></a> </dt><dd><div class="para">
						Name of the <code class="literal">StorageClass</code> required by the claim.
					</div></dd></dl></div><section class="section" id="pvc-storage-class_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.4.1. Storage classes</h3></div></div></div><p>
					Claims can optionally request a specific storage class by specifying the storage class’s name in the <code class="literal">storageClassName</code> attribute. Only PVs of the requested class, ones with the same <code class="literal">storageClassName</code> as the PVC, can be bound to the PVC. The cluster administrator can configure dynamic provisioners to service one or more storage classes. The cluster administrator can create a PV on demand that matches the specifications in the PVC.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						The Cluster Storage Operator might install a default storage class depending on the platform in use. This storage class is owned and controlled by the Operator. It cannot be deleted or modified beyond defining annotations and labels. If different behavior is desired, you must define a custom storage class.
					</p></div></div><p>
					The cluster administrator can also set a default storage class for all PVCs. When a default storage class is configured, the PVC must explicitly ask for <code class="literal">StorageClass</code> or <code class="literal">storageClassName</code> annotations set to <code class="literal">""</code> to be bound to a PV without a storage class.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If more than one storage class is marked as default, a PVC can only be created if the <code class="literal">storageClassName</code> is explicitly specified. Therefore, only one storage class should be set as the default.
					</p></div></div></section><section class="section" id="pvc-access-modes_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.4.2. Access modes</h3></div></div></div><p>
					Claims use the same conventions as volumes when requesting storage with specific access modes.
				</p></section><section class="section" id="pvc-resources_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.4.3. Resources</h3></div></div></div><p>
					Claims, such as pods, can request specific quantities of a resource. In this case, the request is for storage. The same resource model applies to volumes and claims.
				</p></section><section class="section" id="pvc-claims-as-volumes_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.4.4. Claims as volumes</h3></div></div></div><p>
					Pods access storage by using the claim as a volume. Claims must exist in the same namespace as the pod using the claim. The cluster finds the claim in the pod’s namespace and uses it to get the <code class="literal">PersistentVolume</code> backing the claim. The volume is mounted to the host and into the pod, for example:
				</p><div class="formalpara"><p class="title"><strong>Mount volume to the host and into the pod example</strong></p><p>
						
<pre class="programlisting language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: dockerfile/nginx
      volumeMounts:
      - mountPath: "/var/www/html" <span id="CO5-1"><!--Empty--></span><span class="callout">1</span>
        name: mypd <span id="CO5-2"><!--Empty--></span><span class="callout">2</span>
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: myclaim <span id="CO5-3"><!--Empty--></span><span class="callout">3</span></pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO5-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Path to mount the volume inside the pod.
						</div></dd><dt><a href="#CO5-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							Name of the volume to mount. Do not mount to the container root, <code class="literal">/</code>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <code class="literal">/dev/pts</code> files. It is safe to mount the host by using <code class="literal">/host</code>.
						</div></dd><dt><a href="#CO5-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							Name of the PVC, that exists in the same namespace, to use.
						</div></dd></dl></div></section></section><section class="section" id="block-volume-support_understanding-persistent-storage"><div class="titlepage"><div><div><h2 class="title">3.5. Block volume support</h2></div></div></div><p>
				OpenShift Container Platform can statically provision raw block volumes. These volumes do not have a file system, and can provide performance benefits for applications that either write to the disk directly or implement their own storage service.
			</p><p>
				Raw block volumes are provisioned by specifying <code class="literal">volumeMode: Block</code> in the PV and PVC specification.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Pods using raw block volumes must be configured to allow privileged containers.
				</p></div></div><p>
				The following table displays which volume plugins support block volumes.
			</p><div class="table" id="idm140001874637312"><p class="title"><strong>Table 3.4. Block volume support</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 25%; " class="col_1"><!--Empty--></col><col style="width: 25%; " class="col_2"><!--Empty--></col><col style="width: 25%; " class="col_3"><!--Empty--></col><col style="width: 25%; " class="col_4"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001871584864" scope="col">Volume Plugin</th><th align="left" valign="top" id="idm140001871583776" scope="col">Manually provisioned</th><th align="left" valign="top" id="idm140001871582688" scope="col">Dynamically provisioned</th><th align="left" valign="top" id="idm140001852912976" scope="col">Fully supported</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								AliCloud Disk
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Amazon Elastic Block Store (Amazon EBS)
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Amazon Elastic File Storage (Amazon EFS)
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Azure Disk
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Azure File
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Cinder
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Fibre Channel
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								GCP
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								HostPath
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								IBM VPC Disk
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								iSCSI
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Local volume
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								NFS
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> </td><td align="left" valign="top" headers="idm140001871582688"> </td><td align="left" valign="top" headers="idm140001852912976"> </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								Red Hat OpenShift Data Foundation
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001871584864"> <p>
								VMware vSphere
							</p>
							 </td><td align="left" valign="top" headers="idm140001871583776"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001871582688"> <p>
								✅
							</p>
							 </td><td align="left" valign="top" headers="idm140001852912976"> <p>
								✅
							</p>
							 </td></tr></tbody></table></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Using any of the block volumes that can be provisioned manually, but are not provided as fully supported, is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
				</p><p>
					For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
				</p></div></div><section class="section" id="block-volume-examples_understanding-persistent-storage"><div class="titlepage"><div><div><h3 class="title">3.5.1. Block volume examples</h3></div></div></div><div class="formalpara"><p class="title"><strong>PV example</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: block-pv
spec:
  capacity:
    storage: 10Gi
  accessModes:
    - ReadWriteOnce
  volumeMode: Block <span id="CO6-1"><!--Empty--></span><span class="callout">1</span>
  persistentVolumeReclaimPolicy: Retain
  fc:
    targetWWNs: ["50060e801049cfd1"]
    lun: 0
    readOnly: false</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO6-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							<code class="literal">volumeMode</code> must be set to <code class="literal">Block</code> to indicate that this PV is a raw block volume.
						</div></dd></dl></div><div class="formalpara"><p class="title"><strong>PVC example</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: block-pvc
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Block <span id="CO7-1"><!--Empty--></span><span class="callout">1</span>
  resources:
    requests:
      storage: 10Gi</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO7-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							<code class="literal">volumeMode</code> must be set to <code class="literal">Block</code> to indicate that a raw block PVC is requested.
						</div></dd></dl></div><div class="formalpara"><p class="title"><strong><code class="literal">Pod</code> specification example</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-with-block-volume
spec:
  containers:
    - name: fc-container
      image: fedora:26
      command: ["/bin/sh", "-c"]
      args: [ "tail -f /dev/null" ]
      volumeDevices:  <span id="CO8-1"><!--Empty--></span><span class="callout">1</span>
        - name: data
          devicePath: /dev/xvda <span id="CO8-2"><!--Empty--></span><span class="callout">2</span>
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: block-pvc <span id="CO8-3"><!--Empty--></span><span class="callout">3</span></pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO8-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							<code class="literal">volumeDevices</code>, instead of <code class="literal">volumeMounts</code>, is used for block devices. Only <code class="literal">PersistentVolumeClaim</code> sources can be used with raw block volumes.
						</div></dd><dt><a href="#CO8-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							<code class="literal">devicePath</code>, instead of <code class="literal">mountPath</code>, represents the path to the physical device where the raw block is mapped to the system.
						</div></dd><dt><a href="#CO8-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							The volume source must be of type <code class="literal">persistentVolumeClaim</code> and must match the name of the PVC as expected.
						</div></dd></dl></div><div class="table" id="idm140001864377680"><p class="title"><strong>Table 3.5. Accepted values for <code class="literal">volumeMode</code></strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"><!--Empty--></col><col style="width: 67%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001864372528" scope="col">Value</th><th align="left" valign="top" id="idm140001869409472" scope="col">Default</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001864372528"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001869409472"> <p>
									Yes
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001864372528"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001869409472"> <p>
									No
								</p>
								 </td></tr></tbody></table></div></div><div class="table" id="idm140001862115776"><p class="title"><strong>Table 3.6. Binding scenarios for block volumes</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 17%; " class="col_1"><!--Empty--></col><col style="width: 33%; " class="col_2"><!--Empty--></col><col style="width: 50%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001866663600" scope="col">PV <code class="literal">volumeMode</code></th><th align="left" valign="top" id="idm140001866662192" scope="col">PVC <code class="literal">volumeMode</code></th><th align="left" valign="top" id="idm140001866660784" scope="col">Binding result</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Unspecified
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Unspecified
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Unspecified
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Unspecified
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Unspecified
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									No Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Unspecified
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									No Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									No Bind
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001866663600"> <p>
									Block
								</p>
								 </td><td align="left" valign="top" headers="idm140001866662192"> <p>
									Filesystem
								</p>
								 </td><td align="left" valign="top" headers="idm140001866660784"> <p>
									No Bind
								</p>
								 </td></tr></tbody></table></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Unspecified values result in the default value of <code class="literal">Filesystem</code>.
					</p></div></div></section></section><section class="section" id="using_fsGroup_understanding-persistent-storage"><div class="titlepage"><div><div><h2 class="title">3.6. Using fsGroup to reduce pod timeouts</h2></div></div></div><p>
				If a storage volume contains many files (~1,000,000 or greater), you may experience pod timeouts.
			</p><p>
				This can occur because, by default, OpenShift Container Platform recursively changes ownership and permissions for the contents of each volume to match the <code class="literal">fsGroup</code> specified in a pod’s <code class="literal">securityContext</code> when that volume is mounted. For large volumes, checking and changing ownership and permissions can be time consuming, slowing pod startup. You can use the <code class="literal">fsGroupChangePolicy</code> field inside a <code class="literal">securityContext</code> to control the way that OpenShift Container Platform checks and manages ownership and permissions for a volume.
			</p><p>
				<code class="literal">fsGroupChangePolicy</code> defines behavior for changing ownership and permission of the volume before being exposed inside a pod. This field only applies to volume types that support <code class="literal">fsGroup</code>-controlled ownership and permissions. This field has two possible values:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						<code class="literal">OnRootMismatch</code>: Only change permissions and ownership if permission and ownership of root directory does not match with expected permissions of the volume. This can help shorten the time it takes to change ownership and permission of a volume to reduce pod timeouts.
					</li><li class="listitem">
						<code class="literal">Always</code>: Always change permission and ownership of the volume when a volume is mounted.
					</li></ul></div><div class="formalpara"><p class="title"><strong><code class="literal">fsGroupChangePolicy</code> example</strong></p><p>
					
<pre class="programlisting language-yaml">securityContext:
  runAsUser: 1000
  runAsGroup: 3000
  fsGroup: 2000
  fsGroupChangePolicy: "OnRootMismatch" <span id="CO9-1"><!--Empty--></span><span class="callout">1</span>
  ...</pre>

				</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO9-1"><span class="callout">1</span></a> </dt><dd><div class="para">
						<code class="literal">OnRootMismatch</code> specifies skipping recursive permission change, thus helping to avoid pod timeout problems.
					</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					The fsGroupChangePolicyfield has no effect on ephemeral volume types, such as secret, configMap, and emptydir.
				</p></div></div></section></section><section class="chapter" id="configuring-persistent-storage"><div class="titlepage"><div><div><h1 class="title">Chapter 4. Configuring persistent storage</h1></div></div></div><section class="section" id="persistent-storage-aws"><div class="titlepage"><div><div><h2 class="title">4.1. Persistent storage using AWS Elastic Block Store</h2></div></div></div><p>
				OpenShift Container Platform supports Amazon Elastic Block Store (EBS) volumes. You can provision your OpenShift Container Platform cluster with persistent storage by using <a class="link" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/concepts.html">Amazon EC2</a>.
			</p><p>
				The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure. You can dynamically provision Amazon EBS volumes. Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace and can be requested by users. You can define a KMS key to encrypt container-persistent volumes on AWS. By default, newly created clusters using OpenShift Container Platform version 4.10 and later use gp3 storage and the <a class="link" href="https://github.com/openshift/aws-ebs-csi-driver">AWS EBS CSI driver</a>.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High-availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><p>
				For OpenShift Container Platform, automatic migration from AWS EBS in-tree to the Container Storage Interface (CSI) driver is available as a Technology Preview (TP) feature. With migration enabled, volumes provisioned using the existing in-tree driver are automatically migrated to use the AWS EBS CSI driver. For more information, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration feature</a>.
			</p><section class="section" id="storage-create-storage-class_persistent-storage-aws"><div class="titlepage"><div><div><h3 class="title">4.1.1. Creating the EBS storage class</h3></div></div></div><p>
					Storage classes are used to differentiate and delineate storage levels and usages. By defining a storage class, users can obtain dynamically provisioned persistent volumes.
				</p></section><section class="section" id="creating-the-persistent-volume-claim"><div class="titlepage"><div><div><h3 class="title">4.1.2. Creating the persistent volume claim</h3></div></div></div><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
					</p></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Persistent Volume Claims</strong></span>.
						</li><li class="listitem">
							In the persistent volume claims overview, click <span class="strong strong"><strong>Create Persistent Volume Claim</strong></span>.
						</li><li class="listitem"><p class="simpara">
							Define the desired options on the page that appears.
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Select the previously-created storage class from the drop-down menu.
								</li><li class="listitem">
									Enter a unique name for the storage claim.
								</li><li class="listitem">
									Select the access mode. This selection determines the read and write access for the storage claim.
								</li><li class="listitem">
									Define the size of the storage claim.
								</li></ol></div></li><li class="listitem">
							Click <span class="strong strong"><strong>Create</strong></span> to create the persistent volume claim and generate a persistent volume.
						</li></ol></div></section><section class="section" id="volume-format-AWS_persistent-storage-aws"><div class="titlepage"><div><div><h3 class="title">4.1.3. Volume format</h3></div></div></div><p>
					Before OpenShift Container Platform mounts the volume and passes it to a container, it checks that the volume contains a file system as specified by the <code class="literal">fsType</code> parameter in the persistent volume definition. If the device is not formatted with the file system, all data from the device is erased and the device is automatically formatted with the given file system.
				</p><p>
					This verification enables you to use unformatted AWS volumes as persistent volumes, because OpenShift Container Platform formats them before the first use.
				</p></section><section class="section" id="maximum-number-of-ebs-volumes-on-a-node_persistent-storage-aws"><div class="titlepage"><div><div><h3 class="title">4.1.4. Maximum number of EBS volumes on a node</h3></div></div></div><p>
					By default, OpenShift Container Platform supports a maximum of 39 EBS volumes attached to one node. This limit is consistent with the <a class="link" href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/volume_limits.html#linux-specific-volume-limits">AWS volume limits</a>. The volume limit depends on the instance type.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						As a cluster administrator, you must use either in-tree or Container Storage Interface (CSI) volumes and their respective storage classes, but never both volume types at the same time. The maximum attached EBS volume number is counted separately for in-tree and CSI volumes, which means you could have up to 39 EBS volumes of each type.
					</p></div></div><p>
					For information about accessing additional storage options, such as volume snapshots, that are not possible with in-tree volume plug-ins, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-ebs">AWS Elastic Block Store CSI Driver Operator</a>.
				</p></section><section class="section" id="aws-container-persistent-volumes-encrypt_persistent-storage-aws"><div class="titlepage"><div><div><h3 class="title">4.1.5. Encrypting container persistent volumes on AWS with a KMS key</h3></div></div></div><p>
					Defining a KMS key to encrypt container-persistent volumes on AWS is useful when you have explicit compliance and security guidelines when deploying to AWS.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Underlying infrastructure must contain storage.
						</li><li class="listitem">
							You must create a customer KMS key on AWS.
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a storage class:
						</p><pre class="programlisting language-yaml">$ cat &lt;&lt; EOF | oc create -f -
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <span id="CO10-1"><!--Empty--></span><span class="callout">1</span>
parameters:
  fsType: ext4 <span id="CO10-2"><!--Empty--></span><span class="callout">2</span>
  encrypted: "true"
  kmsKeyId: keyvalue <span id="CO10-3"><!--Empty--></span><span class="callout">3</span>
provisioner: ebs.csi.aws.com
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
EOF</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO10-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Specifies the name of the storage class.
								</div></dd><dt><a href="#CO10-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									File system that is created on provisioned volumes.
								</div></dd><dt><a href="#CO10-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									Specifies the full Amazon Resource Name (ARN) of the key to use when encrypting the container-persistent volume. If you do not provide any key, but the <code class="literal">encrypted</code> field is set to <code class="literal">true</code>, then the default KMS key is used. See <a class="link" href="https://docs.aws.amazon.com/kms/latest/developerguide/find-cmk-id-arn.html">Finding the key ID and key ARN on AWS</a> in the AWS documentation.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create a persistent volume claim (PVC) with the storage class specifying the KMS key:
						</p><pre class="programlisting language-yaml">$ cat &lt;&lt; EOF | oc create -f -
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mypvc
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  storageClassName: &lt;storage-class-name&gt;
  resources:
    requests:
      storage: 1Gi
EOF</pre></li><li class="listitem"><p class="simpara">
							Create workload containers to consume the PVC:
						</p><pre class="programlisting language-yaml">$ cat &lt;&lt; EOF | oc create -f -
kind: Pod
metadata:
  name: mypod
spec:
  containers:
    - name: httpd
      image: quay.io/centos7/httpd-24-centos7
      ports:
        - containerPort: 80
      volumeMounts:
        - mountPath: /mnt/storage
          name: data
  volumes:
    - name: data
      persistentVolumeClaim:
        claimName: mypvc
EOF</pre></li></ol></div></section><section class="section _additional-resources" id="additional-resources_persistent-storage-aws"><div class="titlepage"><div><div><h3 class="title">4.1.6. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							See <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-ebs">AWS Elastic Block Store CSI Driver Operator</a> for information about accessing additional storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
						</li></ul></div></section></section><section class="section" id="persistent-storage-using-azure"><div class="titlepage"><div><div><h2 class="title">4.2. Persistent storage using Azure</h2></div></div></div><p>
				OpenShift Container Platform supports Microsoft Azure Disk volumes. You can provision your OpenShift Container Platform cluster with persistent storage using Azure. Some familiarity with Kubernetes and Azure is assumed. The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure. Azure Disk volumes can be provisioned dynamically. Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace and can be requested by users.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision Azure Disk storage.
				</p><p>
					In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration</a>.
				</p><p>
					After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.
				</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://azure.microsoft.com/en-us/services/storage/disks">Microsoft Azure Disk</a>
					</li></ul></div><section class="section" id="storage-create-azure-storage-class_persistent-storage-azure"><div class="titlepage"><div><div><h3 class="title">4.2.1. Creating the Azure storage class</h3></div></div></div><p>
					Storage classes are used to differentiate and delineate storage levels and usages. By defining a storage class, users can obtain dynamically provisioned persistent volumes.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Storage Classes</strong></span>.
						</li><li class="listitem">
							In the storage class overview, click <span class="strong strong"><strong>Create Storage Class</strong></span>.
						</li><li class="listitem"><p class="simpara">
							Define the desired options on the page that appears.
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Enter a name to reference the storage class.
								</li><li class="listitem">
									Enter an optional description.
								</li><li class="listitem">
									Select the reclaim policy.
								</li><li class="listitem"><p class="simpara">
									Select <code class="literal">kubernetes.io/azure-disk</code> from the drop down list.
								</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
											Enter the storage account type. This corresponds to your Azure storage account SKU tier. Valid options are <code class="literal">Premium_LRS</code>, <code class="literal">Standard_LRS</code>, <code class="literal">StandardSSD_LRS</code>, and <code class="literal">UltraSSD_LRS</code>.
										</li><li class="listitem"><p class="simpara">
											Enter the kind of account. Valid options are <code class="literal">shared</code>, <code class="literal">dedicated,</code> and <code class="literal">managed</code>.
										</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
												Red Hat only supports the use of <code class="literal">kind: Managed</code> in the storage class.
											</p><p>
												With <code class="literal">Shared</code> and <code class="literal">Dedicated</code>, Azure creates unmanaged disks, while OpenShift Container Platform creates a managed disk for machine OS (root) disks. But because Azure Disk does not allow the use of both managed and unmanaged disks on a node, unmanaged disks created with <code class="literal">Shared</code> or <code class="literal">Dedicated</code> cannot be attached to OpenShift Container Platform nodes.
											</p></div></div></li></ol></div></li><li class="listitem">
									Enter additional parameters for the storage class as desired.
								</li></ol></div></li><li class="listitem">
							Click <span class="strong strong"><strong>Create</strong></span> to create the storage class.
						</li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://kubernetes.io/docs/concepts/storage/storage-classes/#new-azure-disk-storage-class-starting-from-v1-7-2">Azure Disk Storage Class</a>
						</li></ul></div></section><section class="section" id="creating-the-persistent-volume-claim-2"><div class="titlepage"><div><div><h3 class="title">4.2.2. Creating the persistent volume claim</h3></div></div></div><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
					</p></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Persistent Volume Claims</strong></span>.
						</li><li class="listitem">
							In the persistent volume claims overview, click <span class="strong strong"><strong>Create Persistent Volume Claim</strong></span>.
						</li><li class="listitem"><p class="simpara">
							Define the desired options on the page that appears.
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Select the previously-created storage class from the drop-down menu.
								</li><li class="listitem">
									Enter a unique name for the storage claim.
								</li><li class="listitem">
									Select the access mode. This selection determines the read and write access for the storage claim.
								</li><li class="listitem">
									Define the size of the storage claim.
								</li></ol></div></li><li class="listitem">
							Click <span class="strong strong"><strong>Create</strong></span> to create the persistent volume claim and generate a persistent volume.
						</li></ol></div></section><section class="section" id="volume-format-azure_persistent-storage-azure"><div class="titlepage"><div><div><h3 class="title">4.2.3. Volume format</h3></div></div></div><p>
					Before OpenShift Container Platform mounts the volume and passes it to a container, it checks that it contains a file system as specified by the <code class="literal">fsType</code> parameter in the persistent volume definition. If the device is not formatted with the file system, all data from the device is erased and the device is automatically formatted with the given file system.
				</p><p>
					This allows using unformatted Azure volumes as persistent volumes, because OpenShift Container Platform formats them before the first use.
				</p></section><section class="section" id="machineset-azure-ultra-disk_persistent-storage-azure"><div class="titlepage"><div><div><h3 class="title">4.2.4. Machine sets that deploy machines with ultra disks using PVCs</h3></div></div></div><p>
					You can create a machine set running on Azure that deploys machines with ultra disks. Ultra disks are high-performance storage that are intended for use with the most demanding data workloads.
				</p><p>
					Both the in-tree plugin and CSI driver support using PVCs to enable ultra disks. You can also deploy machines with ultra disks as data disks without creating a PVC.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disks">Microsoft Azure ultra disks documentation</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#machineset-azure-ultra-disk_persistent-storage-csi-azure">Machine sets that deploy machines on ultra disks using CSI PVCs</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/machine_management/#machineset-azure-ultra-disk_creating-machineset-azure">Machine sets that deploy machines on ultra disks as data disks</a>
						</li></ul></div><section class="section" id="machineset-creating-azure-ultra-disk_persistent-storage-azure"><div class="titlepage"><div><div><h4 class="title">4.2.4.1. Creating machines with ultra disks by using machine sets</h4></div></div></div><p>
						You can deploy machines with ultra disks on Azure by editing your machine set YAML file.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Have an existing Microsoft Azure cluster.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Copy an existing Azure <code class="literal">MachineSet</code> custom resource (CR) and edit it by running the following command:
							</p><pre class="programlisting language-terminal">$ oc edit machineset &lt;machine-set-name&gt;</pre><p class="simpara">
								where <code class="literal">&lt;machine-set-name&gt;</code> is the machine set that you want to provision machines with ultra disks.
							</p></li><li class="listitem"><p class="simpara">
								Add the following lines in the positions indicated:
							</p><pre class="programlisting language-yaml">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
spec:
  template:
    spec:
      metadata:
        labels:
          disk: ultrassd <span id="CO11-1"><!--Empty--></span><span class="callout">1</span>
      providerSpec:
        value:
          ultraSSDCapability: Enabled <span id="CO11-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO11-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify a label to use to select a node that is created by this machine set. This procedure uses <code class="literal">disk.ultrassd</code> for this value.
									</div></dd><dt><a href="#CO11-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										These lines enable the use of ultra disks.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create a machine set using the updated configuration by running the following command:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;machine-set-name&gt;.yaml</pre></li><li class="listitem"><p class="simpara">
								Create a storage class that contains the following YAML definition:
							</p><pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ultra-disk-sc <span id="CO12-1"><!--Empty--></span><span class="callout">1</span>
parameters:
  cachingMode: None
  diskIopsReadWrite: "2000" <span id="CO12-2"><!--Empty--></span><span class="callout">2</span>
  diskMbpsReadWrite: "320" <span id="CO12-3"><!--Empty--></span><span class="callout">3</span>
  kind: managed
  skuname: UltraSSD_LRS
provisioner: disk.csi.azure.com <span id="CO12-4"><!--Empty--></span><span class="callout">4</span>
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer <span id="CO12-5"><!--Empty--></span><span class="callout">5</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO12-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the name of the storage class. This procedure uses <code class="literal">ultra-disk-sc</code> for this value.
									</div></dd><dt><a href="#CO12-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										Specify the number of IOPS for the storage class.
									</div></dd><dt><a href="#CO12-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										Specify the throughput in MBps for the storage class.
									</div></dd><dt><a href="#CO12-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										For Azure Kubernetes Service (AKS) version 1.21 or later, use <code class="literal">disk.csi.azure.com</code>. For earlier versions of AKS, use <code class="literal">kubernetes.io/azure-disk</code>.
									</div></dd><dt><a href="#CO12-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										Optional: Specify this parameter to wait for the creation of the pod that will use the disk.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create a persistent volume claim (PVC) to reference the <code class="literal">ultra-disk-sc</code> storage class that contains the following YAML definition:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ultra-disk <span id="CO13-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: ultra-disk-sc <span id="CO13-2"><!--Empty--></span><span class="callout">2</span>
  resources:
    requests:
      storage: 4Gi <span id="CO13-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO13-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the name of the PVC. This procedure uses <code class="literal">ultra-disk</code> for this value.
									</div></dd><dt><a href="#CO13-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										This PVC references the <code class="literal">ultra-disk-sc</code> storage class.
									</div></dd><dt><a href="#CO13-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										Specify the size for the storage class. The minimum value is <code class="literal">4Gi</code>.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create a pod that contains the following YAML definition:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx-ultra
spec:
  nodeSelector:
    disk: ultrassd <span id="CO14-1"><!--Empty--></span><span class="callout">1</span>
  containers:
  - name: nginx-ultra
    image: alpine:latest
    command:
      - "sleep"
      - "infinity"
    volumeMounts:
    - mountPath: "/mnt/azure"
      name: volume
  volumes:
    - name: volume
      persistentVolumeClaim:
        claimName: ultra-disk <span id="CO14-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO14-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the label of the machine set that enables the use of ultra disks. This procedure uses <code class="literal">disk.ultrassd</code> for this value.
									</div></dd><dt><a href="#CO14-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										This pod references the <code class="literal">ultra-disk</code> PVC.
									</div></dd></dl></div></li></ol></div><div class="orderedlist"><p class="title"><strong>Verification</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Validate that the machines are created by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get machines</pre><p class="simpara">
								The machines should be in the <code class="literal">Running</code> state.
							</p></li><li class="listitem"><p class="simpara">
								For a machine that is running and has a node attached, validate the partition by running the following command:
							</p><pre class="programlisting language-terminal">$ oc debug node/&lt;node-name&gt; -- chroot /host lsblk</pre><p class="simpara">
								In this command, <code class="literal">oc debug node/&lt;node-name&gt;</code> starts a debugging shell on the node <code class="literal">&lt;node-name&gt;</code> and passes a command with <code class="literal">--</code>. The passed command <code class="literal">chroot /host</code> provides access to the underlying host OS binaries, and <code class="literal">lsblk</code> shows the block devices that are attached to the host OS machine.
							</p></li></ol></div><div class="itemizedlist"><p class="title"><strong>Next steps</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								To use an ultra disk from within a pod, create a workload that uses the mount point. Create a YAML file similar to the following example:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: ssd-benchmark1
spec:
  containers:
  - name: ssd-benchmark1
    image: nginx
    ports:
      - containerPort: 80
        name: "http-server"
    volumeMounts:
    - name: lun0p1
      mountPath: "/tmp"
  volumes:
    - name: lun0p1
      hostPath:
        path: /var/lib/lun0p1
        type: DirectoryOrCreate
  nodeSelector:
    disktype: ultrassd</pre></li></ul></div></section><section class="section" id="machineset-troubleshooting-azure-ultra-disk_persistent-storage-azure"><div class="titlepage"><div><div><h4 class="title">4.2.4.2. Troubleshooting resources for machine sets that enable ultra disks</h4></div></div></div><p>
						Use the information in this section to understand and recover from issues you might encounter.
					</p><section class="section" id="ts-pvc-mounting-ultra_persistent-storage-azure"><div class="titlepage"><div><div><h5 class="title">4.2.4.2.1. Unable to mount a persistent volume claim backed by an ultra disk</h5></div></div></div><p>
							If there is an issue mounting a persistent volume claim backed by an ultra disk, the pod becomes stuck in the <code class="literal">ContainerCreating</code> state and an alert is triggered.
						</p><p>
							For example, if the <code class="literal">additionalCapabilities.ultraSSDEnabled</code> parameter is not set on the machine that backs the node that hosts the pod, the following error message appears:
						</p><pre class="programlisting language-terminal">StorageAccountType UltraSSD_LRS can be used only when additionalCapabilities.ultraSSDEnabled is set.</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									To resolve this issue, describe the pod by running the following command:
								</p><pre class="programlisting language-terminal">$ oc -n &lt;stuck_pod_namespace&gt; describe pod &lt;stuck_pod_name&gt;</pre></li></ul></div></section></section></section></section><section class="section" id="persistent-storage-using-azure-file"><div class="titlepage"><div><div><h2 class="title">4.3. Persistent storage using Azure File</h2></div></div></div><p>
				OpenShift Container Platform supports Microsoft Azure File volumes. You can provision your OpenShift Container Platform cluster with persistent storage using Azure. Some familiarity with Kubernetes and Azure is assumed.
			</p><p>
				The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure. You can provision Azure File volumes dynamically.
			</p><p>
				Persistent volumes are not bound to a single project or namespace, and you can share them across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace, and can be requested by users for use in applications.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Azure File volumes use Server Message Block.
				</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration</a>.
				</p><p>
					After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.
				</p></div></div><div class="itemizedlist"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
						<a class="link" href="https://azure.microsoft.com/en-us/services/storage/files/">Azure Files</a>
					</li></ul></div><section class="section" id="create-azure-file-secret_persistent-storage-azure-file"><div class="titlepage"><div><div><h3 class="title">4.3.1. Create the Azure File share persistent volume claim</h3></div></div></div><p>
					To create the persistent volume claim, you must first define a <code class="literal">Secret</code> object that contains the Azure account and key. This secret is used in the <code class="literal">PersistentVolume</code> definition, and will be referenced by the persistent volume claim for use in applications.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							An Azure File share exists.
						</li><li class="listitem">
							The credentials to access this share, specifically the storage account and key, are available.
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a <code class="literal">Secret</code> object that contains the Azure File credentials:
						</p><pre class="programlisting language-terminal">$ oc create secret generic &lt;secret-name&gt; --from-literal=azurestorageaccountname=&lt;storage-account&gt; \ <span id="CO15-1"><!--Empty--></span><span class="callout">1</span>
  --from-literal=azurestorageaccountkey=&lt;storage-account-key&gt; <span id="CO15-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO15-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The Azure File storage account name.
								</div></dd><dt><a href="#CO15-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The Azure File storage account key.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create a <code class="literal">PersistentVolume</code> object that references the <code class="literal">Secret</code> object you created:
						</p><pre class="programlisting language-yaml">apiVersion: "v1"
kind: "PersistentVolume"
metadata:
  name: "pv0001" <span id="CO16-1"><!--Empty--></span><span class="callout">1</span>
spec:
  capacity:
    storage: "5Gi" <span id="CO16-2"><!--Empty--></span><span class="callout">2</span>
  accessModes:
    - "ReadWriteOnce"
  storageClassName: azure-file-sc
  azureFile:
    secretName: &lt;secret-name&gt; <span id="CO16-3"><!--Empty--></span><span class="callout">3</span>
    shareName: share-1 <span id="CO16-4"><!--Empty--></span><span class="callout">4</span>
    readOnly: false</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO16-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the persistent volume.
								</div></dd><dt><a href="#CO16-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The size of this persistent volume.
								</div></dd><dt><a href="#CO16-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									The name of the secret that contains the Azure File share credentials.
								</div></dd><dt><a href="#CO16-4"><span class="callout">4</span></a> </dt><dd><div class="para">
									The name of the Azure File share.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create a <code class="literal">PersistentVolumeClaim</code> object that maps to the persistent volume you created:
						</p><pre class="programlisting language-yaml">apiVersion: "v1"
kind: "PersistentVolumeClaim"
metadata:
  name: "claim1" <span id="CO17-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "5Gi" <span id="CO17-2"><!--Empty--></span><span class="callout">2</span>
  storageClassName: azure-file-sc <span id="CO17-3"><!--Empty--></span><span class="callout">3</span>
  volumeName: "pv0001" <span id="CO17-4"><!--Empty--></span><span class="callout">4</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO17-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the persistent volume claim.
								</div></dd><dt><a href="#CO17-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The size of this persistent volume claim.
								</div></dd><dt><a href="#CO17-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									The name of the storage class that is used to provision the persistent volume. Specify the storage class used in the <code class="literal">PersistentVolume</code> definition.
								</div></dd><dt><a href="#CO17-4"><span class="callout">4</span></a> </dt><dd><div class="para">
									The name of the existing <code class="literal">PersistentVolume</code> object that references the Azure File share.
								</div></dd></dl></div></li></ol></div></section><section class="section" id="create-azure-file-pod_persistent-storage-azure-file"><div class="titlepage"><div><div><h3 class="title">4.3.2. Mount the Azure File share in a pod</h3></div></div></div><p>
					After the persistent volume claim has been created, it can be used inside by an application. The following example demonstrates mounting this share inside of a pod.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							A persistent volume claim exists that is mapped to the underlying Azure File share.
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Create a pod that mounts the existing persistent volume claim:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-name <span id="CO18-1"><!--Empty--></span><span class="callout">1</span>
spec:
  containers:
    ...
    volumeMounts:
    - mountPath: "/data" <span id="CO18-2"><!--Empty--></span><span class="callout">2</span>
      name: azure-file-share
  volumes:
    - name: azure-file-share
      persistentVolumeClaim:
        claimName: claim1 <span id="CO18-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO18-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the pod.
								</div></dd><dt><a href="#CO18-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The path to mount the Azure File share inside the pod. Do not mount to the container root, <code class="literal">/</code>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <code class="literal">/dev/pts</code> files. It is safe to mount the host by using <code class="literal">/host</code>.
								</div></dd><dt><a href="#CO18-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									The name of the <code class="literal">PersistentVolumeClaim</code> object that has been previously created.
								</div></dd></dl></div></li></ul></div></section></section><section class="section" id="persistent-storage-cinder"><div class="titlepage"><div><div><h2 class="title">4.4. Persistent storage using Cinder</h2></div></div></div><p>
				OpenShift Container Platform supports OpenStack Cinder. Some familiarity with Kubernetes and OpenStack is assumed.
			</p><p>
				Cinder volumes can be provisioned dynamically. Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace and can be requested by users.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision Cinder storage.
				</p><p>
					In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration</a>.
				</p><p>
					After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.
				</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						For more information about how OpenStack Block Storage provides persistent block storage management for virtual hard drives, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_openstack_platform/8/html-single/architecture_guide/index#comp-cinder">OpenStack Cinder</a>.
					</li></ul></div><section class="section" id="persistent-storage-cinder-provisioning_persistent-storage-cinder"><div class="titlepage"><div><div><h3 class="title">4.4.1. Manual provisioning with Cinder</h3></div></div></div><p>
					Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							OpenShift Container Platform configured for Red Hat OpenStack Platform (RHOSP)
						</li><li class="listitem">
							Cinder volume ID
						</li></ul></div><section class="section" id="persistent-storage-cinder-creating-pv_persistent-storage-cinder"><div class="titlepage"><div><div><h4 class="title">4.4.1.1. Creating the persistent volume</h4></div></div></div><p>
						You must define your persistent volume (PV) in an object definition before creating it in OpenShift Container Platform:
					</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Save your object definition to a file.
							</p><div class="formalpara"><p class="title"><strong>cinder-persistentvolume.yaml</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: "v1"
kind: "PersistentVolume"
metadata:
  name: "pv0001" <span id="CO19-1"><!--Empty--></span><span class="callout">1</span>
spec:
  capacity:
    storage: "5Gi" <span id="CO19-2"><!--Empty--></span><span class="callout">2</span>
  accessModes:
    - "ReadWriteOnce"
  cinder: <span id="CO19-3"><!--Empty--></span><span class="callout">3</span>
    fsType: "ext3" <span id="CO19-4"><!--Empty--></span><span class="callout">4</span>
    volumeID: "f37a03aa-6212-4c62-a805-9ce139fab180" <span id="CO19-5"><!--Empty--></span><span class="callout">5</span></pre>

								</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO19-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The name of the volume that is used by persistent volume claims or pods.
									</div></dd><dt><a href="#CO19-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The amount of storage allocated to this volume.
									</div></dd><dt><a href="#CO19-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										Indicates <code class="literal">cinder</code> for Red Hat OpenStack Platform (RHOSP) Cinder volumes.
									</div></dd><dt><a href="#CO19-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The file system that is created when the volume is mounted for the first time.
									</div></dd><dt><a href="#CO19-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										The Cinder volume to use.
									</div></dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
									Do not change the <code class="literal">fstype</code> parameter value after the volume is formatted and provisioned. Changing this value can result in data loss and pod failure.
								</p></div></div></li><li class="listitem"><p class="simpara">
								Create the object definition file you saved in the previous step.
							</p><pre class="programlisting language-terminal">$ oc create -f cinder-persistentvolume.yaml</pre></li></ol></div></section><section class="section" id="persistent-storage-cinder-pv-format_persistent-storage-cinder"><div class="titlepage"><div><div><h4 class="title">4.4.1.2. Persistent volume formatting</h4></div></div></div><p>
						You can use unformatted Cinder volumes as PVs because OpenShift Container Platform formats them before the first use.
					</p><p>
						Before OpenShift Container Platform mounts the volume and passes it to a container, the system checks that it contains a file system as specified by the <code class="literal">fsType</code> parameter in the PV definition. If the device is not formatted with the file system, all data from the device is erased and the device is automatically formatted with the given file system.
					</p></section><section class="section" id="persistent-storage-cinder-volume-security_persistent-storage-cinder"><div class="titlepage"><div><div><h4 class="title">4.4.1.3. Cinder volume security</h4></div></div></div><p>
						If you use Cinder PVs in your application, configure security for their deployment configurations.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								An SCC must be created that uses the appropriate <code class="literal">fsGroup</code> strategy.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Create a service account and add it to the SCC:
							</p><pre class="programlisting language-terminal">$ oc create serviceaccount &lt;service_account&gt;</pre><pre class="programlisting language-terminal">$ oc adm policy add-scc-to-user &lt;new_scc&gt; -z &lt;service_account&gt; -n &lt;project&gt;</pre></li><li class="listitem"><p class="simpara">
								In your application’s deployment configuration, provide the service account name and <code class="literal">securityContext</code>:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: ReplicationController
metadata:
  name: frontend-1
spec:
  replicas: 1  <span id="CO20-1"><!--Empty--></span><span class="callout">1</span>
  selector:    <span id="CO20-2"><!--Empty--></span><span class="callout">2</span>
    name: frontend
  template:    <span id="CO20-3"><!--Empty--></span><span class="callout">3</span>
    metadata:
      labels:  <span id="CO20-4"><!--Empty--></span><span class="callout">4</span>
        name: frontend <span id="CO20-5"><!--Empty--></span><span class="callout">5</span>
    spec:
      containers:
      - image: openshift/hello-openshift
        name: helloworld
        ports:
        - containerPort: 8080
          protocol: TCP
      restartPolicy: Always
      serviceAccountName: &lt;service_account&gt; <span id="CO20-6"><!--Empty--></span><span class="callout">6</span>
      securityContext:
        fsGroup: 7777 <span id="CO20-7"><!--Empty--></span><span class="callout">7</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO20-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The number of copies of the pod to run.
									</div></dd><dt><a href="#CO20-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The label selector of the pod to run.
									</div></dd><dt><a href="#CO20-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										A template for the pod that the controller creates.
									</div></dd><dt><a href="#CO20-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The labels on the pod. They must include labels from the label selector.
									</div></dd><dt><a href="#CO20-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										The maximum name length after expanding any parameters is 63 characters.
									</div></dd><dt><a href="#CO20-6"><span class="callout">6</span></a> </dt><dd><div class="para">
										Specifies the service account you created.
									</div></dd><dt><a href="#CO20-7"><span class="callout">7</span></a> </dt><dd><div class="para">
										Specifies an <code class="literal">fsGroup</code> for the pods.
									</div></dd></dl></div></li></ol></div></section></section></section><section class="section" id="persistent-storage-using-fibre"><div class="titlepage"><div><div><h2 class="title">4.5. Persistent storage using Fibre Channel</h2></div></div></div><p>
				OpenShift Container Platform supports Fibre Channel, allowing you to provision your OpenShift Container Platform cluster with persistent storage using Fibre channel volumes. Some familiarity with Kubernetes and Fibre Channel is assumed.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Persistent storage using Fibre Channel is not supported on ARM architecture based infrastructures.
				</p></div></div><p>
				The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure. Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace and can be requested by users.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_storage_devices/using-fibre-channel-devices_managing-storage-devices">Using Fibre Channel devices</a>
					</li></ul></div><section class="section" id="provisioning-fibre_persistent-storage-fibre"><div class="titlepage"><div><div><h3 class="title">4.5.1. Provisioning</h3></div></div></div><p>
					To provision Fibre Channel volumes using the <code class="literal">PersistentVolume</code> API the following must be available:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <code class="literal">targetWWNs</code> (array of Fibre Channel target’s World Wide Names).
						</li><li class="listitem">
							A valid LUN number.
						</li><li class="listitem">
							The filesystem type.
						</li></ul></div><p>
					A persistent volume and a LUN have a one-to-one mapping between them.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Fibre Channel LUNs must exist in the underlying infrastructure.
						</li></ul></div><div class="formalpara"><p class="title"><strong><code class="literal">PersistentVolume</code> object definition</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  fc:
    wwids: [scsi-3600508b400105e210000900000490000] <span id="CO21-1"><!--Empty--></span><span class="callout">1</span>
    targetWWNs: ['500a0981891b8dc5', '500a0981991b8dc5'] <span id="CO21-2"><!--Empty--></span><span class="callout">2</span>
    lun: 2 <span id="CO21-3"><!--Empty--></span><span class="callout">3</span>
    fsType: ext4</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO21-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							World wide identifiers (WWIDs). Either FC <code class="literal"><span class="strong strong"><strong>wwids</strong></span></code> or a combination of FC <code class="literal"><span class="strong strong"><strong>targetWWNs</strong></span></code> and <code class="literal"><span class="strong strong"><strong>lun</strong></span></code> must be set, but not both simultaneously. The FC WWID identifier is recommended over the WWNs target because it is guaranteed to be unique for every storage device, and independent of the path that is used to access the device. The WWID identifier can be obtained by issuing a SCSI Inquiry to retrieve the Device Identification Vital Product Data (<code class="literal"><span class="strong strong"><strong>page 0x83</strong></span></code>) or Unit Serial Number (<code class="literal"><span class="strong strong"><strong>page 0x80</strong></span></code>). FC WWIDs are identified as <code class="literal"><span class="strong strong"><strong>/dev/disk/by-id/</strong></span></code> to reference the data on the disk, even if the path to the device changes and even when accessing the device from different systems.
						</div></dd><dt><a href="#CO21-2"><span class="callout">2</span></a> <a href="#CO21-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							Fibre Channel WWNs are identified as <code class="literal">/dev/disk/by-path/pci-&lt;IDENTIFIER&gt;-fc-0x&lt;WWN&gt;-lun-&lt;LUN#&gt;</code>, but you do not need to provide any part of the path leading up to the <code class="literal">WWN</code>, including the <code class="literal">0x</code>, and anything after, including the <code class="literal">-</code> (hyphen).
						</div></dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Changing the value of the <code class="literal">fstype</code> parameter after the volume has been formatted and provisioned can result in data loss and pod failure.
					</p></div></div><section class="section" id="enforcing-disk-quota_persistent-storage-fibre"><div class="titlepage"><div><div><h4 class="title">4.5.1.1. Enforcing disk quotas</h4></div></div></div><p>
						Use LUN partitions to enforce disk quotas and size constraints. Each LUN is mapped to a single persistent volume, and unique names must be used for persistent volumes.
					</p><p>
						Enforcing quotas in this way allows the end user to request persistent storage by a specific amount, such as 10Gi, and be matched with a corresponding volume of equal or greater capacity.
					</p></section><section class="section" id="fibre-volume-security_persistent-storage-fibre"><div class="titlepage"><div><div><h4 class="title">4.5.1.2. Fibre Channel volume security</h4></div></div></div><p>
						Users request storage with a persistent volume claim. This claim only lives in the user’s namespace, and can only be referenced by a pod within that same namespace. Any attempt to access a persistent volume across a namespace causes the pod to fail.
					</p><p>
						Each Fibre Channel LUN must be accessible by all nodes in the cluster.
					</p></section></section></section><section class="section" id="persistent-storage-using-flexvolume"><div class="titlepage"><div><div><h2 class="title">4.6. Persistent storage using FlexVolume</h2></div></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					FlexVolume is a deprecated feature. Deprecated functionality is still included in OpenShift Container Platform and continues to be supported; however, it will be removed in a future release of this product and is not recommended for new deployments.
				</p><p>
					Out-of-tree Container Storage Interface (CSI) driver is the recommended way to write volume drivers in OpenShift Container Platform. Maintainers of FlexVolume drivers should implement a CSI driver and move users of FlexVolume to CSI. Users of FlexVolume should move their workloads to CSI driver.
				</p><p>
					For the most recent list of major functionality that has been deprecated or removed within OpenShift Container Platform, refer to the <span class="emphasis"><em>Deprecated and removed features</em></span> section of the OpenShift Container Platform release notes.
				</p></div></div><p>
				OpenShift Container Platform supports FlexVolume, an out-of-tree plugin that uses an executable model to interface with drivers.
			</p><p>
				To use storage from a back-end that does not have a built-in plugin, you can extend OpenShift Container Platform through FlexVolume drivers and provide persistent storage to applications.
			</p><p>
				Pods interact with FlexVolume drivers through the <code class="literal">flexvolume</code> in-tree plugin.
			</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#expanding-persistent-volumes">Expanding persistent volumes</a>
					</li></ul></div><section class="section" id="flexvolume-drivers_persistent-storage-flexvolume"><div class="titlepage"><div><div><h3 class="title">4.6.1. About FlexVolume drivers</h3></div></div></div><p>
					A FlexVolume driver is an executable file that resides in a well-defined directory on all nodes in the cluster. OpenShift Container Platform calls the FlexVolume driver whenever it needs to mount or unmount a volume represented by a <code class="literal">PersistentVolume</code> object with <code class="literal">flexVolume</code> as the source.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Attach and detach operations are not supported in OpenShift Container Platform for FlexVolume.
					</p></div></div></section><section class="section" id="flexvolume-driver-example_persistent-storage-flexvolume"><div class="titlepage"><div><div><h3 class="title">4.6.2. FlexVolume driver example</h3></div></div></div><p>
					The first command-line argument of the FlexVolume driver is always an operation name. Other parameters are specific to each operation. Most of the operations take a JavaScript Object Notation (JSON) string as a parameter. This parameter is a complete JSON string, and not the name of a file with the JSON data.
				</p><p>
					The FlexVolume driver contains:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							All <code class="literal">flexVolume.options</code>.
						</li><li class="listitem">
							Some options from <code class="literal">flexVolume</code> prefixed by <code class="literal">kubernetes.io/</code>, such as <code class="literal">fsType</code> and <code class="literal">readwrite</code>.
						</li><li class="listitem">
							The content of the referenced secret, if specified, prefixed by <code class="literal">kubernetes.io/secret/</code>.
						</li></ul></div><div class="formalpara"><p class="title"><strong>FlexVolume driver JSON input example</strong></p><p>
						
<pre class="programlisting language-json">{
	"fooServer": "192.168.0.1:1234", <span id="CO22-1"><!--Empty--></span><span class="callout">1</span>
        "fooVolumeName": "bar",
	"kubernetes.io/fsType": "ext4", <span id="CO22-2"><!--Empty--></span><span class="callout">2</span>
	"kubernetes.io/readwrite": "ro", <span id="CO22-3"><!--Empty--></span><span class="callout">3</span>
	"kubernetes.io/secret/&lt;key name&gt;": "&lt;key value&gt;", <span id="CO22-4"><!--Empty--></span><span class="callout">4</span>
	"kubernetes.io/secret/&lt;another key name&gt;": "&lt;another key value&gt;",
}</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO22-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							All options from <code class="literal">flexVolume.options</code>.
						</div></dd><dt><a href="#CO22-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							The value of <code class="literal">flexVolume.fsType</code>.
						</div></dd><dt><a href="#CO22-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							<code class="literal">ro</code>/<code class="literal">rw</code> based on <code class="literal">flexVolume.readOnly</code>.
						</div></dd><dt><a href="#CO22-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							All keys and their values from the secret referenced by <code class="literal">flexVolume.secretRef</code>.
						</div></dd></dl></div><p>
					OpenShift Container Platform expects JSON data on standard output of the driver. When not specified, the output describes the result of the operation.
				</p><div class="formalpara"><p class="title"><strong>FlexVolume driver default output example</strong></p><p>
						
<pre class="programlisting language-json">{
	"status": "&lt;Success/Failure/Not supported&gt;",
	"message": "&lt;Reason for success/failure&gt;"
}</pre>

					</p></div><p>
					Exit code of the driver should be <code class="literal">0</code> for success and <code class="literal">1</code> for error.
				</p><p>
					Operations should be idempotent, which means that the mounting of an already mounted volume should result in a successful operation.
				</p></section><section class="section" id="flexvolume-installing_persistent-storage-flexvolume"><div class="titlepage"><div><div><h3 class="title">4.6.3. Installing FlexVolume drivers</h3></div></div></div><p>
					FlexVolume drivers that are used to extend OpenShift Container Platform are executed only on the node. To implement FlexVolumes, a list of operations to call and the installation path are all that is required.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							FlexVolume drivers must implement these operations:
						</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">init</code></span></dt><dd><p class="simpara">
										Initializes the driver. It is called during initialization of all nodes.
									</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
												Arguments: none
											</li><li class="listitem">
												Executed on: node
											</li><li class="listitem">
												Expected output: default JSON
											</li></ul></div></dd><dt><span class="term"><code class="literal">mount</code></span></dt><dd><p class="simpara">
										Mounts a volume to directory. This can include anything that is necessary to mount the volume, including finding the device and then mounting the device.
									</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
												Arguments: <code class="literal">&lt;mount-dir&gt;</code> <code class="literal">&lt;json&gt;</code>
											</li><li class="listitem">
												Executed on: node
											</li><li class="listitem">
												Expected output: default JSON
											</li></ul></div></dd><dt><span class="term"><code class="literal">unmount</code></span></dt><dd><p class="simpara">
										Unmounts a volume from a directory. This can include anything that is necessary to clean up the volume after unmounting.
									</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
												Arguments: <code class="literal">&lt;mount-dir&gt;</code>
											</li><li class="listitem">
												Executed on: node
											</li><li class="listitem">
												Expected output: default JSON
											</li></ul></div></dd><dt><span class="term"><code class="literal">mountdevice</code></span></dt><dd>
										Mounts a volume’s device to a directory where individual pods can then bind mount.
									</dd></dl></div></li></ul></div><p>
					This call-out does not pass "secrets" specified in the FlexVolume spec. If your driver requires secrets, do not implement this call-out.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Arguments: <code class="literal">&lt;mount-dir&gt;</code> <code class="literal">&lt;json&gt;</code>
						</li><li class="listitem">
							Executed on: node
						</li><li class="listitem"><p class="simpara">
							Expected output: default JSON
						</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">unmountdevice</code></span></dt><dd>
										Unmounts a volume’s device from a directory.
									</dd></dl></div></li><li class="listitem">
							Arguments: <code class="literal">&lt;mount-dir&gt;</code>
						</li><li class="listitem">
							Executed on: node
						</li><li class="listitem"><p class="simpara">
							Expected output: default JSON
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									All other operations should return JSON with <code class="literal">{"status": "Not supported"}</code> and exit code <code class="literal">1</code>.
								</li></ul></div></li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To install the FlexVolume driver:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Ensure that the executable file exists on all nodes in the cluster.
						</li><li class="listitem">
							Place the executable file at the volume plugin path: <code class="literal">/etc/kubernetes/kubelet-plugins/volume/exec/&lt;vendor&gt;~&lt;driver&gt;/&lt;driver&gt;</code>.
						</li></ol></div><p>
					For example, to install the FlexVolume driver for the storage <code class="literal">foo</code>, place the executable file at: <code class="literal">/etc/kubernetes/kubelet-plugins/volume/exec/openshift.com~foo/foo</code>.
				</p></section><section class="section" id="flexvolume-driver-consuming_persistent-storage-flexvolume"><div class="titlepage"><div><div><h3 class="title">4.6.4. Consuming storage using FlexVolume drivers</h3></div></div></div><p>
					Each <code class="literal">PersistentVolume</code> object in OpenShift Container Platform represents one storage asset in the storage back-end, such as a volume.
				</p><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Use the <code class="literal">PersistentVolume</code> object to reference the installed storage.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Persistent volume object definition using FlexVolume drivers example</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 <span id="CO23-1"><!--Empty--></span><span class="callout">1</span>
spec:
  capacity:
    storage: 1Gi <span id="CO23-2"><!--Empty--></span><span class="callout">2</span>
  accessModes:
    - ReadWriteOnce
  flexVolume:
    driver: openshift.com/foo <span id="CO23-3"><!--Empty--></span><span class="callout">3</span>
    fsType: "ext4" <span id="CO23-4"><!--Empty--></span><span class="callout">4</span>
    secretRef: foo-secret <span id="CO23-5"><!--Empty--></span><span class="callout">5</span>
    readOnly: true <span id="CO23-6"><!--Empty--></span><span class="callout">6</span>
    options: <span id="CO23-7"><!--Empty--></span><span class="callout">7</span>
      fooServer: 192.168.0.1:1234
      fooVolumeName: bar</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO23-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							The name of the volume. This is how it is identified through persistent volume claims or from pods. This name can be different from the name of the volume on back-end storage.
						</div></dd><dt><a href="#CO23-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							The amount of storage allocated to this volume.
						</div></dd><dt><a href="#CO23-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							The name of the driver. This field is mandatory.
						</div></dd><dt><a href="#CO23-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							The file system that is present on the volume. This field is optional.
						</div></dd><dt><a href="#CO23-5"><span class="callout">5</span></a> </dt><dd><div class="para">
							The reference to a secret. Keys and values from this secret are provided to the FlexVolume driver on invocation. This field is optional.
						</div></dd><dt><a href="#CO23-6"><span class="callout">6</span></a> </dt><dd><div class="para">
							The read-only flag. This field is optional.
						</div></dd><dt><a href="#CO23-7"><span class="callout">7</span></a> </dt><dd><div class="para">
							The additional options for the FlexVolume driver. In addition to the flags specified by the user in the <code class="literal">options</code> field, the following flags are also passed to the executable:
						</div><pre class="literallayout">"fsType":"&lt;FS type&gt;",
"readwrite":"&lt;rw&gt;",
"secret/key1":"&lt;secret1&gt;"
...
"secret/keyN":"&lt;secretN&gt;"</pre></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Secrets are passed only to mount or unmount call-outs.
					</p></div></div></section></section><section class="section" id="persistent-storage-using-gce"><div class="titlepage"><div><div><h2 class="title">4.7. Persistent storage using GCE Persistent Disk</h2></div></div></div><p>
				OpenShift Container Platform supports GCE Persistent Disk volumes (gcePD). You can provision your OpenShift Container Platform cluster with persistent storage using GCE. Some familiarity with Kubernetes and GCE is assumed.
			</p><p>
				The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure.
			</p><p>
				GCE Persistent Disk volumes can be provisioned dynamically.
			</p><p>
				Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace and can be requested by users.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision gcePD storage.
				</p><p>
					In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plug-ins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration</a>.
				</p><p>
					After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.
				</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://cloud.google.com/compute/docs/disks/">GCE Persistent Disk</a>
					</li></ul></div><section class="section" id="storage-create-storage-class_persistent-storage-gce"><div class="titlepage"><div><div><h3 class="title">4.7.1. Creating the GCE storage class</h3></div></div></div><p>
					Storage classes are used to differentiate and delineate storage levels and usages. By defining a storage class, users can obtain dynamically provisioned persistent volumes.
				</p></section><section class="section" id="creating-the-persistent-volume-claim-3"><div class="titlepage"><div><div><h3 class="title">4.7.2. Creating the persistent volume claim</h3></div></div></div><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
					</p></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Persistent Volume Claims</strong></span>.
						</li><li class="listitem">
							In the persistent volume claims overview, click <span class="strong strong"><strong>Create Persistent Volume Claim</strong></span>.
						</li><li class="listitem"><p class="simpara">
							Define the desired options on the page that appears.
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Select the previously-created storage class from the drop-down menu.
								</li><li class="listitem">
									Enter a unique name for the storage claim.
								</li><li class="listitem">
									Select the access mode. This selection determines the read and write access for the storage claim.
								</li><li class="listitem">
									Define the size of the storage claim.
								</li></ol></div></li><li class="listitem">
							Click <span class="strong strong"><strong>Create</strong></span> to create the persistent volume claim and generate a persistent volume.
						</li></ol></div></section><section class="section" id="volume-format-GCE_persistent-storage-gce"><div class="titlepage"><div><div><h3 class="title">4.7.3. Volume format</h3></div></div></div><p>
					Before OpenShift Container Platform mounts the volume and passes it to a container, it checks that the volume contains a file system as specified by the <code class="literal">fsType</code> parameter in the persistent volume definition. If the device is not formatted with the file system, all data from the device is erased and the device is automatically formatted with the given file system.
				</p><p>
					This verification enables you to use unformatted GCE volumes as persistent volumes, because OpenShift Container Platform formats them before the first use.
				</p></section></section><section class="section" id="persistent-storage-using-iscsi"><div class="titlepage"><div><div><h2 class="title">4.8. Persistent storage using iSCSI</h2></div></div></div><p>
				You can provision your OpenShift Container Platform cluster with persistent storage using <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html-single/managing_storage_devices/index#getting-started-with-iscsi_managing-storage-devices">iSCSI</a>. Some familiarity with Kubernetes and iSCSI is assumed.
			</p><p>
				The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					High-availability of storage in the infrastructure is left to the underlying storage provider.
				</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					When you use iSCSI on Amazon Web Services, you must update the default security policy to include TCP traffic between nodes on the iSCSI ports. By default, they are ports <code class="literal">860</code> and <code class="literal">3260</code>.
				</p></div></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Users must ensure that the iSCSI initiator is already configured on all OpenShift Container Platform nodes by installing the <code class="literal">iscsi-initiator-utils</code> package and configuring their initiator name in <code class="literal">/etc/iscsi/initiatorname.iscsi</code>. The <code class="literal">iscsi-initiator-utils</code> package is already installed on deployments that use Red Hat Enterprise Linux CoreOS (RHCOS).
				</p><p>
					For more information, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/9/html-single/managing_storage_devices/index#configuring-an-iscsi-initiator_managing-storage-devices">Managing Storage Devices</a>.
				</p></div></div><section class="section" id="persistent-storage-iscsi-provisioning_persistent-storage-iscsi"><div class="titlepage"><div><div><h3 class="title">4.8.1. Provisioning</h3></div></div></div><p>
					Verify that the storage exists in the underlying infrastructure before mounting it as a volume in OpenShift Container Platform. All that is required for the iSCSI is the iSCSI target portal, a valid iSCSI Qualified Name (IQN), a valid LUN number, the filesystem type, and the <code class="literal">PersistentVolume</code> API.
				</p><div class="formalpara"><p class="title"><strong><code class="literal">PersistentVolume</code> object definition</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
     targetPortal: 10.16.154.81:3260
     iqn: iqn.2014-12.example.server:storage.target00
     lun: 0
     fsType: 'ext4'</pre>

					</p></div></section><section class="section" id="enforcing-disk-quotas-iscsi_persistent-storage-iscsi"><div class="titlepage"><div><div><h3 class="title">4.8.2. Enforcing disk quotas</h3></div></div></div><p>
					Use LUN partitions to enforce disk quotas and size constraints. Each LUN is one persistent volume. Kubernetes enforces unique names for persistent volumes.
				</p><p>
					Enforcing quotas in this way allows the end user to request persistent storage by a specific amount (for example, <code class="literal">10Gi</code>) and be matched with a corresponding volume of equal or greater capacity.
				</p></section><section class="section" id="volume-security-iscsi_persistent-storage-iscsi"><div class="titlepage"><div><div><h3 class="title">4.8.3. iSCSI volume security</h3></div></div></div><p>
					Users request storage with a <code class="literal">PersistentVolumeClaim</code> object. This claim only lives in the user’s namespace and can only be referenced by a pod within that same namespace. Any attempt to access a persistent volume claim across a namespace causes the pod to fail.
				</p><p>
					Each iSCSI LUN must be accessible by all nodes in the cluster.
				</p><section class="section" id="challenge-handshake-authentication-protocol-chap-configuration"><div class="titlepage"><div><div><h4 class="title">4.8.3.1. Challenge Handshake Authentication Protocol (CHAP) configuration</h4></div></div></div><p>
						Optionally, OpenShift Container Platform can use CHAP to authenticate itself to iSCSI targets:
					</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
    targetPortal: 10.0.0.1:3260
    iqn: iqn.2016-04.test.com:storage.target00
    lun: 0
    fsType: ext4
    chapAuthDiscovery: true <span id="CO24-1"><!--Empty--></span><span class="callout">1</span>
    chapAuthSession: true <span id="CO24-2"><!--Empty--></span><span class="callout">2</span>
    secretRef:
      name: chap-secret <span id="CO24-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO24-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Enable CHAP authentication of iSCSI discovery.
							</div></dd><dt><a href="#CO24-2"><span class="callout">2</span></a> </dt><dd><div class="para">
								Enable CHAP authentication of iSCSI session.
							</div></dd><dt><a href="#CO24-3"><span class="callout">3</span></a> </dt><dd><div class="para">
								Specify name of Secrets object with user name + password. This <code class="literal">Secret</code> object must be available in all namespaces that can use the referenced volume.
							</div></dd></dl></div></section></section><section class="section" id="iscsi-multipath_persistent-storage-iscsi"><div class="titlepage"><div><div><h3 class="title">4.8.4. iSCSI multipathing</h3></div></div></div><p>
					For iSCSI-based storage, you can configure multiple paths by using the same IQN for more than one target portal IP address. Multipathing ensures access to the persistent volume when one or more of the components in a path fail.
				</p><p>
					To specify multi-paths in the pod specification, use the <code class="literal">portals</code> field. For example:
				</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
    targetPortal: 10.0.0.1:3260
    portals: ['10.0.2.16:3260', '10.0.2.17:3260', '10.0.2.18:3260'] <span id="CO25-1"><!--Empty--></span><span class="callout">1</span>
    iqn: iqn.2016-04.test.com:storage.target00
    lun: 0
    fsType: ext4
    readOnly: false</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO25-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Add additional target portals using the <code class="literal">portals</code> field.
						</div></dd></dl></div></section><section class="section" id="iscsi-custom-iqn_persistent-storage-iscsi"><div class="titlepage"><div><div><h3 class="title">4.8.5. iSCSI custom initiator IQN</h3></div></div></div><p>
					Configure the custom initiator iSCSI Qualified Name (IQN) if the iSCSI targets are restricted to certain IQNs, but the nodes that the iSCSI PVs are attached to are not guaranteed to have these IQNs.
				</p><p>
					To specify a custom initiator IQN, use <code class="literal">initiatorName</code> field.
				</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: iscsi-pv
spec:
  capacity:
    storage: 1Gi
  accessModes:
    - ReadWriteOnce
  iscsi:
    targetPortal: 10.0.0.1:3260
    portals: ['10.0.2.16:3260', '10.0.2.17:3260', '10.0.2.18:3260']
    iqn: iqn.2016-04.test.com:storage.target00
    lun: 0
    initiatorName: iqn.2016-04.test.com:custom.iqn <span id="CO26-1"><!--Empty--></span><span class="callout">1</span>
    fsType: ext4
    readOnly: false</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO26-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Specify the name of the initiator.
						</div></dd></dl></div></section></section><section class="section" id="persistent-storage-using-nfs"><div class="titlepage"><div><div><h2 class="title">4.9. Persistent storage using NFS</h2></div></div></div><p>
				OpenShift Container Platform clusters can be provisioned with persistent storage using NFS. Persistent volumes (PVs) and persistent volume claims (PVCs) provide a convenient method for sharing a volume across a project. While the NFS-specific information contained in a PV definition could also be defined directly in a <code class="literal">Pod</code> definition, doing so does not create the volume as a distinct cluster resource, making the volume more susceptible to conflicts.
			</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/storage_administration_guide/ch-nfs">Network File System (NFS)</a>
					</li></ul></div><section class="section" id="persistent-storage-nfs-provisioning_persistent-storage-nfs"><div class="titlepage"><div><div><h3 class="title">4.9.1. Provisioning</h3></div></div></div><p>
					Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform. To provision NFS volumes, a list of NFS servers and export paths are all that is required.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create an object definition for the PV:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv0001 <span id="CO27-1"><!--Empty--></span><span class="callout">1</span>
spec:
  capacity:
    storage: 5Gi <span id="CO27-2"><!--Empty--></span><span class="callout">2</span>
  accessModes:
  - ReadWriteOnce <span id="CO27-3"><!--Empty--></span><span class="callout">3</span>
  nfs: <span id="CO27-4"><!--Empty--></span><span class="callout">4</span>
    path: /tmp <span id="CO27-5"><!--Empty--></span><span class="callout">5</span>
    server: 172.17.0.2 <span id="CO27-6"><!--Empty--></span><span class="callout">6</span>
  persistentVolumeReclaimPolicy: Retain <span id="CO27-7"><!--Empty--></span><span class="callout">7</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO27-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the volume. This is the PV identity in various <code class="literal">oc &lt;command&gt; pod</code> commands.
								</div></dd><dt><a href="#CO27-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The amount of storage allocated to this volume.
								</div></dd><dt><a href="#CO27-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									Though this appears to be related to controlling access to the volume, it is actually used similarly to labels and used to match a PVC to a PV. Currently, no access rules are enforced based on the <code class="literal">accessModes</code>.
								</div></dd><dt><a href="#CO27-4"><span class="callout">4</span></a> </dt><dd><div class="para">
									The volume type being used, in this case the <code class="literal">nfs</code> plugin.
								</div></dd><dt><a href="#CO27-5"><span class="callout">5</span></a> </dt><dd><div class="para">
									The path that is exported by the NFS server.
								</div></dd><dt><a href="#CO27-6"><span class="callout">6</span></a> </dt><dd><div class="para">
									The hostname or IP address of the NFS server.
								</div></dd><dt><a href="#CO27-7"><span class="callout">7</span></a> </dt><dd><div class="para">
									The reclaim policy for the PV. This defines what happens to a volume when released.
								</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Each NFS volume must be mountable by all schedulable nodes in the cluster.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Verify that the PV was created:
						</p><pre class="programlisting language-terminal">$ oc get pv</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME     LABELS    CAPACITY     ACCESSMODES   STATUS      CLAIM  REASON    AGE
pv0001   &lt;none&gt;    5Gi          RWO           Available                    31s</pre>

							</p></div></li><li class="listitem"><p class="simpara">
							Create a persistent volume claim that binds to the new PV:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: nfs-claim1
spec:
  accessModes:
    - ReadWriteOnce <span id="CO28-1"><!--Empty--></span><span class="callout">1</span>
  resources:
    requests:
      storage: 5Gi <span id="CO28-2"><!--Empty--></span><span class="callout">2</span>
  volumeName: pv0001
  storageClassName: ""</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO28-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The access modes do not enforce security, but rather act as labels to match a PV to a PVC.
								</div></dd><dt><a href="#CO28-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									This claim looks for PVs offering <span class="strong strong"><strong>5Gi</strong></span> or greater capacity.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Verify that the persistent volume claim was created:
						</p><pre class="programlisting language-terminal">$ oc get pvc</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME         STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
nfs-claim1   Bound    pv0001   5Gi        RWO                           2m</pre>

							</p></div></li></ol></div></section><section class="section" id="nfs-enforcing-disk-quota_persistent-storage-nfs"><div class="titlepage"><div><div><h3 class="title">4.9.2. Enforcing disk quotas</h3></div></div></div><p>
					You can use disk partitions to enforce disk quotas and size constraints. Each partition can be its own export. Each export is one PV. OpenShift Container Platform enforces unique names for PVs, but the uniqueness of the NFS volume’s server and path is up to the administrator.
				</p><p>
					Enforcing quotas in this way allows the developer to request persistent storage by a specific amount, such as 10Gi, and be matched with a corresponding volume of equal or greater capacity.
				</p></section><section class="section" id="nfs-volume-security_persistent-storage-nfs"><div class="titlepage"><div><div><h3 class="title">4.9.3. NFS volume security</h3></div></div></div><p>
					This section covers NFS volume security, including matching permissions and SELinux considerations. The user is expected to understand the basics of POSIX permissions, process UIDs, supplemental groups, and SELinux.
				</p><p>
					Developers request NFS storage by referencing either a PVC by name or the NFS volume plugin directly in the <code class="literal">volumes</code> section of their <code class="literal">Pod</code> definition.
				</p><p>
					The <code class="literal">/etc/exports</code> file on the NFS server contains the accessible NFS directories. The target NFS directory has POSIX owner and group IDs. The OpenShift Container Platform NFS plugin mounts the container’s NFS directory with the same POSIX ownership and permissions found on the exported NFS directory. However, the container is not run with its effective UID equal to the owner of the NFS mount, which is the desired behavior.
				</p><p>
					As an example, if the target NFS directory appears on the NFS server as:
				</p><pre class="programlisting language-terminal" id="nfs-export">$ ls -lZ /opt/nfs -d</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
						
<pre class="programlisting language-terminal">drwxrws---. nfsnobody 5555 unconfined_u:object_r:usr_t:s0   /opt/nfs</pre>

					</p></div><pre class="programlisting language-terminal">$ id nfsnobody</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
						
<pre class="programlisting language-terminal">uid=65534(nfsnobody) gid=65534(nfsnobody) groups=65534(nfsnobody)</pre>

					</p></div><p>
					Then the container must match SELinux labels, and either run with a UID of <code class="literal">65534</code>, the <code class="literal">nfsnobody</code> owner, or with <code class="literal">5555</code> in its supplemental groups to access the directory.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The owner ID of <code class="literal">65534</code> is used as an example. Even though NFS’s <code class="literal">root_squash</code> maps <code class="literal">root</code>, uid <code class="literal">0</code>, to <code class="literal">nfsnobody</code>, uid <code class="literal">65534</code>, NFS exports can have arbitrary owner IDs. Owner <code class="literal">65534</code> is not required for NFS exports.
					</p></div></div><section class="section" id="storage-persistent-storage-nfs-group-ids_persistent-storage-nfs"><div class="titlepage"><div><div><h4 class="title">4.9.3.1. Group IDs</h4></div></div></div><p>
						The recommended way to handle NFS access, assuming it is not an option to change permissions on the NFS export, is to use supplemental groups. Supplemental groups in OpenShift Container Platform are used for shared storage, of which NFS is an example. In contrast, block storage such as iSCSI uses the <code class="literal">fsGroup</code> SCC strategy and the <code class="literal">fsGroup</code> value in the <code class="literal">securityContext</code> of the pod.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							To gain access to persistent storage, it is generally preferable to use supplemental group IDs versus user IDs.
						</p></div></div><p>
						Because the group ID on the example target NFS directory is <code class="literal">5555</code>, the pod can define that group ID using <code class="literal">supplementalGroups</code> under the <code class="literal">securityContext</code> definition of the pod. For example:
					</p><pre class="programlisting language-yaml">spec:
  containers:
    - name:
    ...
  securityContext: <span id="CO29-1"><!--Empty--></span><span class="callout">1</span>
    supplementalGroups: [5555] <span id="CO29-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO29-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								<code class="literal">securityContext</code> must be defined at the pod level, not under a specific container.
							</div></dd><dt><a href="#CO29-2"><span class="callout">2</span></a> </dt><dd><div class="para">
								An array of GIDs defined for the pod. In this case, there is one element in the array. Additional GIDs would be comma-separated.
							</div></dd></dl></div><p>
						Assuming there are no custom SCCs that might satisfy the pod requirements, the pod likely matches the <code class="literal">restricted</code> SCC. This SCC has the <code class="literal">supplementalGroups</code> strategy set to <code class="literal">RunAsAny</code>, meaning that any supplied group ID is accepted without range checking.
					</p><p>
						As a result, the above pod passes admissions and is launched. However, if group ID range checking is desired, a custom SCC is the preferred solution. A custom SCC can be created such that minimum and maximum group IDs are defined, group ID range checking is enforced, and a group ID of <code class="literal">5555</code> is allowed.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							To use a custom SCC, you must first add it to the appropriate service account. For example, use the <code class="literal">default</code> service account in the given project unless another has been specified on the <code class="literal">Pod</code> specification.
						</p></div></div></section><section class="section" id="nfs-user-id_persistent-storage-nfs"><div class="titlepage"><div><div><h4 class="title">4.9.3.2. User IDs</h4></div></div></div><p>
						User IDs can be defined in the container image or in the <code class="literal">Pod</code> definition.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							It is generally preferable to use supplemental group IDs to gain access to persistent storage versus using user IDs.
						</p></div></div><p>
						In the example target NFS directory shown above, the container needs its UID set to <code class="literal">65534</code>, ignoring group IDs for the moment, so the following can be added to the <code class="literal">Pod</code> definition:
					</p><pre class="programlisting language-yaml">spec:
  containers: <span id="CO30-1"><!--Empty--></span><span class="callout">1</span>
  - name:
  ...
    securityContext:
      runAsUser: 65534 <span id="CO30-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO30-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Pods contain a <code class="literal">securityContext</code> definition specific to each container and a pod’s <code class="literal">securityContext</code> which applies to all containers defined in the pod.
							</div></dd><dt><a href="#CO30-2"><span class="callout">2</span></a> </dt><dd><div class="para">
								<code class="literal">65534</code> is the <code class="literal">nfsnobody</code> user.
							</div></dd></dl></div><p>
						Assuming that the project is <code class="literal">default</code> and the SCC is <code class="literal">restricted</code>, the user ID of <code class="literal">65534</code> as requested by the pod is not allowed. Therefore, the pod fails for the following reasons:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								It requests <code class="literal">65534</code> as its user ID.
							</li><li class="listitem">
								All SCCs available to the pod are examined to see which SCC allows a user ID of <code class="literal">65534</code>. While all policies of the SCCs are checked, the focus here is on user ID.
							</li><li class="listitem">
								Because all available SCCs use <code class="literal">MustRunAsRange</code> for their <code class="literal">runAsUser</code> strategy, UID range checking is required.
							</li><li class="listitem">
								<code class="literal">65534</code> is not included in the SCC or project’s user ID range.
							</li></ul></div><p>
						It is generally considered a good practice not to modify the predefined SCCs. The preferred way to fix this situation is to create a custom SCC A custom SCC can be created such that minimum and maximum user IDs are defined, UID range checking is still enforced, and the UID of <code class="literal">65534</code> is allowed.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							To use a custom SCC, you must first add it to the appropriate service account. For example, use the <code class="literal">default</code> service account in the given project unless another has been specified on the <code class="literal">Pod</code> specification.
						</p></div></div></section><section class="section" id="nfs-selinux_persistent-storage-nfs"><div class="titlepage"><div><div><h4 class="title">4.9.3.3. SELinux</h4></div></div></div><p>
						Red Hat Enterprise Linux (RHEL) and Red Hat Enterprise Linux CoreOS (RHCOS) systems are configured to use SELinux on remote NFS servers by default.
					</p><p>
						For non-RHEL and non-RHCOS systems, SELinux does not allow writing from a pod to a remote NFS server. The NFS volume mounts correctly but it is read-only. You will need to enable the correct SELinux permissions by using the following procedure.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								The <code class="literal">container-selinux</code> package must be installed. This package provides the <code class="literal">virt_use_nfs</code> SELinux boolean.
							</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Enable the <code class="literal">virt_use_nfs</code> boolean using the following command. The <code class="literal">-P</code> option makes this boolean persistent across reboots.
							</p><pre class="programlisting language-terminal"># setsebool -P virt_use_nfs 1</pre></li></ul></div></section><section class="section" id="export-settings"><div class="titlepage"><div><div><h4 class="title">4.9.3.4. Export settings</h4></div></div></div><p>
						To enable arbitrary container users to read and write the volume, each exported volume on the NFS server should conform to the following conditions:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Every export must be exported using the following format:
							</p><pre class="programlisting language-terminal">/&lt;example_fs&gt; *(rw,root_squash)</pre></li><li class="listitem"><p class="simpara">
								The firewall must be configured to allow traffic to the mount point.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p class="simpara">
										For NFSv4, configure the default port <code class="literal">2049</code> (<span class="strong strong"><strong>nfs</strong></span>).
									</p><div class="formalpara"><p class="title"><strong>NFSv4</strong></p><p>
											
<pre class="programlisting language-terminal"># iptables -I INPUT 1 -p tcp --dport 2049 -j ACCEPT</pre>

										</p></div></li><li class="listitem"><p class="simpara">
										For NFSv3, there are three ports to configure: <code class="literal">2049</code> (<span class="strong strong"><strong>nfs</strong></span>), <code class="literal">20048</code> (<span class="strong strong"><strong>mountd</strong></span>), and <code class="literal">111</code> (<span class="strong strong"><strong>portmapper</strong></span>).
									</p><div class="formalpara"><p class="title"><strong>NFSv3</strong></p><p>
											
<pre class="programlisting language-terminal"># iptables -I INPUT 1 -p tcp --dport 2049 -j ACCEPT</pre>

										</p></div><pre class="programlisting language-terminal"># iptables -I INPUT 1 -p tcp --dport 20048 -j ACCEPT</pre><pre class="programlisting language-terminal"># iptables -I INPUT 1 -p tcp --dport 111 -j ACCEPT</pre></li></ul></div></li><li class="listitem">
								The NFS export and directory must be set up so that they are accessible by the target pods. Either set the export to be owned by the container’s primary UID, or supply the pod group access using <code class="literal">supplementalGroups</code>, as shown in the group IDs above.
							</li></ul></div></section></section><section class="section" id="nfs-reclaiming-resources_persistent-storage-nfs"><div class="titlepage"><div><div><h3 class="title">4.9.4. Reclaiming resources</h3></div></div></div><p>
					NFS implements the OpenShift Container Platform <code class="literal">Recyclable</code> plugin interface. Automatic processes handle reclamation tasks based on policies set on each persistent volume.
				</p><p>
					By default, PVs are set to <code class="literal">Retain</code>.
				</p><p>
					Once claim to a PVC is deleted, and the PV is released, the PV object should not be reused. Instead, a new PV should be created with the same basic volume details as the original.
				</p><p>
					For example, the administrator creates a PV named <code class="literal">nfs1</code>:
				</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfs1
spec:
  capacity:
    storage: 1Mi
  accessModes:
    - ReadWriteMany
  nfs:
    server: 192.168.1.1
    path: "/"</pre><p>
					The user creates <code class="literal">PVC1</code>, which binds to <code class="literal">nfs1</code>. The user then deletes <code class="literal">PVC1</code>, releasing claim to <code class="literal">nfs1</code>. This results in <code class="literal">nfs1</code> being <code class="literal">Released</code>. If the administrator wants to make the same NFS share available, they should create a new PV with the same NFS server details, but a different PV name:
				</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: nfs2
spec:
  capacity:
    storage: 1Mi
  accessModes:
    - ReadWriteMany
  nfs:
    server: 192.168.1.1
    path: "/"</pre><p>
					Deleting the original PV and re-creating it with the same name is discouraged. Attempting to manually change the status of a PV from <code class="literal">Released</code> to <code class="literal">Available</code> causes errors and potential data loss.
				</p></section><section class="section" id="additional-configuration-and-troubleshooting"><div class="titlepage"><div><div><h3 class="title">4.9.5. Additional configuration and troubleshooting</h3></div></div></div><p>
					Depending on what version of NFS is being used and how it is configured, there may be additional configuration steps needed for proper export and security mapping. The following are some that may apply:
				</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"><!--Empty--></col><col style="width: 67%; " class="col_2"><!--Empty--></col></colgroup><tbody><tr><td align="left" valign="top"> <p>
									NFSv4 mount incorrectly shows all files with ownership of <code class="literal">nobody:nobody</code>
								</p>
								 </td><td align="left" valign="top"> <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											Could be attributed to the ID mapping settings, found in <code class="literal">/etc/idmapd.conf</code> on your NFS.
										</li><li class="listitem">
											See <a class="link" href="https://access.redhat.com/solutions/33455">this Red Hat Solution</a>.
										</li></ul></div>
								 </td></tr><tr><td align="left" valign="top"> <p>
									Disabling ID mapping on NFSv4
								</p>
								 </td><td align="left" valign="top"> <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
											On both the NFS client and server, run:
										</p><pre class="programlisting language-terminal"># echo 'Y' &gt; /sys/module/nfsd/parameters/nfs4_disable_idmapping</pre></li></ul></div>
								 </td></tr></tbody></table></div></section></section><section class="section" id="red-hat-openshift-data-foundation"><div class="titlepage"><div><div><h2 class="title">4.10. Red Hat OpenShift Data Foundation</h2></div></div></div><p>
				Red Hat OpenShift Data Foundation is a provider of agnostic persistent storage for OpenShift Container Platform supporting file, block, and object storage, either in-house or in hybrid clouds. As a Red Hat storage solution, Red Hat OpenShift Data Foundation is completely integrated with OpenShift Container Platform for deployment, management, and monitoring.
			</p><p>
				Red Hat OpenShift Data Foundation provides its own documentation library. The complete set of Red Hat OpenShift Data Foundation documentation is available at <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_openshift_data_foundation">https://access.redhat.com/documentation/en-us/red_hat_openshift_data_foundation</a>.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					OpenShift Data Foundation on top of Red Hat Hyperconverged Infrastructure (RHHI) for Virtualization, which uses hyperconverged nodes that host virtual machines installed with OpenShift Container Platform, is not a supported configuration. For more information about supported platforms, see the <a class="link" href="https://access.redhat.com/articles/4731161">Red Hat OpenShift Data Foundation Supportability and Interoperability Guide</a>.
				</p></div></div></section><section class="section" id="persistent-storage-using-vsphere"><div class="titlepage"><div><div><h2 class="title">4.11. Persistent storage using VMware vSphere volumes</h2></div></div></div><p>
				OpenShift Container Platform allows use of VMware vSphere’s Virtual Machine Disk (VMDK) volumes. You can provision your OpenShift Container Platform cluster with persistent storage using VMware vSphere. Some familiarity with Kubernetes and VMware vSphere is assumed.
			</p><p>
				VMware vSphere volumes can be provisioned dynamically. OpenShift Container Platform creates the disk in vSphere and attaches this disk to the correct image.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					OpenShift Container Platform provisions new volumes as independent persistent disks that can freely attach and detach the volume on any node in the cluster. Consequently, you cannot back up volumes that use snapshots, or restore volumes from snapshots. See <a class="link" href="https://docs.vmware.com/en/VMware-vSphere/6.7/com.vmware.vsphere.vm_admin.doc/GUID-53F65726-A23B-4CF0-A7D5-48E584B88613.html">Snapshot Limitations</a> for more information.
				</p></div></div><p>
				The Kubernetes persistent volume framework allows administrators to provision a cluster with persistent storage and gives users a way to request those resources without having any knowledge of the underlying infrastructure.
			</p><p>
				Persistent volumes are not bound to a single project or namespace; they can be shared across the OpenShift Container Platform cluster. Persistent volume claims are specific to a project or namespace and can be requested by users.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					OpenShift Container Platform defaults to using an in-tree (non-CSI) plugin to provision vSphere storage.
				</p><p>
					In future OpenShift Container Platform versions, volumes provisioned using existing in-tree plugins are planned for migration to their equivalent CSI driver. CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration</a>.
				</p><p>
					After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.
				</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://www.vmware.com/au/products/vsphere.html">VMware vSphere</a>
					</li></ul></div><section class="section" id="dynamically-provisioning-vmware-vsphere-volumes"><div class="titlepage"><div><div><h3 class="title">4.11.1. Dynamically provisioning VMware vSphere volumes</h3></div></div></div><p>
					Dynamically provisioning VMware vSphere volumes is the recommended method.
				</p></section><section class="section" id="prerequisites"><div class="titlepage"><div><div><h3 class="title">4.11.2. Prerequisites</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							An OpenShift Container Platform cluster installed on a VMware vSphere version that meets the requirements for the components that you use. See <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installing-a-cluster-on-vsphere-with-user-provisioned-infrastructure">Installing a cluster on vSphere</a> for information about vSphere version support.
						</li></ul></div><p>
					You can use either of the following procedures to dynamically provision these volumes using the default storage class.
				</p><section class="section" id="vsphere-dynamic-provisioning_persistent-storage-efs"><div class="titlepage"><div><div><h4 class="title">4.11.2.1. Dynamically provisioning VMware vSphere volumes using the UI</h4></div></div></div><p>
						OpenShift Container Platform installs a default storage class, named <code class="literal">thin</code>, that uses the <code class="literal">thin</code> disk format for provisioning volumes.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
								In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Persistent Volume Claims</strong></span>.
							</li><li class="listitem">
								In the persistent volume claims overview, click <span class="strong strong"><strong>Create Persistent Volume Claim</strong></span>.
							</li><li class="listitem"><p class="simpara">
								Define the required options on the resulting page.
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										Select the <code class="literal">thin</code> storage class.
									</li><li class="listitem">
										Enter a unique name for the storage claim.
									</li><li class="listitem">
										Select the access mode to determine the read and write access for the created storage claim.
									</li><li class="listitem">
										Define the size of the storage claim.
									</li></ol></div></li><li class="listitem">
								Click <span class="strong strong"><strong>Create</strong></span> to create the persistent volume claim and generate a persistent volume.
							</li></ol></div></section><section class="section" id="vsphere-dynamic-provisioning-cli_persistent-storage-efs"><div class="titlepage"><div><div><h4 class="title">4.11.2.2. Dynamically provisioning VMware vSphere volumes using the CLI</h4></div></div></div><p>
						OpenShift Container Platform installs a default StorageClass, named <code class="literal">thin</code>, that uses the <code class="literal">thin</code> disk format for provisioning volumes.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure (CLI)</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								You can define a VMware vSphere PersistentVolumeClaim by creating a file, <code class="literal">pvc.yaml</code>, with the following contents:
							</p><pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: pvc <span id="CO31-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
  - ReadWriteOnce <span id="CO31-2"><!--Empty--></span><span class="callout">2</span>
  resources:
    requests:
      storage: 1Gi <span id="CO31-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO31-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										A unique name that represents the persistent volume claim.
									</div></dd><dt><a href="#CO31-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The access mode of the persistent volume claim. With <code class="literal">ReadWriteOnce</code>, the volume can be mounted with read and write permissions by a single node.
									</div></dd><dt><a href="#CO31-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The size of the persistent volume claim.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create the <code class="literal">PersistentVolumeClaim</code> object from the file:
							</p><pre class="programlisting language-terminal">$ oc create -f pvc.yaml</pre></li></ol></div></section></section><section class="section" id="vsphere-static-provisioning_persistent-storage-efs"><div class="titlepage"><div><div><h3 class="title">4.11.3. Statically provisioning VMware vSphere volumes</h3></div></div></div><p>
					To statically provision VMware vSphere volumes you must create the virtual machine disks for reference by the persistent volume framework.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Storage must exist in the underlying infrastructure before it can be mounted as a volume in OpenShift Container Platform.
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create the virtual machine disks. Virtual machine disks (VMDKs) must be created manually before statically provisioning VMware vSphere volumes. Use either of the following methods:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									Create using <code class="literal">vmkfstools</code>. Access ESX through Secure Shell (SSH) and then use following command to create a VMDK volume:
								</p><pre class="programlisting language-terminal">$ vmkfstools -c &lt;size&gt; /vmfs/volumes/&lt;datastore-name&gt;/volumes/&lt;disk-name&gt;.vmdk</pre></li><li class="listitem"><p class="simpara">
									Create using <code class="literal">vmware-diskmanager</code>:
								</p><pre class="programlisting language-terminal">$ shell vmware-vdiskmanager -c -t 0 -s &lt;size&gt; -a lsilogic &lt;disk-name&gt;.vmdk</pre></li></ul></div></li><li class="listitem"><p class="simpara">
							Create a persistent volume that references the VMDKs. Create a file, <code class="literal">pv1.yaml</code>, with the <code class="literal">PersistentVolume</code> object definition:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv1 <span id="CO32-1"><!--Empty--></span><span class="callout">1</span>
spec:
  capacity:
    storage: 1Gi <span id="CO32-2"><!--Empty--></span><span class="callout">2</span>
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  vsphereVolume: <span id="CO32-3"><!--Empty--></span><span class="callout">3</span>
    volumePath: "[datastore1] volumes/myDisk"  <span id="CO32-4"><!--Empty--></span><span class="callout">4</span>
    fsType: ext4  <span id="CO32-5"><!--Empty--></span><span class="callout">5</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO32-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the volume. This name is how it is identified by persistent volume claims or pods.
								</div></dd><dt><a href="#CO32-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The amount of storage allocated to this volume.
								</div></dd><dt><a href="#CO32-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									The volume type used, with <code class="literal">vsphereVolume</code> for vSphere volumes. The label is used to mount a vSphere VMDK volume into pods. The contents of a volume are preserved when it is unmounted. The volume type supports VMFS and VSAN datastore.
								</div></dd><dt><a href="#CO32-4"><span class="callout">4</span></a> </dt><dd><div class="para">
									The existing VMDK volume to use. If you used <code class="literal">vmkfstools</code>, you must enclose the datastore name in square brackets, <code class="literal">[]</code>, in the volume definition, as shown previously.
								</div></dd><dt><a href="#CO32-5"><span class="callout">5</span></a> </dt><dd><div class="para">
									The file system type to mount. For example, ext4, xfs, or other file systems.
								</div></dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								Changing the value of the fsType parameter after the volume is formatted and provisioned can result in data loss and pod failure.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Create the <code class="literal">PersistentVolume</code> object from the file:
						</p><pre class="programlisting language-terminal">$ oc create -f pv1.yaml</pre></li><li class="listitem"><p class="simpara">
							Create a persistent volume claim that maps to the persistent volume you created in the previous step. Create a file, <code class="literal">pvc1.yaml</code>, with the <code class="literal">PersistentVolumeClaim</code> object definition:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc1 <span id="CO33-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
    - ReadWriteOnce <span id="CO33-2"><!--Empty--></span><span class="callout">2</span>
  resources:
   requests:
     storage: "1Gi" <span id="CO33-3"><!--Empty--></span><span class="callout">3</span>
  volumeName: pv1 <span id="CO33-4"><!--Empty--></span><span class="callout">4</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO33-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									A unique name that represents the persistent volume claim.
								</div></dd><dt><a href="#CO33-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The access mode of the persistent volume claim. With ReadWriteOnce, the volume can be mounted with read and write permissions by a single node.
								</div></dd><dt><a href="#CO33-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									The size of the persistent volume claim.
								</div></dd><dt><a href="#CO33-4"><span class="callout">4</span></a> </dt><dd><div class="para">
									The name of the existing persistent volume.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create the <code class="literal">PersistentVolumeClaim</code> object from the file:
						</p><pre class="programlisting language-terminal">$ oc create -f pvc1.yaml</pre></li></ol></div><section class="section" id="vsphere-formatting-volumes_persistent-storage-efs"><div class="titlepage"><div><div><h4 class="title">4.11.3.1. Formatting VMware vSphere volumes</h4></div></div></div><p>
						Before OpenShift Container Platform mounts the volume and passes it to a container, it checks that the volume contains a file system that is specified by the <code class="literal">fsType</code> parameter value in the <code class="literal">PersistentVolume</code> (PV) definition. If the device is not formatted with the file system, all data from the device is erased, and the device is automatically formatted with the specified file system.
					</p><p>
						Because OpenShift Container Platform formats them before the first use, you can use unformatted vSphere volumes as PVs.
					</p></section></section></section><section class="section" id="persistent-storage-using-local-storage"><div class="titlepage"><div><div><h2 class="title">4.12. Persistent storage using local storage</h2></div></div></div><section class="section" id="persistent-storage-using-local-volume"><div class="titlepage"><div><div><h3 class="title">4.12.1. Persistent storage using local volumes</h3></div></div></div><p>
					OpenShift Container Platform can be provisioned with persistent storage by using local volumes. Local persistent volumes allow you to access local storage devices, such as a disk or partition, by using the standard persistent volume claim interface.
				</p><p>
					Local volumes can be used without manually scheduling pods to nodes because the system is aware of the volume node constraints. However, local volumes are still subject to the availability of the underlying node and are not suitable for all applications.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Local volumes can only be used as a statically created persistent volume.
					</p></div></div><section class="section" id="local-storage-install_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.1. Installing the Local Storage Operator</h4></div></div></div><p>
						The Local Storage Operator is not installed in OpenShift Container Platform by default. Use the following procedure to install and configure this Operator to enable local volumes in your cluster.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Access to the OpenShift Container Platform web console or command-line interface (CLI).
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Create the <code class="literal">openshift-local-storage</code> project:
							</p><pre class="programlisting language-terminal">$ oc adm new-project openshift-local-storage</pre></li><li class="listitem"><p class="simpara">
								Optional: Allow local storage creation on infrastructure nodes.
							</p><p class="simpara">
								You might want to use the Local Storage Operator to create volumes on infrastructure nodes in support of components such as logging and monitoring.
							</p><p class="simpara">
								You must adjust the default node selector so that the Local Storage Operator includes the infrastructure nodes, and not just worker nodes.
							</p><p class="simpara">
								To block the Local Storage Operator from inheriting the cluster-wide default selector, enter the following command:
							</p><pre class="programlisting language-terminal">$ oc annotate namespace openshift-local-storage openshift.io/node-selector=''</pre></li><li class="listitem"><p class="simpara">
								Optional: Allow local storage to run on the management pool of CPUs in single-node deployment.
							</p><p class="simpara">
								Use the Local Storage Operator in single-node deployments and allow the use of CPUs that belong to the <code class="literal">management</code> pool. Perform this step on single-node installations that use management workload partitioning.
							</p><p class="simpara">
								To allow Local Storage Operator to run on the management CPU pool, run following commands:
							</p><pre class="programlisting language-terminal">$ oc annotate namespace openshift-local-storage workload.openshift.io/allowed='management'</pre></li></ol></div><div class="formalpara"><p class="title"><strong>From the UI</strong></p><p>
							To install the Local Storage Operator from the web console, follow these steps:
						</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Log in to the OpenShift Container Platform web console.
							</li><li class="listitem">
								Navigate to <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>OperatorHub</strong></span>.
							</li><li class="listitem">
								Type <span class="strong strong"><strong>Local Storage</strong></span> into the filter box to locate the Local Storage Operator.
							</li><li class="listitem">
								Click <span class="strong strong"><strong>Install</strong></span>.
							</li><li class="listitem">
								On the <span class="strong strong"><strong>Install Operator</strong></span> page, select <span class="strong strong"><strong>A specific namespace on the cluster</strong></span>. Select <span class="strong strong"><strong>openshift-local-storage</strong></span> from the drop-down menu.
							</li><li class="listitem">
								Adjust the values for <span class="strong strong"><strong>Update Channel</strong></span> and <span class="strong strong"><strong>Approval Strategy</strong></span> to the values that you want.
							</li><li class="listitem">
								Click <span class="strong strong"><strong>Install</strong></span>.
							</li></ol></div><p>
						Once finished, the Local Storage Operator will be listed in the <span class="strong strong"><strong>Installed Operators</strong></span> section of the web console.
					</p><div class="orderedlist"><p class="title"><strong>From the CLI</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Install the Local Storage Operator from the CLI.
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
										Create an object YAML file to define an Operator group and subscription for the Local Storage Operator, such as <code class="literal">openshift-local-storage.yaml</code>:
									</p><div class="formalpara"><p class="title"><strong>Example openshift-local-storage.yaml</strong></p><p>
											
<pre class="programlisting language-yaml">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: local-operator-group
  namespace: openshift-local-storage
spec:
  targetNamespaces:
    - openshift-local-storage
---
apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: local-storage-operator
  namespace: openshift-local-storage
spec:
  channel: stable
  installPlanApproval: Automatic <span id="CO34-1"><!--Empty--></span><span class="callout">1</span>
  name: local-storage-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</pre>

										</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO34-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												The user approval policy for an install plan.
											</div></dd></dl></div></li></ol></div></li><li class="listitem"><p class="simpara">
								Create the Local Storage Operator object by entering the following command:
							</p><pre class="programlisting language-terminal">$ oc apply -f openshift-local-storage.yaml</pre><p class="simpara">
								At this point, the Operator Lifecycle Manager (OLM) is now aware of the Local Storage Operator. A ClusterServiceVersion (CSV) for the Operator should appear in the target namespace, and APIs provided by the Operator should be available for creation.
							</p></li><li class="listitem"><p class="simpara">
								Verify local storage installation by checking that all pods and the Local Storage Operator have been created:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
										Check that all the required pods have been created:
									</p><pre class="programlisting language-terminal">$ oc -n openshift-local-storage get pods</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
											
<pre class="programlisting language-terminal">NAME                                      READY   STATUS    RESTARTS   AGE
local-storage-operator-746bf599c9-vlt5t   1/1     Running   0          19m</pre>

										</p></div></li><li class="listitem"><p class="simpara">
										Check the ClusterServiceVersion (CSV) YAML manifest to see that the Local Storage Operator is available in the <code class="literal">openshift-local-storage</code> project:
									</p><pre class="programlisting language-terminal">$ oc get csvs -n openshift-local-storage</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
											
<pre class="programlisting language-terminal">NAME                                         DISPLAY         VERSION               REPLACES   PHASE
local-storage-operator.4.2.26-202003230335   Local Storage   4.2.26-202003230335              Succeeded</pre>

										</p></div></li></ol></div></li></ol></div><p>
						After all checks have passed, the Local Storage Operator is installed successfully.
					</p></section><section class="section" id="local-volume-cr_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.2. Provisioning local volumes by using the Local Storage Operator</h4></div></div></div><p>
						Local volumes cannot be created by dynamic provisioning. Instead, persistent volumes can be created by the Local Storage Operator. The local volume provisioner looks for any file system or block volume devices at the paths specified in the defined resource.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								The Local Storage Operator is installed.
							</li><li class="listitem"><p class="simpara">
								You have a local disk that meets the following conditions:
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
										It is attached to a node.
									</li><li class="listitem">
										It is not mounted.
									</li><li class="listitem">
										It does not contain partitions.
									</li></ul></div></li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Create the local volume resource. This resource must define the nodes and paths to the local volumes.
							</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									Do not use different storage class names for the same device. Doing so will create multiple persistent volumes (PVs).
								</p></div></div><div class="formalpara"><p class="title"><strong>Example: Filesystem</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: "local.storage.openshift.io/v1"
kind: "LocalVolume"
metadata:
  name: "local-disks"
  namespace: "openshift-local-storage" <span id="CO35-1"><!--Empty--></span><span class="callout">1</span>
spec:
  nodeSelector: <span id="CO35-2"><!--Empty--></span><span class="callout">2</span>
    nodeSelectorTerms:
    - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - ip-10-0-140-183
          - ip-10-0-158-139
          - ip-10-0-164-33
  storageClassDevices:
    - storageClassName: "local-sc" <span id="CO35-3"><!--Empty--></span><span class="callout">3</span>
      volumeMode: Filesystem <span id="CO35-4"><!--Empty--></span><span class="callout">4</span>
      fsType: xfs <span id="CO35-5"><!--Empty--></span><span class="callout">5</span>
      devicePaths: <span id="CO35-6"><!--Empty--></span><span class="callout">6</span>
        - /path/to/device <span id="CO35-7"><!--Empty--></span><span class="callout">7</span></pre>

								</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO35-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The namespace where the Local Storage Operator is installed.
									</div></dd><dt><a href="#CO35-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										Optional: A node selector containing a list of nodes where the local storage volumes are attached. This example uses the node hostnames, obtained from <code class="literal">oc get node</code>. If a value is not defined, then the Local Storage Operator will attempt to find matching disks on all available nodes.
									</div></dd><dt><a href="#CO35-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The name of the storage class to use when creating persistent volume objects. The Local Storage Operator automatically creates the storage class if it does not exist. Be sure to use a storage class that uniquely identifies this set of local volumes.
									</div></dd><dt><a href="#CO35-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The volume mode, either <code class="literal">Filesystem</code> or <code class="literal">Block</code>, that defines the type of local volumes.
									</div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
											A raw block volume (<code class="literal">volumeMode: Block</code>) is not formatted with a file system. Use this mode only if any application running on the pod can use raw block devices.
										</p></div></div></dd><dt><a href="#CO35-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										The file system that is created when the local volume is mounted for the first time.
									</div></dd><dt><a href="#CO35-6"><span class="callout">6</span></a> </dt><dd><div class="para">
										The path containing a list of local storage devices to choose from.
									</div></dd><dt><a href="#CO35-7"><span class="callout">7</span></a> </dt><dd><div class="para">
										Replace this value with your actual local disks filepath to the <code class="literal">LocalVolume</code> resource <code class="literal">by-id</code>, such as <code class="literal">/dev/disk/by-id/wwn</code>. PVs are created for these local disks when the provisioner is deployed successfully.
									</div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
											If you are running OpenShift Container Platform with RHEL KVM, you must assign a serial number to your VM disk. Otherwise, the VM disk can not be identified after reboot. You can use the <code class="literal">virsh edit &lt;VM&gt;</code> command to add the <code class="literal">&lt;serial&gt;mydisk&lt;/serial&gt;</code> definition.
										</p></div></div></dd></dl></div><div class="formalpara"><p class="title"><strong>Example: Block</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: "local.storage.openshift.io/v1"
kind: "LocalVolume"
metadata:
  name: "local-disks"
  namespace: "openshift-local-storage" <span id="CO36-1"><!--Empty--></span><span class="callout">1</span>
spec:
  nodeSelector: <span id="CO36-2"><!--Empty--></span><span class="callout">2</span>
    nodeSelectorTerms:
    - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - ip-10-0-136-143
          - ip-10-0-140-255
          - ip-10-0-144-180
  storageClassDevices:
    - storageClassName: "localblock-sc" <span id="CO36-3"><!--Empty--></span><span class="callout">3</span>
      volumeMode: Block <span id="CO36-4"><!--Empty--></span><span class="callout">4</span>
      devicePaths: <span id="CO36-5"><!--Empty--></span><span class="callout">5</span>
        - /path/to/device <span id="CO36-6"><!--Empty--></span><span class="callout">6</span></pre>

								</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO36-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The namespace where the Local Storage Operator is installed.
									</div></dd><dt><a href="#CO36-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										Optional: A node selector containing a list of nodes where the local storage volumes are attached. This example uses the node hostnames, obtained from <code class="literal">oc get node</code>. If a value is not defined, then the Local Storage Operator will attempt to find matching disks on all available nodes.
									</div></dd><dt><a href="#CO36-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The name of the storage class to use when creating persistent volume objects.
									</div></dd><dt><a href="#CO36-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The volume mode, either <code class="literal">Filesystem</code> or <code class="literal">Block</code>, that defines the type of local volumes.
									</div></dd><dt><a href="#CO36-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										The path containing a list of local storage devices to choose from.
									</div></dd><dt><a href="#CO36-6"><span class="callout">6</span></a> </dt><dd><div class="para">
										Replace this value with your actual local disks filepath to the <code class="literal">LocalVolume</code> resource <code class="literal">by-id</code>, such as <code class="literal">dev/disk/by-id/wwn</code>. PVs are created for these local disks when the provisioner is deployed successfully.
									</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									If you are running OpenShift Container Platform with RHEL KVM, you must assign a serial number to your VM disk. Otherwise, the VM disk can not be identified after reboot. You can use the <code class="literal">virsh edit &lt;VM&gt;</code> command to add the <code class="literal">&lt;serial&gt;mydisk&lt;/serial&gt;</code> definition.
								</p></div></div></li><li class="listitem"><p class="simpara">
								Create the local volume resource in your OpenShift Container Platform cluster. Specify the file you just created:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;local-volume&gt;.yaml</pre></li><li class="listitem"><p class="simpara">
								Verify that the provisioner was created and that the corresponding daemon sets were created:
							</p><pre class="programlisting language-terminal">$ oc get all -n openshift-local-storage</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME                                          READY   STATUS    RESTARTS   AGE
pod/diskmaker-manager-9wzms                   1/1     Running   0          5m43s
pod/diskmaker-manager-jgvjp                   1/1     Running   0          5m43s
pod/diskmaker-manager-tbdsj                   1/1     Running   0          5m43s
pod/local-storage-operator-7db4bd9f79-t6k87   1/1     Running   0          14m

NAME                                     TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)             AGE
service/local-storage-operator-metrics   ClusterIP   172.30.135.36   &lt;none&gt;        8383/TCP,8686/TCP   14m

NAME                               DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE
daemonset.apps/diskmaker-manager   3         3         3       3            3           &lt;none&gt;          5m43s

NAME                                     READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/local-storage-operator   1/1     1            1           14m

NAME                                                DESIRED   CURRENT   READY   AGE
replicaset.apps/local-storage-operator-7db4bd9f79   1         1         1       14m</pre>

								</p></div><p class="simpara">
								Note the desired and current number of daemon set processes. A desired count of <code class="literal">0</code> indicates that the label selectors were invalid.
							</p></li><li class="listitem"><p class="simpara">
								Verify that the persistent volumes were created:
							</p><pre class="programlisting language-terminal">$ oc get pv</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME                CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE
local-pv-1cec77cf   100Gi      RWO            Delete           Available           local-sc                88m
local-pv-2ef7cd2a   100Gi      RWO            Delete           Available           local-sc                82m
local-pv-3fa1c73    100Gi      RWO            Delete           Available           local-sc                48m</pre>

								</p></div></li></ol></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Editing the <code class="literal">LocalVolume</code> object does not change the <code class="literal">fsType</code> or <code class="literal">volumeMode</code> of existing persistent volumes because doing so might result in a destructive operation.
						</p></div></div></section><section class="section" id="local-create-cr-manual_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.3. Provisioning local volumes without the Local Storage Operator</h4></div></div></div><p>
						Local volumes cannot be created by dynamic provisioning. Instead, persistent volumes can be created by defining the persistent volume (PV) in an object definition. The local volume provisioner looks for any file system or block volume devices at the paths specified in the defined resource.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Manual provisioning of PVs includes the risk of potential data leaks across PV reuse when PVCs are deleted. The Local Storage Operator is recommended for automating the life cycle of devices when provisioning local PVs.
						</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Local disks are attached to the OpenShift Container Platform nodes.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Define the PV. Create a file, such as <code class="literal">example-pv-filesystem.yaml</code> or <code class="literal">example-pv-block.yaml</code>, with the <code class="literal">PersistentVolume</code> object definition. This resource must define the nodes and paths to the local volumes.
							</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									Do not use different storage class names for the same device. Doing so will create multiple PVs.
								</p></div></div><div class="formalpara"><p class="title"><strong>example-pv-filesystem.yaml</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv-filesystem
spec:
  capacity:
    storage: 100Gi
  volumeMode: Filesystem <span id="CO37-1"><!--Empty--></span><span class="callout">1</span>
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage <span id="CO37-2"><!--Empty--></span><span class="callout">2</span>
  local:
    path: /dev/xvdf <span id="CO37-3"><!--Empty--></span><span class="callout">3</span>
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node</pre>

								</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO37-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The volume mode, either <code class="literal">Filesystem</code> or <code class="literal">Block</code>, that defines the type of PVs.
									</div></dd><dt><a href="#CO37-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The name of the storage class to use when creating PV resources. Use a storage class that uniquely identifies this set of PVs.
									</div></dd><dt><a href="#CO37-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The path containing a list of local storage devices to choose from, or a directory. You can only specify a directory with <code class="literal">Filesystem</code> <code class="literal">volumeMode</code>.
									</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									A raw block volume (<code class="literal">volumeMode: block</code>) is not formatted with a file system. Use this mode only if any application running on the pod can use raw block devices.
								</p></div></div><div class="formalpara"><p class="title"><strong>example-pv-block.yaml</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: example-pv-block
spec:
  capacity:
    storage: 100Gi
  volumeMode: Block <span id="CO38-1"><!--Empty--></span><span class="callout">1</span>
  accessModes:
  - ReadWriteOnce
  persistentVolumeReclaimPolicy: Delete
  storageClassName: local-storage <span id="CO38-2"><!--Empty--></span><span class="callout">2</span>
  local:
    path: /dev/xvdf <span id="CO38-3"><!--Empty--></span><span class="callout">3</span>
  nodeAffinity:
    required:
      nodeSelectorTerms:
      - matchExpressions:
        - key: kubernetes.io/hostname
          operator: In
          values:
          - example-node</pre>

								</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO38-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The volume mode, either <code class="literal">Filesystem</code> or <code class="literal">Block</code>, that defines the type of PVs.
									</div></dd><dt><a href="#CO38-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The name of the storage class to use when creating PV resources. Be sure to use a storage class that uniquely identifies this set of PVs.
									</div></dd><dt><a href="#CO38-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The path containing a list of local storage devices to choose from.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create the PV resource in your OpenShift Container Platform cluster. Specify the file you just created:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;example-pv&gt;.yaml</pre></li><li class="listitem"><p class="simpara">
								Verify that the local PV was created:
							</p><pre class="programlisting language-terminal">$ oc get pv</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME                    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                STORAGECLASS    REASON   AGE
example-pv-filesystem   100Gi      RWO            Delete           Available                        local-storage            3m47s
example-pv1             1Gi        RWO            Delete           Bound       local-storage/pvc1   local-storage            12h
example-pv2             1Gi        RWO            Delete           Bound       local-storage/pvc2   local-storage            12h
example-pv3             1Gi        RWO            Delete           Bound       local-storage/pvc3   local-storage            12h</pre>

								</p></div></li></ol></div></section><section class="section" id="create-local-pvc_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.4. Creating the local volume persistent volume claim</h4></div></div></div><p>
						Local volumes must be statically created as a persistent volume claim (PVC) to be accessed by the pod.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Persistent volumes have been created using the local volume provisioner.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Create the PVC using the corresponding storage class:
							</p><pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: local-pvc-name <span id="CO39-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
  - ReadWriteOnce
  volumeMode: Filesystem <span id="CO39-2"><!--Empty--></span><span class="callout">2</span>
  resources:
    requests:
      storage: 100Gi <span id="CO39-3"><!--Empty--></span><span class="callout">3</span>
  storageClassName: local-sc <span id="CO39-4"><!--Empty--></span><span class="callout">4</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO39-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Name of the PVC.
									</div></dd><dt><a href="#CO39-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The type of the PVC. Defaults to <code class="literal">Filesystem</code>.
									</div></dd><dt><a href="#CO39-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The amount of storage available to the PVC.
									</div></dd><dt><a href="#CO39-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										Name of the storage class required by the claim.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create the PVC in the OpenShift Container Platform cluster, specifying the file you just created:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;local-pvc&gt;.yaml</pre></li></ol></div></section><section class="section" id="local-pod_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.5. Attach the local claim</h4></div></div></div><p>
						After a local volume has been mapped to a persistent volume claim it can be specified inside of a resource.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								A persistent volume claim exists in the same namespace.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Include the defined claim in the resource spec. The following example declares the persistent volume claim inside a pod:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
spec:
  ...
  containers:
    volumeMounts:
    - name: local-disks <span id="CO40-1"><!--Empty--></span><span class="callout">1</span>
      mountPath: /data <span id="CO40-2"><!--Empty--></span><span class="callout">2</span>
  volumes:
  - name: localpvc
    persistentVolumeClaim:
      claimName: local-pvc-name <span id="CO40-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO40-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The name of the volume to mount.
									</div></dd><dt><a href="#CO40-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The path inside the pod where the volume is mounted. Do not mount to the container root, <code class="literal">/</code>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <code class="literal">/dev/pts</code> files. It is safe to mount the host by using <code class="literal">/host</code>.
									</div></dd><dt><a href="#CO40-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The name of the existing persistent volume claim to use.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create the resource in the OpenShift Container Platform cluster, specifying the file you just created:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;local-pod&gt;.yaml</pre></li></ol></div></section><section class="section" id="local-storage-discovery_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.6. Automating discovery and provisioning for local storage devices</h4></div></div></div><p>
						The Local Storage Operator automates local storage discovery and provisioning. With this feature, you can simplify installation when dynamic provisioning is not available during deployment, such as with bare metal, VMware, or AWS store instances with attached devices.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Automatic discovery and provisioning is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
						</p><p>
							However, automatic discovery and provisioning is fully supported when used to deploy Red Hat OpenShift Data Foundation on bare metal.
						</p><p>
							For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
						</p></div></div><p>
						Use the following procedure to automatically discover local devices, and to automatically provision local volumes for selected devices.
					</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
							Use the <code class="literal">LocalVolumeSet</code> object with caution. When you automatically provision persistent volumes (PVs) from local disks, the local PVs might claim all devices that match. If you are using a <code class="literal">LocalVolumeSet</code> object, make sure the Local Storage Operator is the only entity managing local devices on the node.
						</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								You have cluster administrator permissions.
							</li><li class="listitem">
								You have installed the Local Storage Operator.
							</li><li class="listitem">
								You have attached local disks to OpenShift Container Platform nodes.
							</li><li class="listitem">
								You have access to the OpenShift Container Platform web console and the <code class="literal">oc</code> command-line interface (CLI).
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								To enable automatic discovery of local devices from the web console:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										In the <span class="emphasis"><em>Administrator</em></span> perspective, navigate to <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>Installed Operators</strong></span> and click on the <span class="strong strong"><strong>Local Volume Discovery</strong></span> tab.
									</li><li class="listitem">
										Click <span class="strong strong"><strong>Create Local Volume Discovery</strong></span>.
									</li><li class="listitem"><p class="simpara">
										Select either <span class="strong strong"><strong>All nodes</strong></span> or <span class="strong strong"><strong>Select nodes</strong></span>, depending on whether you want to discover available disks on all or specific nodes.
									</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
											Only worker nodes are available, regardless of whether you filter using <span class="strong strong"><strong>All nodes</strong></span> or <span class="strong strong"><strong>Select nodes</strong></span>.
										</p></div></div></li><li class="listitem">
										Click <span class="strong strong"><strong>Create</strong></span>.
									</li></ol></div></li></ol></div><p>
						A local volume discovery instance named <code class="literal">auto-discover-devices</code> is displayed.
					</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								To display a continuous list of available devices on a node:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										Log in to the OpenShift Container Platform web console.
									</li><li class="listitem">
										Navigate to <span class="strong strong"><strong>Compute</strong></span> → <span class="strong strong"><strong>Nodes</strong></span>.
									</li><li class="listitem">
										Click the node name that you want to open. The "Node Details" page is displayed.
									</li><li class="listitem"><p class="simpara">
										Select the <span class="strong strong"><strong>Disks</strong></span> tab to display the list of the selected devices.
									</p><p class="simpara">
										The device list updates continuously as local disks are added or removed. You can filter the devices by name, status, type, model, capacity, and mode.
									</p></li></ol></div></li><li class="listitem"><p class="simpara">
								To automatically provision local volumes for the discovered devices from the web console:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										Navigate to <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>Installed Operators</strong></span> and select <span class="strong strong"><strong>Local Storage</strong></span> from the list of Operators.
									</li><li class="listitem">
										Select <span class="strong strong"><strong>Local Volume Set</strong></span> → <span class="strong strong"><strong>Create Local Volume Set</strong></span>.
									</li><li class="listitem">
										Enter a volume set name and a storage class name.
									</li><li class="listitem"><p class="simpara">
										Choose <span class="strong strong"><strong>All nodes</strong></span> or <span class="strong strong"><strong>Select nodes</strong></span> to apply filters accordingly.
									</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
											Only worker nodes are available, regardless of whether you filter using <span class="strong strong"><strong>All nodes</strong></span> or <span class="strong strong"><strong>Select nodes</strong></span>.
										</p></div></div></li><li class="listitem"><p class="simpara">
										Select the disk type, mode, size, and limit you want to apply to the local volume set, and click <span class="strong strong"><strong>Create</strong></span>.
									</p><p class="simpara">
										A message displays after several minutes, indicating that the "Operator reconciled successfully."
									</p></li></ol></div></li></ol></div><div class="orderedlist"><ol class="orderedlist" start="3" type="1"><li class="listitem"><p class="simpara">
								Alternatively, to provision local volumes for the discovered devices from the CLI:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
										Create an object YAML file to define the local volume set, such as <code class="literal">local-volume-set.yaml</code>, as shown in the following example:
									</p><pre class="programlisting language-yaml">apiVersion: local.storage.openshift.io/v1alpha1
kind: LocalVolumeSet
metadata:
  name: example-autodetect
spec:
  nodeSelector:
    nodeSelectorTerms:
      - matchExpressions:
          - key: kubernetes.io/hostname
            operator: In
            values:
              - worker-0
              - worker-1
  storageClassName: example-storageclass <span id="CO41-1"><!--Empty--></span><span class="callout">1</span>
  volumeMode: Filesystem
  fsType: ext4
  maxDeviceCount: 10
  deviceInclusionSpec:
    deviceTypes: <span id="CO41-2"><!--Empty--></span><span class="callout">2</span>
      - disk
      - part
    deviceMechanicalProperties:
      - NonRotational
    minSize: 10G
    maxSize: 100G
    models:
      - SAMSUNG
      - Crucial_CT525MX3
    vendors:
      - ATA
      - ST2000LM</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO41-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												Determines the storage class that is created for persistent volumes that are provisioned from discovered devices. The Local Storage Operator automatically creates the storage class if it does not exist. Be sure to use a storage class that uniquely identifies this set of local volumes.
											</div></dd><dt><a href="#CO41-2"><span class="callout">2</span></a> </dt><dd><div class="para">
												When using the local volume set feature, the Local Storage Operator does not support the use of logical volume management (LVM) devices.
											</div></dd></dl></div></li><li class="listitem"><p class="simpara">
										Create the local volume set object:
									</p><pre class="programlisting language-terminal">$ oc apply -f local-volume-set.yaml</pre></li><li class="listitem"><p class="simpara">
										Verify that the local persistent volumes were dynamically provisioned based on the storage class:
									</p><pre class="programlisting language-terminal">$ oc get pv</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
											
<pre class="programlisting language-terminal">NAME                CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS           REASON   AGE
local-pv-1cec77cf   100Gi      RWO            Delete           Available           example-storageclass            88m
local-pv-2ef7cd2a   100Gi      RWO            Delete           Available           example-storageclass            82m
local-pv-3fa1c73    100Gi      RWO            Delete           Available           example-storageclass            48m</pre>

										</p></div></li></ol></div></li></ol></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							Results are deleted after they are removed from the node. Symlinks must be manually removed.
						</p></div></div></section><section class="section" id="local-tolerations_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.7. Using tolerations with Local Storage Operator pods</h4></div></div></div><p>
						Taints can be applied to nodes to prevent them from running general workloads. To allow the Local Storage Operator to use tainted nodes, you must add tolerations to the <code class="literal">Pod</code> or <code class="literal">DaemonSet</code> definition. This allows the created resources to run on these tainted nodes.
					</p><p>
						You apply tolerations to the Local Storage Operator pod through the <code class="literal">LocalVolume</code> resource and apply taints to a node through the node specification. A taint on a node instructs the node to repel all pods that do not tolerate the taint. Using a specific taint that is not on other pods ensures that the Local Storage Operator pod can also run on that node.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Taints and tolerations consist of a key, value, and effect. As an argument, it is expressed as <code class="literal">key=value:effect</code>. An operator allows you to leave one of these parameters empty.
						</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								The Local Storage Operator is installed.
							</li><li class="listitem">
								Local disks are attached to OpenShift Container Platform nodes with a taint.
							</li><li class="listitem">
								Tainted nodes are expected to provision local storage.
							</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
							To configure local volumes for scheduling on tainted nodes:
						</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Modify the YAML file that defines the <code class="literal">Pod</code> and add the <code class="literal">LocalVolume</code> spec, as shown in the following example:
							</p><pre class="programlisting language-yaml">  apiVersion: "local.storage.openshift.io/v1"
  kind: "LocalVolume"
  metadata:
    name: "local-disks"
    namespace: "openshift-local-storage"
  spec:
    tolerations:
      - key: localstorage <span id="CO42-1"><!--Empty--></span><span class="callout">1</span>
        operator: Equal <span id="CO42-2"><!--Empty--></span><span class="callout">2</span>
        value: "localstorage" <span id="CO42-3"><!--Empty--></span><span class="callout">3</span>
    storageClassDevices:
        - storageClassName: "localblock-sc"
          volumeMode: Block <span id="CO42-4"><!--Empty--></span><span class="callout">4</span>
          devicePaths: <span id="CO42-5"><!--Empty--></span><span class="callout">5</span>
            - /dev/xvdg</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO42-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the key that you added to the node.
									</div></dd><dt><a href="#CO42-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										Specify the <code class="literal">Equal</code> operator to require the <code class="literal">key</code>/<code class="literal">value</code> parameters to match. If operator is <code class="literal">Exists</code>, the system checks that the key exists and ignores the value. If operator is <code class="literal">Equal</code>, then the key and value must match.
									</div></dd><dt><a href="#CO42-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										Specify the value <code class="literal">local</code> of the tainted node.
									</div></dd><dt><a href="#CO42-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The volume mode, either <code class="literal">Filesystem</code> or <code class="literal">Block</code>, defining the type of the local volumes.
									</div></dd><dt><a href="#CO42-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										The path containing a list of local storage devices to choose from.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Optional: To create local persistent volumes on only tainted nodes, modify the YAML file and add the <code class="literal">LocalVolume</code> spec, as shown in the following example:
							</p><pre class="programlisting language-yaml">spec:
  tolerations:
    - key: node-role.kubernetes.io/master
      operator: Exists</pre></li></ol></div><p>
						The defined tolerations will be passed to the resulting daemon sets, allowing the diskmaker and provisioner pods to be created for nodes that contain the specified taints.
					</p></section><section class="section" id="local-storage-metrics_persistent-storage-local"><div class="titlepage"><div><div><h4 class="title">4.12.1.8. Local Storage Operator Metrics</h4></div></div></div><p>
						OpenShift Container Platform provides the following metrics for the Local Storage Operator:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								<code class="literal">lso_discovery_disk_count</code>: total number of discovered devices on each node
							</li><li class="listitem">
								<code class="literal">lso_lvset_provisioned_PV_count</code>: total number of PVs created by <code class="literal">LocalVolumeSet</code> objects
							</li><li class="listitem">
								<code class="literal">lso_lvset_unmatched_disk_count</code>: total number of disks that Local Storage Operator did not select for provisioning because of mismatching criteria
							</li><li class="listitem">
								<code class="literal">lso_lvset_orphaned_symlink_count</code>: number of devices with PVs that no longer match <code class="literal">LocalVolumeSet</code> object criteria
							</li><li class="listitem">
								<code class="literal">lso_lv_orphaned_symlink_count</code>: number of devices with PVs that no longer match <code class="literal">LocalVolume</code> object criteria
							</li><li class="listitem">
								<code class="literal">lso_lv_provisioned_PV_count</code>: total number of provisioned PVs for <code class="literal">LocalVolume</code>
							</li></ul></div><p>
						To use these metrics, be sure to:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Enable support for monitoring when installing the Local Storage Operator.
							</li><li class="listitem">
								When upgrading to OpenShift Container Platform 4.9 or later, enable metric support manually by adding the <code class="literal">operator-metering=true</code> label to the namespace.
							</li></ul></div><p>
						For more information about metrics, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/monitoring/#managing-metric">Managing metrics</a>.
					</p></section><section class="section" id="deleting-the-local-storage-operator-resources"><div class="titlepage"><div><div><h4 class="title">4.12.1.9. Deleting the Local Storage Operator resources</h4></div></div></div><section class="section" id="local-removing-device_persistent-storage-local"><div class="titlepage"><div><div><h5 class="title">4.12.1.9.1. Removing a local volume or local volume set</h5></div></div></div><p>
							Occasionally, local volumes and local volume sets must be deleted. While removing the entry in the resource and deleting the persistent volume is typically enough, if you want to reuse the same device path or have it managed by a different storage class, then additional steps are needed.
						</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								The following procedure outlines an example for removing a local volume. The same procedure can also be used to remove symlinks for a local volume set custom resource.
							</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									The persistent volume must be in a <code class="literal">Released</code> or <code class="literal">Available</code> state.
								</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
										Deleting a persistent volume that is still in use can result in data loss or corruption.
									</p></div></div></li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Edit the previously created local volume to remove any unwanted disks.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
											Edit the cluster resource:
										</p><pre class="programlisting language-terminal">$ oc edit localvolume &lt;name&gt; -n openshift-local-storage</pre></li><li class="listitem">
											Navigate to the lines under <code class="literal">devicePaths</code>, and delete any representing unwanted disks.
										</li></ol></div></li><li class="listitem"><p class="simpara">
									Delete any persistent volumes created.
								</p><pre class="programlisting language-terminal">$ oc delete pv &lt;pv-name&gt;</pre></li><li class="listitem"><p class="simpara">
									Delete any symlinks on the node.
								</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
										The following step involves accessing a node as the root user. Modifying the state of the node beyond the steps in this procedure could result in cluster instability.
									</p></div></div><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
											Create a debug pod on the node:
										</p><pre class="programlisting language-terminal">$ oc debug node/&lt;node-name&gt;</pre></li><li class="listitem"><p class="simpara">
											Change your root directory to <code class="literal">/host</code>:
										</p><pre class="programlisting language-terminal">$ chroot /host</pre></li><li class="listitem"><p class="simpara">
											Navigate to the directory containing the local volume symlinks.
										</p><pre class="programlisting language-terminal">$ cd /mnt/openshift-local-storage/&lt;sc-name&gt; <span id="CO43-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO43-1"><span class="callout">1</span></a> </dt><dd><div class="para">
													The name of the storage class used to create the local volumes.
												</div></dd></dl></div></li><li class="listitem"><p class="simpara">
											Delete the symlink belonging to the removed device.
										</p><pre class="programlisting language-terminal">$ rm &lt;symlink&gt;</pre></li></ol></div></li></ol></div></section><section class="section" id="local-storage-uninstall_persistent-storage-local"><div class="titlepage"><div><div><h5 class="title">4.12.1.9.2. Uninstalling the Local Storage Operator</h5></div></div></div><p>
							To uninstall the Local Storage Operator, you must remove the Operator and all created resources in the <code class="literal">openshift-local-storage</code> project.
						</p><div class="admonition warning"><div class="admonition_header">Warning</div><div><p>
								Uninstalling the Local Storage Operator while local storage PVs are still in use is not recommended. While the PVs will remain after the Operator’s removal, there might be indeterminate behavior if the Operator is uninstalled and reinstalled without removing the PVs and local storage resources.
							</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									Access to the OpenShift Container Platform web console.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Delete any local volume resources installed in the project, such as <code class="literal">localvolume</code>, <code class="literal">localvolumeset</code>, and <code class="literal">localvolumediscovery</code>:
								</p><pre class="programlisting language-terminal">$ oc delete localvolume --all --all-namespaces
$ oc delete localvolumeset --all --all-namespaces
$ oc delete localvolumediscovery --all --all-namespaces</pre></li><li class="listitem"><p class="simpara">
									Uninstall the Local Storage Operator from the web console.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											Log in to the OpenShift Container Platform web console.
										</li><li class="listitem">
											Navigate to <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>Installed Operators</strong></span>.
										</li><li class="listitem">
											Type <span class="strong strong"><strong>Local Storage</strong></span> into the filter box to locate the Local Storage Operator.
										</li><li class="listitem">
											Click the Options menu 
											<span class="inlinemediaobject"><img src="https://access.redhat.com/webassets/avalon/d/OpenShift_Container_Platform-4.13-Storage-en-US/images/f468284ec3cc9bf27e6bd2c83849ca50/kebab.png" alt="kebab"/></span>
											 at the end of the Local Storage Operator.
										</li><li class="listitem">
											Click <span class="strong strong"><strong>Uninstall Operator</strong></span>.
										</li><li class="listitem">
											Click <span class="strong strong"><strong>Remove</strong></span> in the window that appears.
										</li></ol></div></li><li class="listitem"><p class="simpara">
									The PVs created by the Local Storage Operator will remain in the cluster until deleted. After these volumes are no longer in use, delete them by running the following command:
								</p><pre class="programlisting language-terminal">$ oc delete pv &lt;pv-name&gt;</pre></li><li class="listitem"><p class="simpara">
									Delete the <code class="literal">openshift-local-storage</code> project:
								</p><pre class="programlisting language-terminal">$ oc delete project openshift-local-storage</pre></li></ol></div></section></section></section><section class="section" id="persistent-storage-using-hostpath"><div class="titlepage"><div><div><h3 class="title">4.12.2. Persistent storage using hostPath</h3></div></div></div><p>
					A hostPath volume in an OpenShift Container Platform cluster mounts a file or directory from the host node’s filesystem into your pod. Most pods will not need a hostPath volume, but it does offer a quick option for testing should an application require it.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						The cluster administrator must configure pods to run as privileged. This grants access to pods in the same node.
					</p></div></div><section class="section" id="persistent-storage-hostpath-about_persistent-storage-hostpath"><div class="titlepage"><div><div><h4 class="title">4.12.2.1. Overview</h4></div></div></div><p>
						OpenShift Container Platform supports hostPath mounting for development and testing on a single-node cluster.
					</p><p>
						In a production cluster, you would not use hostPath. Instead, a cluster administrator would provision a network resource, such as a GCE Persistent Disk volume, an NFS share, or an Amazon EBS volume. Network resources support the use of storage classes to set up dynamic provisioning.
					</p><p>
						A hostPath volume must be provisioned statically.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Do not mount to the container root, <code class="literal">/</code>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged. It is safe to mount the host by using <code class="literal">/host</code>. The following example shows the <code class="literal">/</code> directory from the host being mounted into the container at <code class="literal">/host</code>.
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: test-host-mount
spec:
  containers:
  - image: registry.access.redhat.com/ubi9/ubi
    name: test-container
    command: ['sh', '-c', 'sleep 3600']
    volumeMounts:
    - mountPath: /host
      name: host-slash
  volumes:
   - name: host-slash
     hostPath:
       path: /
       type: ''</pre></div></div></section><section class="section" id="hostpath-static-provisioning_persistent-storage-hostpath"><div class="titlepage"><div><div><h4 class="title">4.12.2.2. Statically provisioning hostPath volumes</h4></div></div></div><p>
						A pod that uses a hostPath volume must be referenced by manual (static) provisioning.
					</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Define the persistent volume (PV). Create a file, <code class="literal">pv.yaml</code>, with the <code class="literal">PersistentVolume</code> object definition:
							</p><pre class="programlisting language-yaml">  apiVersion: v1
  kind: PersistentVolume
  metadata:
    name: task-pv-volume <span id="CO44-1"><!--Empty--></span><span class="callout">1</span>
    labels:
      type: local
  spec:
    storageClassName: manual <span id="CO44-2"><!--Empty--></span><span class="callout">2</span>
    capacity:
      storage: 5Gi
    accessModes:
      - ReadWriteOnce <span id="CO44-3"><!--Empty--></span><span class="callout">3</span>
    persistentVolumeReclaimPolicy: Retain
    hostPath:
      path: "/mnt/data" <span id="CO44-4"><!--Empty--></span><span class="callout">4</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO44-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The name of the volume. This name is how it is identified by persistent volume claims or pods.
									</div></dd><dt><a href="#CO44-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										Used to bind persistent volume claim requests to this persistent volume.
									</div></dd><dt><a href="#CO44-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The volume can be mounted as <code class="literal">read-write</code> by a single node.
									</div></dd><dt><a href="#CO44-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The configuration file specifies that the volume is at <code class="literal">/mnt/data</code> on the cluster’s node. Do not mount to the container root, <code class="literal">/</code>, or any path that is the same in the host and the container. This can corrupt your host system. It is safe to mount the host by using <code class="literal">/host</code>.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create the PV from the file:
							</p><pre class="programlisting language-terminal">$ oc create -f pv.yaml</pre></li><li class="listitem"><p class="simpara">
								Define the persistent volume claim (PVC). Create a file, <code class="literal">pvc.yaml</code>, with the <code class="literal">PersistentVolumeClaim</code> object definition:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: task-pvc-volume
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  storageClassName: manual</pre></li><li class="listitem"><p class="simpara">
								Create the PVC from the file:
							</p><pre class="programlisting language-terminal">$ oc create -f pvc.yaml</pre></li></ol></div></section><section class="section" id="persistent-storage-hostpath-pod_persistent-storage-hostpath"><div class="titlepage"><div><div><h4 class="title">4.12.2.3. Mounting the hostPath share in a privileged pod</h4></div></div></div><p>
						After the persistent volume claim has been created, it can be used inside by an application. The following example demonstrates mounting this share inside of a pod.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								A persistent volume claim exists that is mapped to the underlying hostPath share.
							</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Create a privileged pod that mounts the existing persistent volume claim:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: pod-name <span id="CO45-1"><!--Empty--></span><span class="callout">1</span>
spec:
  containers:
    ...
    securityContext:
      privileged: true <span id="CO45-2"><!--Empty--></span><span class="callout">2</span>
    volumeMounts:
    - mountPath: /data <span id="CO45-3"><!--Empty--></span><span class="callout">3</span>
      name: hostpath-privileged
  ...
  securityContext: {}
  volumes:
    - name: hostpath-privileged
      persistentVolumeClaim:
        claimName: task-pvc-volume <span id="CO45-4"><!--Empty--></span><span class="callout">4</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO45-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										The name of the pod.
									</div></dd><dt><a href="#CO45-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										The pod must run as privileged to access the node’s storage.
									</div></dd><dt><a href="#CO45-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										The path to mount the host path share inside the privileged pod. Do not mount to the container root, <code class="literal">/</code>, or any path that is the same in the host and the container. This can corrupt your host system if the container is sufficiently privileged, such as the host <code class="literal">/dev/pts</code> files. It is safe to mount the host by using <code class="literal">/host</code>.
									</div></dd><dt><a href="#CO45-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										The name of the <code class="literal">PersistentVolumeClaim</code> object that has been previously created.
									</div></dd></dl></div></li></ul></div></section></section><section class="section" id="persistent-storage-using-lvms"><div class="titlepage"><div><div><h3 class="title">4.12.3. Persistent storage using logical volume manager storage</h3></div></div></div><p>
					Logical volume manager storage (LVM Storage) uses the TopoLVM CSI driver to dynamically provision local storage on single-node OpenShift clusters.
				</p><p>
					LVM Storage creates thin-provisioned volumes using Logical Volume Manager and provides dynamic provisioning of block storage on a limited resources single-node OpenShift cluster.
				</p><section class="section" id="lvms-preface-sno-ran_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.1. Deploying LVM Storage on single-node OpenShift clusters</h4></div></div></div><p>
						You can deploy LVM Storage on a single-node OpenShift bare-metal or user-provisioned infrastructure cluster and configure it to dynamically provision storage for your workloads.
					</p><p>
						LVM Storage creates a volume group using all the available unused disks and creates a single thin pool with a size of 90% of the volume group. The remaining 10% of the volume group is left free to enable data recovery by expanding the thin pool when required. You might need to manually perform such recovery.
					</p><p>
						You can use persistent volume claims (PVCs) and volume snapshots provisioned by LVM Storage to request storage and create volume snapshots.
					</p><p>
						LVM Storage configures a default overprovisioning limit of 10 to take advantage of the thin-provisioning feature. The total size of the volumes and volume snapshots that can be created on the single-node OpenShift clusters is 10 times the size of the thin pool.
					</p><p>
						You can deploy LVM Storage on single-node OpenShift clusters using one of the following:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Red Hat Advanced Cluster Management (RHACM)
							</li><li class="listitem">
								OpenShift Container Platform Web Console
							</li></ul></div><section class="section" id="lvms-deployment-requirements-for-sno-ran_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.1. Requirements</h5></div></div></div><p>
							Before you begin deploying LVM Storage on single-node OpenShift clusters, ensure that the following requirements are met:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									You have installed Red Hat Advanced Cluster Management (RHACM) on an OpenShift Container Platform cluster.
								</li><li class="listitem">
									Every managed single-node OpenShift cluster has dedicated disks that are used to provision storage.
								</li></ul></div><p>
							Before you deploy LVM Storage on single-node OpenShift clusters, be aware of the following limitations:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									You can only create a single instance of the <code class="literal">LVMCluster</code> custom resource (CR) on an OpenShift Container Platform cluster.
								</li><li class="listitem">
									When a device becomes part of the <code class="literal">LVMCluster</code> CR, it cannot be removed.
								</li></ul></div></section><section class="section" id="lvms-deployment-limitations-for-sno-ran_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.2. Limitations</h5></div></div></div><p>
							For deploying single-node OpenShift, LVM Storage has the following limitations:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									The total storage size is limited by the size of the underlying Logical Volume Manager (LVM) thin pool and the overprovisioning factor.
								</li><li class="listitem"><p class="simpara">
									The size of the logical volume depends on the size of the Physical Extent (PE) and the Logical Extent (LE).
								</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
											It is possible to define the size of PE and LE during the physical and logical device creation.
										</li><li class="listitem">
											The default PE and LE size is 4 MB.
										</li><li class="listitem">
											If the size of the PE is increased, the maximum size of the LVM is determined by the kernel limits and your disk space.
										</li></ul></div></li></ul></div><div class="table" id="idm140001851543968"><p class="title"><strong>Table 4.1. Size limits for different architectures using the default PE and LE size</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 20%; " class="col_1"><!--Empty--></col><col style="width: 20%; " class="col_2"><!--Empty--></col><col style="width: 20%; " class="col_3"><!--Empty--></col><col style="width: 20%; " class="col_4"><!--Empty--></col><col style="width: 20%; " class="col_5"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001891684992" scope="col">Architecture</th><th align="left" valign="top" id="idm140001891683904" scope="col">RHEL 5</th><th align="left" valign="top" id="idm140001891682816" scope="col">RHEL 6</th><th align="left" valign="top" id="idm140001856908544" scope="col">RHEL 7</th><th align="left" valign="top" id="idm140001856907456" scope="col">RHEL 8</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001891684992"> <p>
											32-bit
										</p>
										 </td><td align="left" valign="top" headers="idm140001891683904"> <p>
											16 TB
										</p>
										 </td><td align="left" valign="top" headers="idm140001891682816"> <p>
											16 TB
										</p>
										 </td><td align="left" valign="top" headers="idm140001856908544"> <p>
											-
										</p>
										 </td><td align="left" valign="top" headers="idm140001856907456"> <p>
											-
										</p>
										 </td></tr><tr><td align="left" valign="top" headers="idm140001891684992"> <p>
											64-bit
										</p>
										 </td><td align="left" valign="top" headers="idm140001891683904"> <p>
											8 EB <sup>[1]</sup>
										</p>
										 </td><td align="left" valign="top" headers="idm140001891682816"> <p>
											8 EB <sup>[1]</sup>
										</p>
										 <p>
											100 TB <sup>[2]</sup>
										</p>
										 </td><td align="left" valign="top" headers="idm140001856908544"> <p>
											8 EB <sup>[1]</sup>
										</p>
										 <p>
											500 TB <sup>[2]</sup>
										</p>
										 </td><td align="left" valign="top" headers="idm140001856907456"> <p>
											8 EB
										</p>
										 </td></tr></tbody></table></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Theoretical size.
								</li><li class="listitem">
									Tested size.
								</li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html/install/installing#installing-while-connected-online">Red Hat Advanced Cluster Management for Kubernetes: Installing while connected online</a>
								</li></ul></div></section><section class="section" id="install-lvms-operator-cli_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.3. Installing LVM Storage with the CLI</h5></div></div></div><p>
							As a cluster administrator, you can install Logical volume manager storage (LVM Storage) by using the CLI.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You have installed the OpenShift CLI (<code class="literal">oc</code>).
								</li><li class="listitem">
									You have logged in as a user with <code class="literal">cluster-admin</code> privileges.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Create a namespace for the LVM Storage Operator.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
											Save the following YAML in the <code class="literal">lvms-namespace.yaml</code> file:
										</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Namespace
metadata:
  labels:
    openshift.io/cluster-monitoring: "true"
    pod-security.kubernetes.io/enforce: privileged
    pod-security.kubernetes.io/audit: privileged
    pod-security.kubernetes.io/warn: privileged
  name: openshift-storage</pre></li><li class="listitem"><p class="simpara">
											Create the <code class="literal">Namespace</code> CR:
										</p><pre class="programlisting language-terminal">$ oc create -f lvms-namespace.yaml</pre></li></ol></div></li><li class="listitem"><p class="simpara">
									Create an Operator group for the LVM Storage Operator.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
											Save the following YAML in the <code class="literal">lvms-operatorgroup.yaml</code> file:
										</p><pre class="programlisting language-yaml">apiVersion: operators.coreos.com/v1
kind: OperatorGroup
metadata:
  name: openshift-storage-operatorgroup
  namespace: openshift-storage
spec:
  targetNamespaces:
  - openshift-storage</pre></li><li class="listitem"><p class="simpara">
											Create the <code class="literal">OperatorGroup</code> CR:
										</p><pre class="programlisting language-terminal">$ oc create -f lvms-operatorgroup.yaml</pre></li></ol></div></li><li class="listitem"><p class="simpara">
									Subscribe to the LVM Storage Operator.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
											Save the following YAML in the <code class="literal">lvms-sub.yaml</code> file:
										</p><pre class="programlisting language-yaml">apiVersion: operators.coreos.com/v1alpha1
kind: Subscription
metadata:
  name: lvms
  namespace: openshift-storage
spec:
  installPlanApproval: Automatic
  name: lvms-operator
  source: redhat-operators
  sourceNamespace: openshift-marketplace</pre></li><li class="listitem"><p class="simpara">
											Create the <code class="literal">Subscription</code> CR:
										</p><pre class="programlisting language-terminal">$ oc create -f lvms-sub.yaml</pre></li></ol></div></li><li class="listitem"><p class="simpara">
									Create the <code class="literal">LVMCluster</code> resource:
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
											Save the following YAML in the <code class="literal">lvmcluster.yaml</code> file:
										</p><pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
 name: my-lvmcluster
 namespace: openshift-storage
spec:
 storage:
   deviceClasses:
   - name: vg1
     deviceSelector:
       paths:
       - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
       - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
     thinPoolConfig:
       name: thin-pool-1
       sizePercent: 90
       overprovisionRatio: 10
     nodeSelector:
       nodeSelectorTerms:
       - matchExpressions:
         - key: app
           operator: In
           values:
           - test1</pre></li><li class="listitem"><p class="simpara">
											Create the <code class="literal">LVMCluster</code> CR:
										</p><pre class="programlisting language-yaml">$ oc create -f lvmcluster.yaml</pre></li></ol></div></li><li class="listitem"><p class="simpara">
									To verify that the Operator is installed, enter the following command:
								</p><pre class="programlisting language-terminal">$ oc get csv -n openshift-storage -o custom-columns=Name:.metadata.name,Phase:.status.phase</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
										
<pre class="programlisting language-terminal">Name                         Phase
4.13.0-202301261535          Succeeded</pre>

									</p></div></li></ol></div></section><section class="section" id="lvms-installing-lvms-with-web-console_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.4. Installing LVM Storage with the web console</h5></div></div></div><p>
							You can install Logical volume manager storage (LVM Storage) by using the Red Hat OpenShift Container Platform OperatorHub.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You have access to the single-node OpenShift cluster.
								</li><li class="listitem">
									You are using an account with the <code class="literal">cluster-admin</code> and Operator installation permissions.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Log in to the OpenShift Container Platform Web Console.
								</li><li class="listitem">
									Click <span class="strong strong"><strong>Operators → OperatorHub</strong></span>.
								</li><li class="listitem">
									Scroll or type <code class="literal">LVM Storage</code> into the <span class="strong strong"><strong>Filter by keyword</strong></span> box to find LVM Storage.
								</li><li class="listitem">
									Click <span class="strong strong"><strong>Install</strong></span>.
								</li><li class="listitem"><p class="simpara">
									Set the following options on the <span class="strong strong"><strong>Install Operator</strong></span> page:
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											<span class="strong strong"><strong>Update Channel</strong></span> as <span class="strong strong"><strong>stable-4.13</strong></span>.
										</li><li class="listitem">
											<span class="strong strong"><strong>Installation Mode</strong></span> as <span class="strong strong"><strong>A specific namespace on the cluster</strong></span>.
										</li><li class="listitem">
											<span class="strong strong"><strong>Installed Namespace</strong></span> as <span class="strong strong"><strong>Operator recommended namespace openshift-storage</strong></span>. If the <code class="literal">openshift-storage</code> namespace does not exist, it is created during the operator installation.
										</li><li class="listitem"><p class="simpara">
											<span class="strong strong"><strong>Approval Strategy</strong></span> as <span class="strong strong"><strong>Automatic</strong></span> or <span class="strong strong"><strong>Manual</strong></span>.
										</p><p class="simpara">
											If you select <span class="strong strong"><strong>Automatic</strong></span> updates, then the Operator Lifecycle Manager (OLM) automatically upgrades the running instance of your Operator without any intervention.
										</p><p class="simpara">
											If you select <span class="strong strong"><strong>Manual</strong></span> updates, then the OLM creates an update request. As a cluster administrator, you must then manually approve that update request to update the Operator to a newer version.
										</p></li></ol></div></li><li class="listitem">
									Click <span class="strong strong"><strong>Install</strong></span>.
								</li></ol></div><div class="itemizedlist"><p class="title"><strong>Verification steps</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									Verify that LVM Storage shows a green tick, indicating successful installation.
								</li></ul></div></section><section class="section" id="lvms-unstalling-lvms-with-web-console_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.5. Uninstalling LVM Storage installed using the OpenShift Web Console</h5></div></div></div><p>
							You can unstall LVM Storage using the Red Hat OpenShift Container Platform Web Console.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You deleted all the applications on the clusters that are using the storage provisioned by LVM Storage.
								</li><li class="listitem">
									You deleted the persistent volume claims (PVCs) and persistent volumes (PVs) provisioned using LVM Storage.
								</li><li class="listitem">
									You deleted all volume snapshots provisioned by LVM Storage.
								</li><li class="listitem">
									You verified that no logical volume resources exist by using the <code class="literal">oc get logicalvolume</code> command.
								</li><li class="listitem">
									You have access to the single-node OpenShift cluster using an account with <code class="literal">cluster-admin</code> permissions.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									From the <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>Installed Operators</strong></span> page, scroll to <span class="strong strong"><strong>LVM Storage</strong></span> or type <code class="literal">LVM Storage</code> into the <span class="strong strong"><strong>Filter by name</strong></span> to find and click on it.
								</li><li class="listitem">
									Click on the <span class="strong strong"><strong>LVMCluster</strong></span> tab.
								</li><li class="listitem">
									On the right-hand side of the <span class="strong strong"><strong>LVMCluster</strong></span> page, select <span class="strong strong"><strong>Delete LVMCluster</strong></span> from the <span class="strong strong"><strong>Actions</strong></span> drop-down menu.
								</li><li class="listitem">
									Click on the <span class="strong strong"><strong>Details</strong></span> tab.
								</li><li class="listitem">
									On the right-hand side of the <span class="strong strong"><strong>Operator Details</strong></span> page, select <span class="strong strong"><strong>Uninstall Operator</strong></span> from the <span class="strong strong"><strong>Actions</strong></span> drop-down menu.
								</li><li class="listitem">
									Select <span class="strong strong"><strong>Remove</strong></span>. LVM Storage stops running and is completely removed.
								</li></ol></div></section><section class="section" id="lvms-installing-lvms-disconnected-env_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.6. Installing LVM Storage in a disconnected environment</h5></div></div></div><p>
							You can install LVM Storage on OpenShift Container Platform 4.13 in a disconnected environment. All sections referenced in this procedure are linked in <span class="emphasis"><em>Additional resources</em></span>.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You read the <span class="emphasis"><em>About disconnected installation mirroring</em></span> section.
								</li><li class="listitem">
									You have access to the OpenShift Container Platform image repository.
								</li><li class="listitem">
									You created a mirror registry.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Follow the steps in the <span class="emphasis"><em>Creating the image set configuration</em></span> procedure. To create an <code class="literal">ImageSetConfiguration</code> resource for LVM Storage, you can use the following example YAML file:
								</p><div class="formalpara"><p class="title"><strong>Example ImageSetConfiguration file for LVM Storage</strong></p><p>
										
<pre class="programlisting language-yaml">kind: ImageSetConfiguration
apiVersion: mirror.openshift.io/v1alpha2
archiveSize: 4 <span id="CO46-1"><!--Empty--></span><span class="callout">1</span>
storageConfig: <span id="CO46-2"><!--Empty--></span><span class="callout">2</span>
  registry:
    imageURL: example.com/mirror/oc-mirror-metadata <span id="CO46-3"><!--Empty--></span><span class="callout">3</span>
    skipTLS: false
mirror:
  platform:
    channels:
    - name: stable-4.13 <span id="CO46-4"><!--Empty--></span><span class="callout">4</span>
      type: ocp
    graph: true <span id="CO46-5"><!--Empty--></span><span class="callout">5</span>
  operators:
  - catalog: registry.redhat.io/redhat/redhat-operator-index:v4.13 <span id="CO46-6"><!--Empty--></span><span class="callout">6</span>
    packages:
    - name: lvms-operator <span id="CO46-7"><!--Empty--></span><span class="callout">7</span>
      channels:
      - name: stable <span id="CO46-8"><!--Empty--></span><span class="callout">8</span>
  additionalImages:
  - name: registry.redhat.io/ubi9/ubi:latest <span id="CO46-9"><!--Empty--></span><span class="callout">9</span>
  helm: {}</pre>

									</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO46-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											Add <code class="literal">archiveSize</code> to set the maximum size, in GiB, of each file within the image set.
										</div></dd><dt><a href="#CO46-2"><span class="callout">2</span></a> </dt><dd><div class="para">
											Set the back-end location to save the image set metadata to. This location can be a registry or local directory. It is required to specify <code class="literal">storageConfig</code> values, unless you are using the Technology Preview OCI feature.
										</div></dd><dt><a href="#CO46-3"><span class="callout">3</span></a> </dt><dd><div class="para">
											Set the registry URL for the storage backend.
										</div></dd><dt><a href="#CO46-4"><span class="callout">4</span></a> </dt><dd><div class="para">
											Set the channel to retrieve the OpenShift Container Platform images from.
										</div></dd><dt><a href="#CO46-5"><span class="callout">5</span></a> </dt><dd><div class="para">
											Add <code class="literal">graph: true</code> to generate the OpenShift Update Service (OSUS) graph image to allow for an improved cluster update experience when using the web console. For more information, see <span class="emphasis"><em>About the OpenShift Update Service</em></span>.
										</div></dd><dt><a href="#CO46-6"><span class="callout">6</span></a> </dt><dd><div class="para">
											Set the Operator catalog to retrieve the OpenShift Container Platform images from.
										</div></dd><dt><a href="#CO46-7"><span class="callout">7</span></a> </dt><dd><div class="para">
											Specify only certain Operator packages to include in the image set. Remove this field to retrieve all packages in the catalog.
										</div></dd><dt><a href="#CO46-8"><span class="callout">8</span></a> </dt><dd><div class="para">
											Specify only certain channels of the Operator packages to include in the image set. You must always include the default channel for the Operator package even if you do not use the bundles in that channel. You can find the default channel by running the following command: <code class="literal">oc mirror list operators --catalog=&lt;catalog_name&gt; --package=&lt;package_name&gt;</code>.
										</div></dd><dt><a href="#CO46-9"><span class="callout">9</span></a> </dt><dd><div class="para">
											Specify any additional images to include in image set.
										</div></dd></dl></div></li><li class="listitem">
									Follow the procedure in the <span class="emphasis"><em>Mirroring an image set to a mirror registry</em></span> section.
								</li><li class="listitem">
									Follow the procedure in the <span class="emphasis"><em>Configuring image registry repository mirroring</em></span> section.
								</li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installing-mirroring-disconnected-about">About disconnected installation mirroring</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installing-mirroring-creating-registry">Creating a mirror registry with mirror registry for Red Hat OpenShift</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installation-mirror-repository_installing-mirroring-installation-images">Mirroring the OpenShift Container Platform image repository</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#oc-mirror-creating-image-set-config_installing-mirroring-disconnected">Creating the image set configuration</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#mirroring-image-set">Mirroring an image set to a mirror registry</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/images/#images-configuration-registry-mirror_image-configuration">Configuring image registry repository mirroring</a>
								</li></ul></div></section><section class="section" id="lvms-installing-odf-logical-volume-manager-operator-using-rhacm_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.7. Installing LVM Storage using RHACM</h5></div></div></div><p>
							LVM Storage is deployed on single-node OpenShift clusters using Red Hat Advanced Cluster Management (RHACM). You create a <code class="literal">Policy</code> object on RHACM that deploys and configures the Operator when it is applied to managed clusters which match the selector specified in the <code class="literal">PlacementRule</code> resource. The policy is also applied to clusters that are imported later and satisfy the placement rule.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									Access to the RHACM cluster using an account with <code class="literal">cluster-admin</code> and Operator installation permissions.
								</li><li class="listitem">
									Dedicated disks on each single-node OpenShift cluster to be used by LVM Storage.
								</li><li class="listitem">
									The single-node OpenShift cluster needs to be managed by RHACM, either imported or created.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Log in to the RHACM CLI using your OpenShift Container Platform credentials.
								</li><li class="listitem"><p class="simpara">
									Create a namespace in which you will create policies.
								</p><pre class="programlisting language-terminal"># oc create ns lvms-policy-ns</pre></li><li class="listitem"><p class="simpara">
									To create a policy, save the following YAML to a file with a name such as <code class="literal">policy-lvms-operator.yaml</code>:
								</p><pre class="programlisting language-yaml">apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-install-lvms
spec:
  clusterConditions:
  - status: "True"
    type: ManagedClusterConditionAvailable
  clusterSelector: <span id="CO47-1"><!--Empty--></span><span class="callout">1</span>
    matchExpressions:
    - key: mykey
      operator: In
      values:
      - myvalue
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-install-lvms
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-install-lvms
subjects:
- apiGroup: policy.open-cluster-management.io
  kind: Policy
  name: install-lvms
---
apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
  name: install-lvms
spec:
  disabled: false
  remediationAction: enforce
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: install-lvms
      spec:
        object-templates:
        - complianceType: musthave
          objectDefinition:
            apiVersion: v1
            kind: Namespace
            metadata:
              labels:
                openshift.io/cluster-monitoring: "true"
                pod-security.kubernetes.io/enforce: privileged
                pod-security.kubernetes.io/audit: privileged
                pod-security.kubernetes.io/warn: privileged
              name: openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1
            kind: OperatorGroup
            metadata:
              name: openshift-storage-operatorgroup
              namespace: openshift-storage
            spec:
              targetNamespaces:
              - openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1alpha1
            kind: Subscription
            metadata:
              name: lvms
              namespace: openshift-storage
            spec:
              installPlanApproval: Automatic
              name: lvms-operator
              source: redhat-operators
              sourceNamespace: openshift-marketplace
        remediationAction: enforce
        severity: low
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: lvms
      spec:
        object-templates:
           - complianceType: musthave
             objectDefinition:
               apiVersion: lvm.topolvm.io/v1alpha1
               kind: LVMCluster
               metadata:
                 name: my-lvmcluster
                 namespace: openshift-storage
               spec:
                 storage:
                   deviceClasses:
                   - name: vg1
                     default: true
                     deviceSelector: <span id="CO47-2"><!--Empty--></span><span class="callout">2</span>
                       paths:
                       - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
                     thinPoolConfig:
                       name: thin-pool-1
                       sizePercent: 90
                       overprovisionRatio: 10
                     nodeSelector: <span id="CO47-3"><!--Empty--></span><span class="callout">3</span>
                       nodeSelectorTerms:
                       - matchExpressions:
                           - key: app
                             operator: In
                             values:
                             - test1
        remediationAction: enforce
        severity: low</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO47-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											Replace the key and value in <code class="literal">PlacementRule.spec.clusterSelector</code> to match the labels set on the single-node OpenShift clusters on which you want to install LVM Storage.
										</div></dd><dt><a href="#CO47-2"><span class="callout">2</span></a> </dt><dd><div class="para">
											To control or restrict the volume group to your preferred disks, you can manually specify the local paths of the disks in the <code class="literal">deviceSelector</code> section of the <code class="literal">LVMCluster</code> YAML.
										</div></dd><dt><a href="#CO47-3"><span class="callout">3</span></a> </dt><dd><div class="para">
											To add a node filter, which is a subset of the additional worker nodes, specify the required filter in the <code class="literal">nodeSelector</code> section. LVM Storage detects and uses the additional worker nodes when the new nodes show up.
										</div></dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
										This <code class="literal">nodeSelector</code> node filter matching is not the same as the pod label matching.
									</p></div></div></li><li class="listitem"><p class="simpara">
									Create the policy in the namespace by running the following command:
								</p><pre class="programlisting language-terminal"># oc create -f policy-lvms-operator.yaml -n lvms-policy-ns <span id="CO48-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO48-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											The <code class="literal">policy-lvms-operator.yaml</code> is the name of the file to which the policy is saved.
										</div></dd></dl></div><p class="simpara">
									This creates a <code class="literal">Policy</code>, a <code class="literal">PlacementRule</code>, and a <code class="literal">PlacementBinding</code> object in the <code class="literal">lvms-policy-ns</code> namespace. The policy creates a <code class="literal">Namespace</code>, <code class="literal">OperatorGroup</code>, <code class="literal">Subscription</code>, and <code class="literal">LVMCluster</code> resource on the clusters that match the placement rule. This deploys the Operator on the single-node OpenShift clusters which match the selection criteria and configures it to set up the required resources to provision storage. The Operator uses all the disks specified in the <code class="literal">LVMCluster</code> CR. If no disks are specified, the Operator uses all the unused disks on the single-node OpenShift node.
								</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
										After a device is added to the <code class="literal">LVMCluster</code>, it cannot be removed.
									</p></div></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html/install/installing#installing-while-connected-online">Red Hat Advanced Cluster Management for Kubernetes: Installing while connected online</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</a>
								</li></ul></div></section><section class="section" id="lvms-uninstalling-lvms-rhacm_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.1.8. Uninstalling LVM Storage installed using RHACM</h5></div></div></div><p>
							To uninstall LVM Storage that you installed using RHACM, you need to delete the RHACM policy that you created for deploying and configuring the Operator.
						</p><p>
							When you delete the RHACM policy, the resources that the policy has created are not removed. You need to create additional policies to remove the resources.
						</p><p>
							As the created resources are not removed when you delete the policy, you need to perform the following steps:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									Remove all the Persistent volume claims (PVCs) and volume snapshots provisioned by LVM Storage.
								</li><li class="listitem">
									Remove the <code class="literal">LVMCluster</code> resources to clean up Logical Volume Manager resources created on the disks.
								</li><li class="listitem">
									Create an additional policy to uninstall the Operator.
								</li></ol></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									Ensure that the following are deleted before deleting the policy:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
											All the applications on the managed clusters that are using the storage provisioned by LVM Storage.
										</li><li class="listitem">
											PVCs and persistent volumes (PVs) provisioned using LVM Storage.
										</li><li class="listitem">
											All volume snapshots provisioned by LVM Storage.
										</li></ul></div></li><li class="listitem">
									Ensure you have access to the RHACM cluster using an account with a <code class="literal">cluster-admin</code> role.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									In the OpenShift CLI (<code class="literal">oc</code>), delete the RHACM policy that you created for deploying and configuring LVM Storage on the hub cluster by using the following command:
								</p><pre class="programlisting language-terminal"># oc delete -f policy-lvms-operator.yaml -n lvms-policy-ns <span id="CO49-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO49-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											The <code class="literal">policy-lvms-operator.yaml</code> is the name of the file to which the policy was saved.
										</div></dd></dl></div></li><li class="listitem"><p class="simpara">
									To create a policy for removing the <code class="literal">LVMCluster</code> resource, save the following YAML to a file with a name such as <code class="literal">lvms-remove-policy.yaml</code>. This enables the Operator to clean up all Logical Volume Manager resources that it created on the cluster.
								</p><pre class="programlisting language-yaml">apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  name: policy-lvmcluster-delete
  annotations:
    policy.open-cluster-management.io/standards: NIST SP 800-53
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
spec:
  remediationAction: enforce
  disabled: false
  policy-templates:
    - objectDefinition:
        apiVersion: policy.open-cluster-management.io/v1
        kind: ConfigurationPolicy
        metadata:
          name: policy-lvmcluster-removal
        spec:
          remediationAction: enforce <span id="CO50-1"><!--Empty--></span><span class="callout">1</span>
          severity: low
          object-templates:
            - complianceType: mustnothave
              objectDefinition:
                kind: LVMCluster
                apiVersion: lvm.topolvm.io/v1alpha1
                metadata:
                  name: my-lvmcluster
                  namespace: openshift-storage <span id="CO50-2"><!--Empty--></span><span class="callout">2</span>
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-policy-lvmcluster-delete
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-policy-lvmcluster-delete
subjects:
  - apiGroup: policy.open-cluster-management.io
    kind: Policy
    name: policy-lvmcluster-delete
---
apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-policy-lvmcluster-delete
spec:
  clusterConditions:
    - status: "True"
      type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
      - key: mykey
        operator: In
        values:
          - myvalue</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO50-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											The <code class="literal">policy-template</code> <code class="literal">spec.remediationAction</code> is overridden by the preceding parameter value for <code class="literal">spec.remediationAction</code>.
										</div></dd><dt><a href="#CO50-2"><span class="callout">2</span></a> </dt><dd><div class="para">
											This <code class="literal">namespace</code> field must have the <code class="literal">openshift-storage</code> value.
										</div></dd></dl></div></li><li class="listitem">
									Set the value of the <code class="literal">PlacementRule.spec.clusterSelector</code> field to select the clusters from which to uninstall LVM Storage.
								</li><li class="listitem"><p class="simpara">
									Create the policy by running the following command:
								</p><pre class="programlisting language-terminal"># oc create -f lvms-remove-policy.yaml -n lvms-policy-ns</pre></li><li class="listitem"><p class="simpara">
									To create a policy to check if the <code class="literal">LVMCluster</code> CR has been removed, save the following YAML to a file with a name such as <code class="literal">check-lvms-remove-policy.yaml</code>:
								</p><pre class="programlisting language-yaml">apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  name: policy-lvmcluster-inform
  annotations:
    policy.open-cluster-management.io/standards: NIST SP 800-53
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
spec:
  remediationAction: inform
  disabled: false
  policy-templates:
    - objectDefinition:
        apiVersion: policy.open-cluster-management.io/v1
        kind: ConfigurationPolicy
        metadata:
          name: policy-lvmcluster-removal-inform
        spec:
          remediationAction: inform <span id="CO51-1"><!--Empty--></span><span class="callout">1</span>
          severity: low
          object-templates:
            - complianceType: mustnothave
              objectDefinition:
                kind: LVMCluster
                apiVersion: lvm.topolvm.io/v1alpha1
                metadata:
                  name: my-lvmcluster
                  namespace: openshift-storage <span id="CO51-2"><!--Empty--></span><span class="callout">2</span>
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-policy-lvmcluster-check
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-policy-lvmcluster-check
subjects:
  - apiGroup: policy.open-cluster-management.io
    kind: Policy
    name: policy-lvmcluster-inform
---
apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-policy-lvmcluster-check
spec:
  clusterConditions:
    - status: "True"
      type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
      - key: mykey
        operator: In
        values:
          - myvalue</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO51-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											The <code class="literal">policy-template</code> <code class="literal">spec.remediationAction</code> is overridden by the preceding parameter value for <code class="literal">spec.remediationAction</code>.
										</div></dd><dt><a href="#CO51-2"><span class="callout">2</span></a> </dt><dd><div class="para">
											The <code class="literal">namespace</code> field must have the <code class="literal">openshift-storage</code> value.
										</div></dd></dl></div></li><li class="listitem"><p class="simpara">
									Create the policy by running the following command:
								</p><pre class="programlisting language-terminal"># oc create -f check-lvms-remove-policy.yaml -n lvms-policy-ns</pre></li><li class="listitem"><p class="simpara">
									Check the policy status by running the following command:
								</p><pre class="programlisting language-terminal"># oc get policy -n lvms-policy-ns</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
										
<pre class="programlisting language-terminal">NAME                       REMEDIATION ACTION   COMPLIANCE STATE   AGE
policy-lvmcluster-delete   enforce              Compliant          15m
policy-lvmcluster-inform   inform               Compliant          15m</pre>

									</p></div></li><li class="listitem"><p class="simpara">
									After both the policies are compliant, save the following YAML to a file with a name such as <code class="literal">lvms-uninstall-policy.yaml</code> to create a policy to uninstall LVM Storage.
								</p><pre class="programlisting language-yaml">apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-uninstall-lvms
spec:
  clusterConditions:
  - status: "True"
    type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
    - key: mykey
      operator: In
      values:
      - myvalue
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-uninstall-lvms
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-uninstall-lvms
subjects:
- apiGroup: policy.open-cluster-management.io
  kind: Policy
  name: uninstall-lvms
---
apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
  name: uninstall-lvms
spec:
  disabled: false
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: uninstall-lvms
      spec:
        object-templates:
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: v1
            kind: Namespace
            metadata:
              name: openshift-storage
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: operators.coreos.com/v1
            kind: OperatorGroup
            metadata:
              name: openshift-storage-operatorgroup
              namespace: openshift-storage
            spec:
              targetNamespaces:
              - openshift-storage
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: operators.coreos.com/v1alpha1
            kind: Subscription
            metadata:
              name: lvms-operator
              namespace: openshift-storage
        remediationAction: enforce
        severity: low
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: policy-remove-lvms-crds
      spec:
        object-templates:
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: logicalvolumes.topolvm.io
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: lvmclusters.lvm.topolvm.io
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: lvmvolumegroupnodestatuses.lvm.topolvm.io
        - complianceType: mustnothave
          objectDefinition:
            apiVersion: apiextensions.k8s.io/v1
            kind: CustomResourceDefinition
            metadata:
              name: lvmvolumegroups.lvm.topolvm.io
        remediationAction: enforce
        severity: high</pre></li><li class="listitem"><p class="simpara">
									Create the policy by running the following command:
								</p><pre class="programlisting language-terminal"># oc create -f lvms-uninstall-policy.yaml -ns lvms-policy-ns</pre></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</a>
								</li></ul></div></section></section><section class="section" id="lvms-creating-lvms-cluster_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.2. Creating a Logical Volume Manager cluster on a single-node OpenShift worker node</h4></div></div></div><p>
						You can configure a single-node OpenShift worker node as a Logical Volume Manager cluster. On the control-plane single-node OpenShift node, LVM Storage detects and uses the additional worker nodes when the new nodes become active in the cluster.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							When you create a Logical Volume Manager cluster, <code class="literal">StorageClass</code> and <code class="literal">LVMVolumeGroup</code> resources work together to provide dynamic provisioning of storage. <code class="literal">StorageClass</code> CRs define the properties of the storage that you can dynamically provision. <code class="literal">LVMVolumeGroup</code> is a specific type of persistent volume (PV) that is backed by an LVM Volume Group. <code class="literal">LVMVolumeGroup</code> CRs provide the back-end storage for the persistent volumes that you create.
						</p></div></div><p>
						Perform the following procedure to create a Logical Volume Manager cluster on a single-node OpenShift worker node.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							You also can perform the same task by using the OpenShift Container Platform web console.
						</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								You have installed the OpenShift CLI (<code class="literal">oc</code>).
							</li><li class="listitem">
								You have logged in as a user with <code class="literal">cluster-admin</code> privileges.
							</li><li class="listitem">
								You installed LVM Storage in a single-node OpenShift cluster and have installed a worker node for use in the single-node OpenShift cluster.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Create the <code class="literal">LVMCluster</code> custom resource (CR).
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
										Save the following YAML in the <code class="literal">lvmcluster.yaml</code> file:
									</p><pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: lvmcluster
spec:
  storage:
    deviceClasses:  <span id="CO52-1"><!--Empty--></span><span class="callout">1</span>
      - name: vg1
        default: true <span id="CO52-2"><!--Empty--></span><span class="callout">2</span>
        deviceSelector:
          paths:
          - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
          - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
        thinPoolConfig:
          name: thin-pool-1
          sizePercent: 90
          overprovisionRatio: 10
        nodeSelector: <span id="CO52-3"><!--Empty--></span><span class="callout">3</span>
          nodeSelectorTerms:
            - matchExpressions:
              - key: app
                operator: In
                values:
                - test1</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO52-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												To create multiple device storage classes in the cluster, create a YAML array under <code class="literal">deviceClasses</code> for each required storage class. Configure the local device paths of the disks as an array of values in the <code class="literal">deviceSelector</code> field. When configuring multiple device classes, you must specify the device path for each device.
											</div></dd><dt><a href="#CO52-2"><span class="callout">2</span></a> </dt><dd><div class="para">
												Mandatory: The <code class="literal">LVMCluster</code> resource must contain a single default storage class. Set <code class="literal">default: false</code> for secondary device storage classes. If you are upgrading the <code class="literal">LVMCluster</code> resource from a previous version, you must specify a single default device class.
											</div></dd><dt><a href="#CO52-3"><span class="callout">3</span></a> </dt><dd><div class="para">
												Optional: To control what worker nodes the <code class="literal">LVMCluster</code> CR is applied to, specify a set of node selector labels. The specified labels must be present on the node in order for the <code class="literal">LVMCluster</code> to be scheduled on that node.
											</div></dd></dl></div></li><li class="listitem"><p class="simpara">
										Create the <code class="literal">LVMCluster</code> CR:
									</p><pre class="programlisting language-terminal">$ oc create -f lvmcluster.yaml</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
											
<pre class="programlisting language-terminal">lvmcluster/lvmcluster created</pre>

										</p></div><p class="simpara">
										The <code class="literal">LVMCluster</code> resource creates the following system-managed CRs:
									</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">LVMVolumeGroup</code></span></dt><dd>
													Tracks individual volume groups across multiple nodes.
												</dd><dt><span class="term"><code class="literal">LVMVolumeGroupNodeStatus</code></span></dt><dd>
													Tracks the status of the volume groups on a node.
												</dd></dl></div></li></ol></div></li></ol></div><div class="formalpara"><p class="title"><strong>Verification</strong></p><p>
							Verify that the <code class="literal">LVMCluster</code> resource has created the <code class="literal">StorageClass</code>, <code class="literal">LVMVolumeGroup</code>, and <code class="literal">LVMVolumeGroupNodeStatus</code> CRs.
						</p></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							<code class="literal">LVMVolumeGroup</code> and <code class="literal">LVMVolumeGroupNodeStatus</code> are managed by LVM Storage. Do not edit these CRs directly.
						</p></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Check that the <code class="literal">LVMCluster</code> CR is in a <code class="literal">ready</code> state by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get lvmclusters.lvm.topolvm.io -o jsonpath='{.items[*].status.deviceClassStatuses[*]}'</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-json">{
    "name": "vg1",
    "nodeStatus": [
        {
            "devices": [
                "/dev/nvme0n1",
                "/dev/nvme1n1",
                "/dev/nvme2n1"
            ],
            "node": "kube-node",
            "status": "Ready"
        }
    ]
}</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Check that the storage class is created:
							</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME          PROVISIONER          RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
lvms-vg1      topolvm.io           Delete          WaitForFirstConsumer   true                   31m</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Check that the volume snapshot class is created:
							</p><pre class="programlisting language-terminal">$ oc get volumesnapshotclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME          DRIVER               DELETIONPOLICY   AGE
lvms-vg1      topolvm.io           Delete           24h</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Check that the <code class="literal">LVMVolumeGroup</code> resource is created:
							</p><pre class="programlisting language-terminal">$ oc get lvmvolumegroup vg1 -o yaml</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMVolumeGroup
metadata:
  creationTimestamp: "2022-02-02T05:16:42Z"
  generation: 1
  name: vg1
  namespace: lvm-operator-system
  resourceVersion: "17242461"
  uid: 88e8ad7d-1544-41fb-9a8e-12b1a66ab157
spec: {}</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Check that the <code class="literal">LVMVolumeGroupNodeStatus</code> resource is created:
							</p><pre class="programlisting language-terminal">$ oc get lvmvolumegroupnodestatuses.lvm.topolvm.io kube-node -o yaml</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMVolumeGroupNodeStatus
metadata:
  creationTimestamp: "2022-02-02T05:17:59Z"
  generation: 1
  name: kube-node
  namespace: lvm-operator-system
  resourceVersion: "17242882"
  uid: 292de9bb-3a9b-4ee8-946a-9b587986dafd
spec:
  nodeStatus:
    - devices:
        - /dev/nvme0n1
        - /dev/nvme1n1
        - /dev/nvme2n1
      name: vg1
      status: Ready</pre>

								</p></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/nodes/#adding-worker-nodes-to-single-node-openshift-clusters">Adding worker nodes to single-node OpenShift clusters</a>
							</li><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</a>
							</li></ul></div></section><section class="section" id="lvms-provisioning-storage-using-lvms_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.3. Provisioning storage using LVM Storage</h4></div></div></div><p>
						You can provision persistent volume claims (PVCs) using the storage class that is created during the Operator installation. You can provision block and file PVCs, however, the storage is allocated only when a pod that uses the PVC is created.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							LVM Storage provisions PVCs in units of 1 GiB. The requested storage is rounded up to the nearest GiB.
						</p></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Identify the <code class="literal">StorageClass</code> that is created when LVM Storage is deployed.
							</p><p class="simpara">
								The <code class="literal">StorageClass</code> name is in the format, <code class="literal">lvms-&lt;device-class-name&gt;</code>. The <code class="literal">device-class-name</code> is the name of the device class that you provided in the <code class="literal">LVMCluster</code> of the <code class="literal">Policy</code> YAML. For example, if the <code class="literal">deviceClass</code> is called <code class="literal">vg1</code>, then the <code class="literal">storageClass</code> name is <code class="literal">lvms-vg1</code>.
							</p><p class="simpara">
								The <code class="literal">volumeBindingMode</code> of the storage class is set to <code class="literal">WaitForFirstConsumer</code>.
							</p></li><li class="listitem"><p class="simpara">
								To create a PVC where the application requires storage, save the following YAML to a file with a name such as <code class="literal">pvc.yaml</code>.
							</p><div class="formalpara"><p class="title"><strong>Example YAML to create a PVC</strong></p><p>
									
<pre class="programlisting language-yaml"># block pvc
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: lvm-block-1
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Block
  resources:
    requests:
      storage: 10Gi
  storageClassName: lvms-vg1
---
# file pvc
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: lvm-file-1
  namespace: default
spec:
  accessModes:
    - ReadWriteOnce
  volumeMode: Filesystem
  resources:
    requests:
      storage: 10Gi
  storageClassName: lvms-vg1</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Create the PVC by running the following command:
							</p><pre class="programlisting language-terminal"># oc create -f pvc.yaml -ns &lt;application_namespace&gt;</pre><p class="simpara">
								The created PVCs remain in <code class="literal">pending</code> state until you deploy the pods that use them.
							</p></li></ol></div></section><section class="section" id="lvms-monitoring-using-lvms_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.4. Monitoring LVM Storage</h4></div></div></div><p>
						When LVM Storage is installed using the OpenShift Container Platform Web Console, you can monitor the cluster by using the <span class="strong strong"><strong>Block and File</strong></span> dashboard in the console by default. However, when you use RHACM to install LVM Storage, you need to configure RHACM Observability to monitor all the single-node OpenShift clusters from one place.
					</p><section class="section" id="lvms-monitoring-using-lvms-metrics_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.4.1. Metrics</h5></div></div></div><p>
							You can monitor LVM Storage by viewing the metrics exported by the Operator on the RHACM dashboards and the alerts that are triggered.
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									Add the following <code class="literal">topolvm</code> metrics to the <code class="literal">allow</code> list:
								</p><pre class="programlisting language-terminal">topolvm_thinpool_data_percent
topolvm_thinpool_metadata_percent
topolvm_thinpool_size_bytes</pre></li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Metrics are updated every 10 minutes or when there is a change in the thin pool, such as a new logical volume creation.
							</p></div></div></section><section class="section" id="lvms-monitoring-using-lvms-alerts_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.4.2. Alerts</h5></div></div></div><p>
							When the thin pool and volume group are filled up, further operations fail and might lead to data loss. LVM Storage sends the following alerts about the usage of the thin pool and volume group when utilization crosses a certain value:
						</p><div class="formalpara"><p class="title"><strong>Alerts for Logical Volume Manager cluster in RHACM</strong></p><p>
								<span id="alerts_for_LVMCluster_in_RHACM"><!--Empty--></span>
							</p></div><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 50%; " class="col_1"><!--Empty--></col><col style="width: 50%; " class="col_2"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001852224816" scope="col">Alert</th><th align="left" valign="top" id="idm140001852223728" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001852224816"> <p>
											<code class="literal">VolumeGroupUsageAtThresholdNearFull</code>
										</p>
										 </td><td align="left" valign="top" headers="idm140001852223728"> <p>
											This alert is triggered when both the volume group and thin pool utilization cross 75% on nodes. Data deletion or volume group expansion is required.
										</p>
										 </td></tr><tr><td align="left" valign="top" headers="idm140001852224816"> <p>
											<code class="literal">VolumeGroupUsageAtThresholdCritical</code>
										</p>
										 </td><td align="left" valign="top" headers="idm140001852223728"> <p>
											This alert is triggered when both the volume group and thin pool utilization cross 85% on nodes. <code class="literal">VolumeGroup</code> is critically full. Data deletion or volume group expansion is required.
										</p>
										 </td></tr><tr><td align="left" valign="top" headers="idm140001852224816"> <p>
											<code class="literal">ThinPoolDataUsageAtThresholdNearFull</code>
										</p>
										 </td><td align="left" valign="top" headers="idm140001852223728"> <p>
											This alert is triggered when the thin pool data utilization in the volume group crosses 75% on nodes. Data deletion or thin pool expansion is required.
										</p>
										 </td></tr><tr><td align="left" valign="top" headers="idm140001852224816"> <p>
											<code class="literal">ThinPoolDataUsageAtThresholdCritical</code>
										</p>
										 </td><td align="left" valign="top" headers="idm140001852223728"> <p>
											This alert is triggered when the thin pool data utilization in the volume group crosses 85% on nodes. Data deletion or thin pool expansion is required.
										</p>
										 </td></tr><tr><td align="left" valign="top" headers="idm140001852224816"> <p>
											<code class="literal">ThinPoolMetaDataUsageAtThresholdNearFull</code>
										</p>
										 </td><td align="left" valign="top" headers="idm140001852223728"> <p>
											This alert is triggered when the thin pool metadata utilization in the volume group crosses 75% on nodes. Data deletion or thin pool expansion is required.
										</p>
										 </td></tr><tr><td align="left" valign="top" headers="idm140001852224816"> <p>
											<code class="literal">ThinPoolMetaDataUsageAtThresholdCritical</code>
										</p>
										 </td><td align="left" valign="top" headers="idm140001852223728"> <p>
											This alert is triggered when the thin pool metadata utilization in the volume group crosses 85% on nodes. Data deletion or thin pool expansion is required.
										</p>
										 </td></tr></tbody></table></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/observability/index">Observability</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html-single/observability/index#adding-custom-metrics">Adding custom metrics</a>
								</li></ul></div></section></section><section class="section" id="lvms-scaling-storage-of-single-node-openshift-cluster-con_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.5. Scaling storage of single-node OpenShift clusters</h4></div></div></div><p>
						The OpenShift Container Platform supports additional worker nodes for single-node OpenShift clusters on bare-metal user-provisioned infrastructure. LVM Storage detects and uses the new additional worker nodes when the nodes show up.
					</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/nodes/#adding-worker-nodes-to-single-node-openshift-clusters">Adding worker nodes to single-node OpenShift clusters</a>
							</li></ul></div><section class="section" id="lvms-scaling-storage-of-single-node-openshift-cluster_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.5.1. Scaling up storage by adding capacity to your single-node OpenShift cluster</h5></div></div></div><p>
							To scale the storage capacity of your configured worker nodes on a single-node OpenShift cluster, you can increase the capacity by adding disks.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You have additional unused disks on each single-node OpenShift cluster to be used by LVM Storage.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Log in to OpenShift Container Platform console of the single-node OpenShift cluster.
								</li><li class="listitem">
									From the <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>Installed Operators</strong></span> page, click on the <span class="strong strong"><strong>LVM Storage Operator</strong></span> in the <code class="literal">openshift-storage</code> namespace.
								</li><li class="listitem">
									Click on the <span class="strong strong"><strong>LVMCluster</strong></span> tab to list the <code class="literal">LVMCluster</code> CR created on the cluster.
								</li><li class="listitem">
									Select <span class="strong strong"><strong>Edit LVMCluster</strong></span> from the <span class="strong strong"><strong>Actions</strong></span> drop-down menu.
								</li><li class="listitem">
									Click on the <span class="strong strong"><strong>YAML</strong></span> tab.
								</li><li class="listitem"><p class="simpara">
									Edit the <code class="literal">LVMCluster</code> CR YAML to add the new device path in the <code class="literal">deviceSelector</code> section:
								</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										In case the <code class="literal">deviceSelector</code> field is not included during the <code class="literal">LVMCluster</code> creation, it is not possible to add the <code class="literal">deviceSelector</code> section to the CR. You need to remove the <code class="literal">LVMCluster</code> and then create a new CR.
									</p></div></div><pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  storage:
    deviceClasses:
    - name: vg1
      default: true
      deviceSelector:
        paths:
        - /dev/disk/by-path/pci-0000:87:00.0-nvme-1 <span id="CO53-1"><!--Empty--></span><span class="callout">1</span>
        - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:89:00.0-nvme-1 <span id="CO53-2"><!--Empty--></span><span class="callout">2</span>
      thinPoolConfig:
        name: thin-pool-1
        sizePercent: 90
        overprovisionRatio: 10</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO53-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											The path can be added by name (<code class="literal">/dev/sdb</code>) or by path.
										</div></dd><dt><a href="#CO53-2"><span class="callout">2</span></a> </dt><dd><div class="para">
											A new disk is added.
										</div></dd></dl></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</a>
								</li></ul></div></section><section class="section" id="lvms-scaling-storage-of-single-node-openshift-cluster-using-rhacm_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.5.2. Scaling up storage by adding capacity to your single-node OpenShift cluster using RHACM</h5></div></div></div><p>
							You can scale the storage capacity of your configured worker nodes on a single-node OpenShift cluster using RHACM.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You have access to the RHACM cluster using an account with <code class="literal">cluster-admin</code> privilages.
								</li><li class="listitem">
									You have additional unused disks on each single-node OpenShift cluster to be used by LVM Storage.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Log in to the RHACM CLI using your OpenShift Container Platform credentials.
								</li><li class="listitem">
									Find the disk that you want to add. The disk to be added needs to match with the device name and path of the existing disks.
								</li><li class="listitem"><p class="simpara">
									To add capacity to the single-node OpenShift cluster, edit the <code class="literal">deviceSelector</code> section of the existing policy YAML, for example, <code class="literal">policy-lvms-operator.yaml</code>.
								</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										In case the <code class="literal">deviceSelector</code> field is not included during the <code class="literal">LVMCluster</code> creation, it is not possible to add the <code class="literal">deviceSelector</code> section to the CR. You need to remove the <code class="literal">LVMCluster</code> and then recreate from the new CR.
									</p></div></div><pre class="programlisting language-yaml">apiVersion: apps.open-cluster-management.io/v1
kind: PlacementRule
metadata:
  name: placement-install-lvms
spec:
  clusterConditions:
  - status: "True"
    type: ManagedClusterConditionAvailable
  clusterSelector:
    matchExpressions:
    - key: mykey
      operator: In
      values:
      - myvalue
---
apiVersion: policy.open-cluster-management.io/v1
kind: PlacementBinding
metadata:
  name: binding-install-lvms
placementRef:
  apiGroup: apps.open-cluster-management.io
  kind: PlacementRule
  name: placement-install-lvms
subjects:
- apiGroup: policy.open-cluster-management.io
  kind: Policy
  name: install-lvms
---
apiVersion: policy.open-cluster-management.io/v1
kind: Policy
metadata:
  annotations:
    policy.open-cluster-management.io/categories: CM Configuration Management
    policy.open-cluster-management.io/controls: CM-2 Baseline Configuration
    policy.open-cluster-management.io/standards: NIST SP 800-53
  name: install-lvms
spec:
  disabled: false
  remediationAction: enforce
  policy-templates:
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: install-lvms
      spec:
        object-templates:
        - complianceType: musthave
          objectDefinition:
            apiVersion: v1
            kind: Namespace
            metadata:
              labels:
                openshift.io/cluster-monitoring: "true"
                pod-security.kubernetes.io/enforce: privileged
                pod-security.kubernetes.io/audit: privileged
                pod-security.kubernetes.io/warn: privileged
              name: openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1
            kind: OperatorGroup
            metadata:
              name: openshift-storage-operatorgroup
              namespace: openshift-storage
            spec:
              targetNamespaces:
              - openshift-storage
        - complianceType: musthave
          objectDefinition:
            apiVersion: operators.coreos.com/v1alpha1
            kind: Subscription
            metadata:
              name: lvms
              namespace: openshift-storage
            spec:
              installPlanApproval: Automatic
              name: lvms-operator
              source: redhat-operators
              sourceNamespace: openshift-marketplace
        remediationAction: enforce
        severity: low
  - objectDefinition:
      apiVersion: policy.open-cluster-management.io/v1
      kind: ConfigurationPolicy
      metadata:
        name: lvms
      spec:
        object-templates:
           - complianceType: musthave
             objectDefinition:
               apiVersion: lvm.topolvm.io/v1alpha1
               kind: LVMCluster
               metadata:
                 name: my-lvmcluster
                 namespace: openshift-storage
               spec:
                 storage:
                   deviceClasses:
                   - name: vg1
                     default: true
                     deviceSelector:
                       paths:
                       - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
                       - /dev/disk/by-path/pci-0000:89:00.0-nvme-1 # new disk is added
                     thinPoolConfig:
                       name: thin-pool-1
                       sizePercent: 90
                       overprovisionRatio: 10
                     nodeSelector:
                       nodeSelectorTerms:
                       - matchExpressions:
                           - key: app
                             operator: In
                             values:
                             - test1
        remediationAction: enforce
        severity: low</pre></li><li class="listitem"><p class="simpara">
									Edit the policy by running the following command:
								</p><pre class="programlisting language-terminal"># oc edit -f policy-lvms-operator.yaml -ns lvms-policy-ns <span id="CO54-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO54-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											The <code class="literal">policy-lvms-operator.yaml</code> is the name of the existing policy.
										</div></dd></dl></div><p class="simpara">
									This uses the new disk specified in the <code class="literal">LVMCluster</code> CR to provision storage.
								</p></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_advanced_cluster_management_for_kubernetes/2.6/html/install/installing#installing-while-connected-online">Red Hat Advanced Cluster Management for Kubernetes: Installing while connected online</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-reference-file_logical-volume-manager-storage">LVM Storage reference YAML file</a>
								</li></ul></div></section><section class="section" id="lvms-scaling-expand-pvc_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.5.3. Expanding PVCs</h5></div></div></div><p>
							To leverage the new storage after adding additional capacity, you can expand existing persistent volume claims (PVCs) with LVM Storage.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									Dynamic provisioning is used.
								</li><li class="listitem">
									The controlling <code class="literal">StorageClass</code> object has <code class="literal">allowVolumeExpansion</code> set to <code class="literal">true</code>.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Modify the <code class="literal">.spec.resources.requests.storage</code> field in the desired PVC resource to the new size by running the following command:
								</p><pre class="programlisting language-terminal">oc patch &lt;pvc_name&gt; -n &lt;application_namespace&gt; -p '{ "spec": { "resources": { "requests": { "storage": "&lt;desired_size&gt;" }}}}'</pre></li><li class="listitem">
									Watch the <code class="literal">status.conditions</code> field of the PVC to see if the resize has completed. OpenShift Container Platform adds the <code class="literal">Resizing</code> condition to the PVC during expansion, which is removed after the expansion completes.
								</li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-scaling-storage-of-single-node-openshift-cluster_logical-volume-manager-storage">Scaling up storage by adding capacity to your single-node OpenShift cluster</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#lvms-scaling-storage-of-single-node-openshift-cluster-using-rhacm_logical-volume-manager-storage">Scaling up storage by adding capacity to your single-node OpenShift cluster using RHACM</a>
								</li><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#add-volume-expansion_expanding-persistent-volumes">Enabling volume expansion support</a>
								</li></ul></div></section></section><section class="section" id="lvms-upgrading-lvms-on-sno_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.6. Upgrading LVM Storage on single-node OpenShift clusters</h4></div></div></div><p>
						Currently, it is not possible to upgrade from OpenShift Data Foundation Logical Volume Manager Operator 4.11 to LVM Storage 4.12 on single-node OpenShift clusters.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							The data will not be preserved during this process.
						</p></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
								Back up any data that you want to preserve on the persistent volume claims (PVCs).
							</li><li class="listitem">
								Delete all PVCs provisioned by the OpenShift Data Foundation Logical Volume Manager Operator and their pods.
							</li><li class="listitem">
								Reinstall LVM Storage on OpenShift Container Platform 4.12.
							</li><li class="listitem">
								Recreate the workloads.
							</li><li class="listitem">
								Copy the backup data to the PVCs created after upgrading to 4.12.
							</li></ol></div></section><section class="section" id="lvms-volume-snapsot-for-sno_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.7. Volume snapshots for single-node OpenShift</h4></div></div></div><p>
						You can take volume snapshots of persistent volumes (PVs) that are provisioned by LVM Storage. You can also create volume snapshots of the cloned volumes. Volume snapshots help you to do the following:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Back up your application data.
							</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
									Volume snapshots are located on the same devices as the original data. To use the volume snapshots as backups, you need to move the snapshots to a secure location. You can use OpenShift API for Data Protection backup and restore solutions.
								</p></div></div></li><li class="listitem">
								Revert to a state at which the volume snapshot was taken.
							</li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/backup_and_restore/#oadp-features_oadp-features-plugins">OADP features</a>
							</li></ul></div><section class="section" id="lvms-creating-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.7.1. Creating volume snapshots in single-node OpenShift</h5></div></div></div><p>
							You can create volume snapshots based on the available capacity of the thin pool and the overprovisioning limits. LVM Storage creates a <code class="literal">VolumeSnapshotClass</code> with the <code class="literal">lvms-&lt;deviceclass-name&gt;</code> name.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You ensured that the persistent volume claim (PVC) is in <code class="literal">Bound</code> state. This is required for a consistent snapshot.
								</li><li class="listitem">
									You stopped all the I/O to the PVC before taking the snapshot.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Log in to the single-node OpenShift for which you need to run the <code class="literal">oc</code> command.
								</li><li class="listitem"><p class="simpara">
									Save the following YAML to a file with a name such as <code class="literal">lvms-vol-snapshot.yaml</code>.
								</p><div class="formalpara"><p class="title"><strong>Example YAML to create a volume snapshot</strong></p><p>
										
<pre class="programlisting language-yaml">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
    name: lvm-block-1-snap
spec:
    volumeSnapshotClassName: lvms-vg1
    source:
        persistentVolumeClaimName: lvm-block-1</pre>

									</p></div></li><li class="listitem"><p class="simpara">
									Create the snapshot by running the following command in the same namespace as the PVC:
								</p><pre class="programlisting language-terminal"># oc create -f lvms-vol-snapshot.yaml</pre></li></ol></div><p>
							A read-only copy of the PVC is created as a volume snapshot.
						</p></section><section class="section" id="lvms-restoring-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.7.2. Restoring volume snapshots in single-node OpenShift</h5></div></div></div><p>
							When you restore a volume snapshot, a new persistent volume claim (PVC) is created. The restored PVC is independent of the volume snapshot and the source PVC.
						</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									The storage class must be the same as that of the source PVC.
								</li><li class="listitem"><p class="simpara">
									The size of the requested PVC must be the same as that of the source volume of the snapshot.
								</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
										A snapshot must be restored to a PVC of the same size as the source volume of the snapshot. If a larger PVC is required, you can resize the PVC after the snapshot is restored successfully.
									</p></div></div></li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Identify the storage class name of the source PVC and volume snapshot name.
								</li><li class="listitem"><p class="simpara">
									Save the following YAML to a file with a name such as <code class="literal">lvms-vol-restore.yaml</code> to restore the snapshot.
								</p><div class="formalpara"><p class="title"><strong>Example YAML to restore a PVC.</strong></p><p>
										
<pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: lvm-block-1-restore
spec:
  accessModes:
  - ReadWriteOnce
  volumeMode: Block
  Resources:
    Requests:
      storage: 2Gi
  storageClassName: lvms-vg1
  dataSource:
    name: lvm-block-1-snap
    kind: VolumeSnapshot
    apiGroup: snapshot.storage.k8s.io</pre>

									</p></div></li><li class="listitem"><p class="simpara">
									Create the policy by running the following command in the same namespace as the snapshot:
								</p><pre class="programlisting language-terminal"># oc create -f lvms-vol-restore.yaml</pre></li></ol></div></section><section class="section" id="lvms-deleting-volume-snapshots-in-single-node-openshift_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.7.3. Deleting volume snapshots in single-node OpenShift</h5></div></div></div><p>
							You can delete volume snapshots resources and persistent volume claims (PVCs).
						</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Delete the volume snapshot resource by running the following command:
								</p><pre class="programlisting language-terminal"># oc delete volumesnapshot &lt;volume_snapshot_name&gt; -n &lt;namespace&gt;</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										When you delete a persistent volume claim (PVC), the snapshots of the PVC are not deleted.
									</p></div></div></li><li class="listitem"><p class="simpara">
									To delete the restored volume snapshot, delete the PVC that was created to restore the volume snapshot by running the following command:
								</p><pre class="programlisting language-terminal"># oc delete pvc &lt;pvc_name&gt; -n &lt;namespace&gt;</pre></li></ol></div></section></section><section class="section" id="lvms-volume-cloning-for-single-node-openshift-cluster_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.8. Volume cloning for single-node OpenShift</h4></div></div></div><p>
						A clone is a duplicate of an existing storage volume that can be used like any standard volume.
					</p><section class="section" id="lvms-creating-volume-clones-in-single-node-openshift_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.8.1. Creating volume clones in single-node OpenShift</h5></div></div></div><p>
							You create a clone of a volume to make a point-in-time copy of the data. A persistent volume claim (PVC) cannot be cloned with a different size.
						</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								The cloned PVC has write access.
							</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
									You ensured that the PVC is in <code class="literal">Bound</code> state. This is required for a consistent snapshot.
								</li><li class="listitem">
									You ensured that the <code class="literal">StorageClass</code> is the same as that of the source PVC.
								</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
									Identify the storage class of the source PVC.
								</li><li class="listitem"><p class="simpara">
									To create a volume clone, save the following YAML to a file with a name such as <code class="literal">lvms-vol-clone.yaml</code>:
								</p><div class="formalpara"><p class="title"><strong>Example YAML to clone a volume</strong></p><p>
										
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
Metadata:
  name: lvm-block-1-clone
Spec:
  storageClassName: lvms-vg1
  dataSource:
    name: lvm-block-1
    kind: PersistentVolumeClaim
  accessModes:
   - ReadWriteOnce
  volumeMode: Block
  Resources:
    Requests:
      storage: 2Gi</pre>

									</p></div></li><li class="listitem"><p class="simpara">
									Create the policy in the same namespace as the source PVC by running the following command:
								</p><pre class="programlisting language-terminal"># oc create -f lvms-vol-clone.yaml</pre></li></ol></div></section><section class="section" id="lvms-deleting-cloned-volumes-in-single-node-openshift_logical-volume-manager-storage"><div class="titlepage"><div><div><h5 class="title">4.12.3.8.2. Deleting cloned volumes in single-node OpenShift</h5></div></div></div><p>
							You can delete cloned volumes.
						</p><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									To delete the cloned volume, delete the cloned PVC by running the following command:
								</p><pre class="programlisting language-terminal"># oc delete pvc &lt;clone_pvc_name&gt; -n &lt;namespace&gt;</pre></li></ul></div></section></section><section class="section" id="lvms-dowloading-log-files-and-diagnostics_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.9. Downloading log files and diagnostic information using must-gather</h4></div></div></div><p>
						When LVM Storage is unable to automatically resolve a problem, use the must-gather tool to collect the log files and diagnostic information so that you or the Red Hat Support can review the problem and determine a solution.
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Run the must-gather command from the client connected to LVM Storage cluster by running the following command:
							</p><pre class="programlisting language-terminal">$ oc adm must-gather --image=registry.redhat.io/lvms4/lvms-must-gather-rhel8:v4.13 --dest-dir=&lt;directory-name&gt;</pre></li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/support/#about-must-gather_gathering-cluster-data">About the must-gather tool</a>
							</li></ul></div></section><section class="section" id="lvms-reference-file_logical-volume-manager-storage"><div class="titlepage"><div><div><h4 class="title">4.12.3.10. LVM Storage reference YAML file</h4></div></div></div><p>
						The sample <code class="literal">LVMCluster</code> custom resource (CR) describes all the fields in the YAML file.
					</p><div class="formalpara"><p class="title"><strong>Example LVMCluster CR</strong></p><p>
							
<pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  tolerations:
  - effect: NoSchedule
    key: xyz
    operator: Equal
    value: "true"
  storage:
    deviceClasses:    <span id="CO55-1"><!--Empty--></span><span class="callout">1</span>
    - name: vg1    <span id="CO55-2"><!--Empty--></span><span class="callout">2</span>
      default: true
      nodeSelector: <span id="CO55-3"><!--Empty--></span><span class="callout">3</span>
        nodeSelectorTerms: <span id="CO55-4"><!--Empty--></span><span class="callout">4</span>
        - matchExpressions:
          - key: mykey
            operator: In
            values:
            - ssd
      deviceSelector: <span id="CO55-5"><!--Empty--></span><span class="callout">5</span>
        paths:
        - /dev/disk/by-path/pci-0000:87:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:88:00.0-nvme-1
        - /dev/disk/by-path/pci-0000:89:00.0-nvme-1
      thinPoolConfig: <span id="CO55-6"><!--Empty--></span><span class="callout">6</span>
        name: thin-pool-1 <span id="CO55-7"><!--Empty--></span><span class="callout">7</span>
        sizePercent: 90 <span id="CO55-8"><!--Empty--></span><span class="callout">8</span>
        overprovisionRatio: 10 <span id="CO55-9"><!--Empty--></span><span class="callout">9</span>
status:
    deviceClassStatuses: <span id="CO55-10"><!--Empty--></span><span class="callout">10</span>
    - name: vg1
      nodeStatus: <span id="CO55-11"><!--Empty--></span><span class="callout">11</span>
      - devices: <span id="CO55-12"><!--Empty--></span><span class="callout">12</span>
        - /dev/nvme0n1
        - /dev/nvme1n1
        - /dev/nvme2n1
        node: my-node.example.com <span id="CO55-13"><!--Empty--></span><span class="callout">13</span>
        status: Ready <span id="CO55-14"><!--Empty--></span><span class="callout">14</span>
    ready: true <span id="CO55-15"><!--Empty--></span><span class="callout">15</span>
    state: Ready <span id="CO55-16"><!--Empty--></span><span class="callout">16</span></pre>

						</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO55-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								The LVM volume groups to be created on the cluster. Currently, only a single <code class="literal">deviceClass</code> is supported.
							</div></dd><dt><a href="#CO55-2"><span class="callout">2</span></a> </dt><dd><div class="para">
								The name of the LVM volume group to be created on the nodes.
							</div></dd><dt><a href="#CO55-3"><span class="callout">3</span></a> </dt><dd><div class="para">
								The nodes on which to create the LVM volume group. If the field is empty, all nodes are considered.
							</div></dd><dt><a href="#CO55-4"><span class="callout">4</span></a> </dt><dd><div class="para">
								A list of node selector requirements.
							</div></dd><dt><a href="#CO55-5"><span class="callout">5</span></a> </dt><dd><div class="para">
								A list of device paths which is used to create the LVM volume group. If this field is empty, all unused disks on the node will be used.
							</div></dd><dt><a href="#CO55-6"><span class="callout">6</span></a> </dt><dd><div class="para">
								The LVM thin pool configuration.
							</div></dd><dt><a href="#CO55-7"><span class="callout">7</span></a> </dt><dd><div class="para">
								The name of the thin pool to be created in the LVM volume group.
							</div></dd><dt><a href="#CO55-8"><span class="callout">8</span></a> </dt><dd><div class="para">
								The percentage of remaining space in the LVM volume group that should be used for creating the thin pool.
							</div></dd><dt><a href="#CO55-9"><span class="callout">9</span></a> </dt><dd><div class="para">
								The factor by which additional storage can be provisioned compared to the available storage in the thin pool.
							</div></dd><dt><a href="#CO55-10"><span class="callout">10</span></a> </dt><dd><div class="para">
								The status of the <code class="literal">deviceClass</code>.
							</div></dd><dt><a href="#CO55-11"><span class="callout">11</span></a> </dt><dd><div class="para">
								The status of the LVM volume group on each node.
							</div></dd><dt><a href="#CO55-12"><span class="callout">12</span></a> </dt><dd><div class="para">
								The list of devices used to create the LVM volume group.
							</div></dd><dt><a href="#CO55-13"><span class="callout">13</span></a> </dt><dd><div class="para">
								The node on which the <code class="literal">deviceClass</code> was created.
							</div></dd><dt><a href="#CO55-14"><span class="callout">14</span></a> </dt><dd><div class="para">
								The status of the LVM volume group on the node.
							</div></dd><dt><a href="#CO55-15"><span class="callout">15</span></a> </dt><dd><div class="para">
								This field is deprecated.
							</div></dd><dt><a href="#CO55-16"><span class="callout">16</span></a> </dt><dd><div class="para">
								The status of the <code class="literal">LVMCluster</code>.
							</div></dd></dl></div></section></section><section class="section" id="troubleshooting-local-persistent-storage"><div class="titlepage"><div><div><h3 class="title">4.12.4. Troubleshooting local persistent storage using LVMS</h3></div></div></div><p>
					Because OpenShift Container Platform does not scope a persistent volume (PV) to a single project, it can be shared across the cluster and claimed by any project using a persistent volume claim (PVC). This can lead to a number of issues that require troubleshooting.
				</p><section class="section" id="investigating-a-pvc-stuck-in-the-pending-state_troubleshooting-local-persistent-storage-using-lvms"><div class="titlepage"><div><div><h4 class="title">4.12.4.1. Investigating a PVC stuck in the Pending state</h4></div></div></div><p>
						A persistent volume claim (PVC) can get stuck in a <code class="literal">Pending</code> state for a number of reasons. For example:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Insufficient computing resources
							</li><li class="listitem">
								Network problems
							</li><li class="listitem">
								Mismatched storage class or node selector
							</li><li class="listitem">
								No available volumes
							</li><li class="listitem">
								The node with the persistent volume (PV) is in a <code class="literal">Not Ready</code> state
							</li></ul></div><p>
						Identify the cause by using the <code class="literal">oc describe</code> command to review details about the stuck PVC.
					</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Retrieve the list of PVCs by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get pvc</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME        STATUS    VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
lvms-test   Pending                                      lvms-vg1       11s</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Inspect the events associated with a PVC stuck in the <code class="literal">Pending</code> state by running the following command:
							</p><pre class="programlisting language-terminal">$ oc describe pvc &lt;pvc_name&gt; <span id="CO56-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO56-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Replace <code class="literal">&lt;pvc_name&gt;</code> with the name of the PVC. For example, <code class="literal">lvms-vg1</code>.
									</div></dd></dl></div><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">Type     Reason              Age               From                         Message
----     ------              ----              ----                         -------
Warning  ProvisioningFailed  4s (x2 over 17s)  persistentvolume-controller  storageclass.storage.k8s.io "lvms-vg1" not found</pre>

								</p></div></li></ol></div></section><section class="section" id="recovering-from-missing-lvms-or-operator-components_troubleshooting-local-persistent-storage-using-lvms"><div class="titlepage"><div><div><h4 class="title">4.12.4.2. Recovering from missing LVMS or Operator components</h4></div></div></div><p>
						If you encounter a storage class "not found" error, check the <code class="literal">LVMCluster</code> resource and ensure that all the logical volume manager storage (LVMS) pods are running. You can create an <code class="literal">LVMCluster</code> resource if it does not exist.
					</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Verify the presence of the LVMCluster resource by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get lvmcluster -n openshift-storage</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME            AGE
my-lvmcluster   65m</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								If the cluster doesn’t have an <code class="literal">LVMCluster</code> resource, create one by running the following command:
							</p><pre class="programlisting language-terminal">$ oc create -n openshift-storage -f &lt;custom_resource&gt; <span id="CO57-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO57-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Replace <code class="literal">&lt;custom_resource&gt;</code> with a custom resource URL or file tailored to your requirements.
									</div></dd></dl></div><div class="white-space-pre white-space-pre"><p class="title"><strong>Example custom resource</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: lvm.topolvm.io/v1alpha1
kind: LVMCluster
metadata:
  name: my-lvmcluster
spec:
  storage:
    deviceClasses:
    - name: vg1
      default: true
      thinPoolConfig:
        name: thin-pool-1
        sizePercent: 90
        overprovisionRatio: 10</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Check that all the pods from LVMS are in the <code class="literal">Running</code> state in the <code class="literal">openshift-storage</code> namespace by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get pods -n openshift-storage</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME                                  READY   STATUS    RESTARTS      AGE
lvms-operator-7b9fb858cb-6nsml        3/3     Running   0             70m
topolvm-controller-5dd9cf78b5-7wwr2   5/5     Running   0             66m
topolvm-node-dr26h                    4/4     Running   0             66m
vg-manager-r6zdv                      1/1     Running   0             66m</pre>

								</p></div><p class="simpara">
								The expected output is one running instance of <code class="literal">lvms-operator</code> and <code class="literal">vg-manager</code>. One instance of <code class="literal">topolvm-controller</code> and <code class="literal">topolvm-node</code> is expected for each node.
							</p><p class="simpara">
								If <code class="literal">topolvm-node</code> is stuck in the <code class="literal">Init</code> state, there is a failure to locate an available disk for LVMS to use. To retrieve the information necessary to troubleshoot, review the logs of the <code class="literal">vg-manager</code> pod by running the following command:
							</p><pre class="programlisting language-terminal">$ oc logs -l app.kubernetes.io/component=vg-manager -n openshift-storage</pre></li></ol></div></section><section class="section" id="recovering-from-node-failure_troubleshooting-local-persistent-storage-using-lvms"><div class="titlepage"><div><div><h4 class="title">4.12.4.3. Recovering from node failure</h4></div></div></div><p>
						Sometimes a persistent volume claim (PVC) is stuck in a <code class="literal">Pending</code> state because a particular node in the cluster has failed. To identify the failed node, you can examine the restart count of the <code class="literal">topolvm-node</code> pod. An increased restart count indicates potential problems with the underlying node, which may require further investigation and troubleshooting.
					</p><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								Examine the restart count of the <code class="literal">topolvm-node</code> pod instances by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get pods -n openshift-storage</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">NAME                                  READY   STATUS    RESTARTS      AGE
lvms-operator-7b9fb858cb-6nsml        3/3     Running   0             70m
topolvm-controller-5dd9cf78b5-7wwr2   5/5     Running   0             66m
topolvm-node-dr26h                    4/4     Running   0             66m
topolvm-node-54as8                    4/4     Running   0             66m
topolvm-node-78fft                    4/4     Running   17 (8s ago)   66m
vg-manager-r6zdv                      1/1     Running   0             66m
vg-manager-990ut                      1/1     Running   0             66m
vg-manager-an118                      1/1     Running   0             66m</pre>

								</p></div><p class="simpara">
								After you resolve any issues with the node, you might need to perform the forced cleanup procedure if the PVC is still stuck in a <code class="literal">Pending</code> state.
							</p></li></ul></div><div class="itemizedlist _additional-resources" id="additional-resources-forced-cleanup-1"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="#performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms" title="4.12.4.5. Performing a forced cleanup">Performing a forced cleanup</a>
							</li></ul></div></section><section class="section" id="recovering-from-disk-failure_troubleshooting-local-persistent-storage-using-lvms"><div class="titlepage"><div><div><h4 class="title">4.12.4.4. Recovering from disk failure</h4></div></div></div><p>
						If you see a failure message while inspecting the events associated with the persistent volume claim (PVC), there might be a problem with the underlying volume or disk. Disk and volume provisioning issues often result with a generic error first, such as <code class="literal">Failed to provision volume with StorageClass &lt;storage_class_name&gt;</code>. A second, more specific error message usually follows.
					</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Inspect the events associated with a PVC by running the following command:
							</p><pre class="programlisting language-terminal">$ oc describe pvc &lt;pvc_name&gt; <span id="CO58-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO58-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Replace <code class="literal">&lt;pvc_name&gt;</code> with the name of the PVC. Here are some examples of disk or volume failure error messages and their causes:
									</div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
												<span class="strong strong"><strong>Failed to check volume existence:</strong></span> Indicates a problem in verifying whether the volume already exists. Volume verification failure can be caused by network connectivity problems or other failures.
											</li><li class="listitem">
												<span class="strong strong"><strong>Failed to bind volume:</strong></span> Failure to bind a volume can happen if the persistent volume (PV) that is available does not match the requirements of the PVC.
											</li><li class="listitem">
												<span class="strong strong"><strong>FailedMount or FailedUnMount:</strong></span> This error indicates problems when trying to mount the volume to a node or unmount a volume from a node. If the disk has failed, this error might appear when a pod tries to use the PVC.
											</li><li class="listitem">
												<span class="strong strong"><strong>Volume is already exclusively attached to one node and can’t be attached to another:</strong></span> This error can appear with storage solutions that do not support <code class="literal">ReadWriteMany</code> access modes.
											</li></ul></div></dd></dl></div></li><li class="listitem">
								Establish a direct connection to the host where the problem is occurring.
							</li><li class="listitem">
								Resolve the disk issue.
							</li></ol></div><p>
						After you have resolved the issue with the disk, you might need to perform the forced cleanup procedure if failure messages persist or reoccur.
					</p><div class="itemizedlist _additional-resources" id="additional-resources-forced-cleanup-2"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="#performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms" title="4.12.4.5. Performing a forced cleanup">Performing a forced cleanup</a>
							</li></ul></div></section><section class="section" id="performing-a-forced-cleanup_troubleshooting-local-persistent-storage-using-lvms"><div class="titlepage"><div><div><h4 class="title">4.12.4.5. Performing a forced cleanup</h4></div></div></div><p>
						If disk- or node-related problems persist after you complete the troubleshooting procedures, it might be necessary to perform a forced cleanup procedure. A forced cleanup is used to comprehensively address persistent issues and ensure the proper functioning of the LVMS.
					</p><div class="orderedlist"><p class="title"><strong>Prerequisites</strong></p><ol class="orderedlist" type="1"><li class="listitem">
								All of the persistent volume claims (PVCs) created using the logical volume manager storage (LVMS) driver have been removed.
							</li><li class="listitem">
								The pods using those PVCs have been stopped.
							</li></ol></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Switch to the <code class="literal">openshift-storage</code> namespace by running the following command:
							</p><pre class="programlisting language-terminal">$ oc project openshift-storage</pre></li><li class="listitem"><p class="simpara">
								Ensure there is no <code class="literal">Logical Volume</code> custom resource (CR) remaining by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get logicalvolume</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">No resources found</pre>

								</p></div><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
										If there are any <code class="literal">LogicalVolume</code> CRs remaining, remove their finalizers by running the following command:
									</p><pre class="programlisting language-terminal">$ oc patch logicalvolume &lt;name&gt; -p '{"metadata":{"finalizers":[]}}' --type=merge <span id="CO59-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO59-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												Replace <code class="literal">&lt;name&gt;</code> with the name of the CR.
											</div></dd></dl></div></li><li class="listitem"><p class="simpara">
										After removing their finalizers, delete the CRs by running the following command:
									</p><pre class="programlisting language-terminal">$ oc delete logicalvolume &lt;name&gt; <span id="CO60-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO60-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												Replace <code class="literal">&lt;name&gt;</code> with the name of the CR.
											</div></dd></dl></div></li></ol></div></li><li class="listitem"><p class="simpara">
								Make sure there are no <code class="literal">LVMVolumeGroup</code> CRs left by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get lvmvolumegroup</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">No resources found</pre>

								</p></div><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem"><p class="simpara">
										If there are any <code class="literal">LVMVolumeGroup</code> CRs left, remove their finalizers by running the following command:
									</p><pre class="programlisting language-terminal">$ oc patch lvmvolumegroup &lt;name&gt; -p '{"metadata":{"finalizers":[]}}' --type=merge <span id="CO61-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO61-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												Replace <code class="literal">&lt;name&gt;</code> with the name of the CR.
											</div></dd></dl></div></li><li class="listitem"><p class="simpara">
										After removing their finalizers, delete the CRs by running the following command:
									</p><pre class="programlisting language-terminal">$ oc delete lvmvolumegroup &lt;name&gt; <span id="CO62-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO62-1"><span class="callout">1</span></a> </dt><dd><div class="para">
												Replace <code class="literal">&lt;name&gt;</code> with the name of the CR.
											</div></dd></dl></div></li></ol></div></li><li class="listitem"><p class="simpara">
								Remove any <code class="literal">LVMVolumeGroupNodeStatus</code> CRs by running the following command:
							</p><pre class="programlisting language-terminal">$ oc delete lvmvolumegroupnodestatus --all</pre></li><li class="listitem"><p class="simpara">
								Remove the <code class="literal">LVMCluster</code> CR by running the following command:
							</p><pre class="programlisting language-terminal">$ oc delete lvmcluster --all</pre></li></ol></div></section></section></section></section><section class="chapter" id="using-container-storage-interface-csi"><div class="titlepage"><div><div><h1 class="title">Chapter 5. Using Container Storage Interface (CSI)</h1></div></div></div><section class="section" id="persistent-storage-csi"><div class="titlepage"><div><div><h2 class="title">5.1. Configuring CSI volumes</h2></div></div></div><p>
				The Container Storage Interface (CSI) allows OpenShift Container Platform to consume storage from storage back ends that implement the <a class="link" href="https://github.com/container-storage-interface/spec">CSI interface</a> as persistent storage.
			</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					OpenShift Container Platform 4.13 supports version 1.6.0 of the <a class="link" href="https://github.com/container-storage-interface/spec">CSI specification</a>.
				</p></div></div><section class="section" id="persistent-storage-csi-architecture_persistent-storage-csi"><div class="titlepage"><div><div><h3 class="title">5.1.1. CSI architecture</h3></div></div></div><p>
					CSI drivers are typically shipped as container images. These containers are not aware of OpenShift Container Platform where they run. To use CSI-compatible storage back end in OpenShift Container Platform, the cluster administrator must deploy several components that serve as a bridge between OpenShift Container Platform and the storage driver.
				</p><p>
					The following diagram provides a high-level overview about the components running in pods in the OpenShift Container Platform cluster.
				</p><div class="informalfigure"><div class="mediaobject"><img src="https://access.redhat.com/webassets/avalon/d/OpenShift_Container_Platform-4.13-Storage-en-US/images/8984f70396bee6fae4a769322f541eab/csi-arch-rev1.png" alt="Architecture of CSI components"/></div></div><p>
					It is possible to run multiple CSI drivers for different storage back ends. Each driver needs its own external controllers deployment and daemon set with the driver and CSI registrar.
				</p><section class="section" id="external-csi-contollers_persistent-storage-csi"><div class="titlepage"><div><div><h4 class="title">5.1.1.1. External CSI controllers</h4></div></div></div><p>
						External CSI controllers is a deployment that deploys one or more pods with five containers:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The snapshotter container watches <code class="literal">VolumeSnapshot</code> and <code class="literal">VolumeSnapshotContent</code> objects and is responsible for the creation and deletion of <code class="literal">VolumeSnapshotContent</code> object.
							</li><li class="listitem">
								The resizer container is a sidecar container that watches for <code class="literal">PersistentVolumeClaim</code> updates and triggers <code class="literal">ControllerExpandVolume</code> operations against a CSI endpoint if you request more storage on <code class="literal">PersistentVolumeClaim</code> object.
							</li><li class="listitem">
								An external CSI attacher container translates <code class="literal">attach</code> and <code class="literal">detach</code> calls from OpenShift Container Platform to respective <code class="literal">ControllerPublish</code> and <code class="literal">ControllerUnpublish</code> calls to the CSI driver.
							</li><li class="listitem">
								An external CSI provisioner container that translates <code class="literal">provision</code> and <code class="literal">delete</code> calls from OpenShift Container Platform to respective <code class="literal">CreateVolume</code> and <code class="literal">DeleteVolume</code> calls to the CSI driver.
							</li><li class="listitem">
								A CSI driver container.
							</li></ul></div><p>
						The CSI attacher and CSI provisioner containers communicate with the CSI driver container using UNIX Domain Sockets, ensuring that no CSI communication leaves the pod. The CSI driver is not accessible from outside of the pod.
					</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The <code class="literal">attach</code>, <code class="literal">detach</code>, <code class="literal">provision</code>, and <code class="literal">delete</code> operations typically require the CSI driver to use credentials to the storage backend. Run the CSI controller pods on infrastructure nodes so the credentials are never leaked to user processes, even in the event of a catastrophic security breach on a compute node.
						</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							The external attacher must also run for CSI drivers that do not support third-party <code class="literal">attach</code> or <code class="literal">detach</code> operations. The external attacher will not issue any <code class="literal">ControllerPublish</code> or <code class="literal">ControllerUnpublish</code> operations to the CSI driver. However, it still must run to implement the necessary OpenShift Container Platform attachment API.
						</p></div></div></section><section class="section" id="csi-driver-daemonset_persistent-storage-csi"><div class="titlepage"><div><div><h4 class="title">5.1.1.2. CSI driver daemon set</h4></div></div></div><p>
						The CSI driver daemon set runs a pod on every node that allows OpenShift Container Platform to mount storage provided by the CSI driver to the node and use it in user workloads (pods) as persistent volumes (PVs). The pod with the CSI driver installed contains the following containers:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								A CSI driver registrar, which registers the CSI driver into the <code class="literal">openshift-node</code> service running on the node. The <code class="literal">openshift-node</code> process running on the node then directly connects with the CSI driver using the UNIX Domain Socket available on the node.
							</li><li class="listitem">
								A CSI driver.
							</li></ul></div><p>
						The CSI driver deployed on the node should have as few credentials to the storage back end as possible. OpenShift Container Platform will only use the node plugin set of CSI calls such as <code class="literal">NodePublish</code>/<code class="literal">NodeUnpublish</code> and <code class="literal">NodeStage</code>/<code class="literal">NodeUnstage</code>, if these calls are implemented.
					</p></section></section><section class="section" id="csi-drivers-supported_persistent-storage-csi"><div class="titlepage"><div><div><h3 class="title">5.1.2. CSI drivers supported by OpenShift Container Platform</h3></div></div></div><p>
					OpenShift Container Platform installs certain CSI drivers by default, giving users storage options that are not possible with in-tree volume plugins.
				</p><p>
					To create CSI-provisioned persistent volumes that mount to these supported storage assets, OpenShift Container Platform installs the necessary CSI driver Operator, the CSI driver, and the required storage class by default. For more details about the default namespace of the Operator and driver, see the documentation for the specific CSI Driver Operator.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						The AWS EFS and GCP Filestore CSI drivers are not installed by default, and must be installed manually. For instructions on installing the AWS EFS CSI driver, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_dedicated/4/html/storage/using-container-storage-interface-csi#osd-persistent-storage-aws-efs-csi">Setting up AWS Elastic File Service CSI Driver Operator</a>. For instructions on installing the GCP Filestore CSI driver, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html/storage/using-container-storage-interface-csi#persistent-storage-csi-google-cloud-file-overview">Google Compute Platform Filestore CSI Driver Operator</a>.
					</p></div></div><p>
					The following table describes the CSI drivers that are installed with OpenShift Container Platform supported by OpenShift Container Platform and which CSI features they support, such as volume snapshots and resize.
				</p><div class="table" id="idm140001856226720"><p class="title"><strong>Table 5.1. Supported CSI drivers and features in OpenShift Container Platform</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 20%; " class="col_1"><!--Empty--></col><col style="width: 20%; " class="col_2"><!--Empty--></col><col style="width: 20%; " class="col_3"><!--Empty--></col><col style="width: 20%; " class="col_4"><!--Empty--></col><col style="width: 20%; " class="col_5"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001853748160" scope="col">CSI driver</th><th align="center" valign="top" id="idm140001853747072" scope="col">CSI volume snapshots</th><th align="center" valign="top" id="idm140001853745984" scope="col">CSI cloning</th><th align="center" valign="top" id="idm140001853744896" scope="col">CSI resize</th><th align="center" valign="top" id="idm140001853743808" scope="col">Inline ephemeral volumes</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									AliCloud Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									AWS EBS
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									AWS EFS
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									Google Compute Platform (GCP) persistent disk (PD)
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									GCP Filestore
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									IBM Power Virtual Server Block
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									IBM VPC Block
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅<sup>[3]</sup></p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅<sup>[3]</sup></p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									Microsoft Azure Disk
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									Microsoft Azure Stack Hub
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									Microsoft Azure File
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									OpenStack Cinder
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									OpenShift Data Foundation
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									OpenStack Manila
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									Red Hat Virtualization (oVirt)
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									Shared Resource
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> ✅</p></div>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001853748160"> <p>
									VMware vSphere
								</p>
								 </td><td align="center" valign="top" headers="idm140001853747072">
<div class="literallayout"><p> ✅<sup>[1]</sup></p></div>
								 </td><td align="center" valign="top" headers="idm140001853745984">
<div class="literallayout"><p> -</p></div>
								 </td><td align="center" valign="top" headers="idm140001853744896">
<div class="literallayout"><p> ✅<sup>[2]</sup></p></div>
								 </td><td align="center" valign="top" headers="idm140001853743808">
<div class="literallayout"><p> -</p></div>
								 </td></tr></tbody></table></div></div><p>
					1.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Requires vSphere version 7.0 Update 3 or later for both vCenter Server and ESXi.
						</li><li class="listitem">
							Does not support fileshare volumes.
						</li></ul></div><p>
					2.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Offline volume expansion: minimum required vSphere version is 6.7 Update 3 P06
						</li><li class="listitem">
							Online volume expansion: minimum required vSphere version is 7.0 Update 2.
						</li></ul></div><p>
					3.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Does not support offline snapshots or resize. Volume must be attached to a running pod.
						</li></ul></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						If your CSI driver is not listed in the preceding table, you must follow the installation instructions provided by your CSI storage vendor to use their supported CSI features.
					</p></div></div></section><section class="section" id="csi-dynamic-provisioning_persistent-storage-csi"><div class="titlepage"><div><div><h3 class="title">5.1.3. Dynamic provisioning</h3></div></div></div><p>
					Dynamic provisioning of persistent storage depends on the capabilities of the CSI driver and underlying storage back end. The provider of the CSI driver should document how to create a storage class in OpenShift Container Platform and the parameters available for configuration.
				</p><p>
					The created storage class can be configured to enable dynamic provisioning.
				</p><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Create a default storage class that ensures all PVCs that do not require any special storage class are provisioned by the installed CSI driver.
						</p><pre class="programlisting language-shell"># oc create -f - &lt;&lt; EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class&gt; <span id="CO63-1"><!--Empty--></span><span class="callout">1</span>
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
provisioner: &lt;provisioner-name&gt; <span id="CO63-2"><!--Empty--></span><span class="callout">2</span>
parameters:
EOF</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO63-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the storage class that will be created.
								</div></dd><dt><a href="#CO63-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The name of the CSI driver that has been installed.
								</div></dd></dl></div></li></ul></div></section><section class="section" id="csi-example-usage_persistent-storage-csi"><div class="titlepage"><div><div><h3 class="title">5.1.4. Example using the CSI driver</h3></div></div></div><p>
					The following example installs a default MySQL template without any changes to the template.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							The CSI driver has been deployed.
						</li><li class="listitem">
							A storage class has been created for dynamic provisioning.
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Create the MySQL template:
						</p><pre class="programlisting language-terminal"># oc new-app mysql-persistent</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">--&gt; Deploying template "openshift/mysql-persistent" to project default
...</pre>

							</p></div><pre class="programlisting language-terminal"># oc get pvc</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME              STATUS    VOLUME                                   CAPACITY
ACCESS MODES   STORAGECLASS   AGE
mysql             Bound     kubernetes-dynamic-pv-3271ffcb4e1811e8   1Gi
RWO            cinder         3s</pre>

							</p></div></li></ul></div></section><section class="section" id="persistent-storage-csi-vol-populator_persistent-storage-csi"><div class="titlepage"><div><div><h3 class="title">5.1.5. Volume populators</h3></div></div></div><p>
					Volume populators use the <code class="literal">datasource</code> field in a persistent volume claim (PVC) spec to create pre-populated volumes.
				</p><p>
					Volume population is currently enabled, and supported as a Technology Preview feature. However, OpenShift Container Platform does not ship with any volume populators.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Volume populators is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
					</p><p>
						For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
					</p></div></div><p>
					For more information about volume populators, see <a class="link" href="https://kubernetes.io/blog/2022/05/16/volume-populators-beta/">Kubernetes volume populators</a>.
				</p></section></section><section class="section" id="ephemeral-storage-csi-inline"><div class="titlepage"><div><div><h2 class="title">5.2. CSI inline ephemeral volumes</h2></div></div></div><p>
				Container Storage Interface (CSI) inline ephemeral volumes allow you to define a <code class="literal">Pod</code> spec that creates inline ephemeral volumes when a pod is deployed and delete them when a pod is destroyed.
			</p><p>
				This feature is only available with supported Container Storage Interface (CSI) drivers: * Shared Resource CSI driver * Azure File CSI driver
			</p><section class="section" id="ephemeral-storage-csi-inline-overview_ephemeral-storage-csi-inline"><div class="titlepage"><div><div><h3 class="title">5.2.1. Overview of CSI inline ephemeral volumes</h3></div></div></div><p>
					Traditionally, volumes that are backed by Container Storage Interface (CSI) drivers can only be used with a <code class="literal">PersistentVolume</code> and <code class="literal">PersistentVolumeClaim</code> object combination.
				</p><p>
					This feature allows you to specify CSI volumes directly in the <code class="literal">Pod</code> specification, rather than in a <code class="literal">PersistentVolume</code> object. Inline volumes are ephemeral and do not persist across pod restarts.
				</p><section class="section" id="support-limitations"><div class="titlepage"><div><div><h4 class="title">5.2.1.1. Support limitations</h4></div></div></div><p>
						By default, OpenShift Container Platform supports CSI inline ephemeral volumes with these limitations:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Support is only available for CSI drivers. In-tree and FlexVolumes are not supported.
							</li><li class="listitem">
								The Shared Resource CSI Driver supports using inline ephemeral volumes only to access <code class="literal">Secrets</code> or <code class="literal">ConfigMaps</code> across multiple namespaces as a Technology Preview feature.
							</li><li class="listitem">
								Community or storage vendors provide other CSI drivers that support these volumes. Follow the installation instructions provided by the CSI driver provider.
							</li></ul></div><p>
						CSI drivers might not have implemented the inline volume functionality, including <code class="literal">Ephemeral</code> capacity. For details, see the CSI driver documentation.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Shared Resource CSI Driver is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
						</p><p>
							For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
						</p></div></div></section></section><section class="section" id="ephemeral-storage-csi-overview-admin-plugin_ephemeral-storage-csi-inline"><div class="titlepage"><div><div><h3 class="title">5.2.2. CSI Volume Admission plugin</h3></div></div></div><p>
					The Container Storage Interface (CSI) Volume Admission plugin allows you to restrict the use of an individual CSI driver capable of provisioning CSI ephemeral volumes on pod admission. Administrators can add a <code class="literal">csi-ephemeral-volume-profile</code> label, and this label is then inspected by the Admission plugin and used in enforcement, warning, and audit decisions.
				</p><section class="section" id="overview-admission-plugin"><div class="titlepage"><div><div><h4 class="title">5.2.2.1. Overview</h4></div></div></div><p>
						To use the CSI Volume Admission plugin, administrators add the <code class="literal">security.openshift.io/csi-ephemeral-volume-profile</code> label to a <code class="literal">CSIDriver</code> object, which declares the CSI driver’s effective pod security profile when it is used to provide CSI ephemeral volumes, as shown in the following example:
					</p><pre class="programlisting language-yaml">kind: CSIDriver
metadata:
  name: csi.mydriver.company.org
  labels:
    security.openshift.io/csi-ephemeral-volume-profile: restricted <span id="CO64-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO64-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								CSI driver object YAML file with the <code class="literal">csi-ephemeral-volume-profile</code> label set to "restricted"
							</div></dd></dl></div><p>
						This “effective profile” communicates that a pod can use the CSI driver to mount CSI ephemeral volumes when the pod’s namespace is governed by a pod security standard.
					</p><p>
						The CSI Volume Admission plugin inspects pod volumes when pods are created; existing pods that use CSI volumes are not affected. If a pod uses a container storage interface (CSI) volume, the plugin looks up the <code class="literal">CSIDriver</code> object and inspects the <code class="literal">csi-ephemeral-volume-profile</code> label, and then use the label’s value in its enforcement, warning, and audit decisions.
					</p></section><section class="section" id="security-profile-enforcement"><div class="titlepage"><div><div><h4 class="title">5.2.2.2. Pod security profile enforcement</h4></div></div></div><p>
						When a CSI driver has the <code class="literal">csi-ephemeral-volume-profile</code> label, pods using the CSI driver to mount CSI ephemeral volumes must run in a namespace that enforces a pod security standard of equal or greater permission. If the namespace enforces a more restrictive standard, the CSI Volume Admission plugin denies admission. The following table describes the enforcement behavior for different pod security profiles for given label values.
					</p><div class="table" id="idm140001855999616"><p class="title"><strong>Table 5.2. Pod security profile enforcement</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 25%; " class="col_1"><!--Empty--></col><col style="width: 25%; " class="col_2"><!--Empty--></col><col style="width: 25%; " class="col_3"><!--Empty--></col><col style="width: 25%; " class="col_4"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001852429856" scope="col">Pod security profile</th><th align="center" valign="top" id="idm140001852428768" scope="col">Driver label: restricted</th><th align="center" valign="top" id="idm140001852427664" scope="col">Driver label: baseline</th><th align="center" valign="top" id="idm140001852426576" scope="col">Driver label: privileged</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001852429856"> <p>
										Restricted
									</p>
									 </td><td align="center" valign="top" headers="idm140001852428768">
<div class="literallayout"><p>Allowed</p></div>
									 </td><td align="center" valign="top" headers="idm140001852427664">
<div class="literallayout"><p>Denied</p></div>
									 </td><td align="center" valign="top" headers="idm140001852426576">
<div class="literallayout"><p>Denied</p></div>
									 </td></tr><tr><td align="left" valign="top" headers="idm140001852429856"> <p>
										Baseline
									</p>
									 </td><td align="center" valign="top" headers="idm140001852428768">
<div class="literallayout"><p>Allowed</p></div>
									 </td><td align="center" valign="top" headers="idm140001852427664">
<div class="literallayout"><p>Allowed</p></div>
									 </td><td align="center" valign="top" headers="idm140001852426576">
<div class="literallayout"><p>Denied</p></div>
									 </td></tr><tr><td align="left" valign="top" headers="idm140001852429856"> <p>
										Privileged
									</p>
									 </td><td align="center" valign="top" headers="idm140001852428768">
<div class="literallayout"><p>Allowed</p></div>
									 </td><td align="center" valign="top" headers="idm140001852427664">
<div class="literallayout"><p>Allowed</p></div>
									 </td><td align="center" valign="top" headers="idm140001852426576">
<div class="literallayout"><p>Allowed</p></div>
									 </td></tr></tbody></table></div></div></section><section class="section" id="security-profile-warning"><div class="titlepage"><div><div><h4 class="title">5.2.2.3. Pod security profile warning</h4></div></div></div><p>
						The CSI Volume Admission plugin can warn you if the CSI driver’s effective profile is more permissive than the pod security warning profile for the pod namespace. The following table shows when a warning occurs for different pod security profiles for given label values.
					</p><div class="table" id="idm140001853772624"><p class="title"><strong>Table 5.3. Pod security profile warning</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 25%; " class="col_1"><!--Empty--></col><col style="width: 25%; " class="col_2"><!--Empty--></col><col style="width: 25%; " class="col_3"><!--Empty--></col><col style="width: 25%; " class="col_4"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001853765920" scope="col">Pod security profile</th><th align="center" valign="top" id="idm140001853764832" scope="col">Driver label: restricted</th><th align="center" valign="top" id="idm140001853763728" scope="col">Driver label: baseline</th><th align="center" valign="top" id="idm140001853762640" scope="col">Driver label: privileged</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001853765920"> <p>
										Restricted
									</p>
									 </td><td align="center" valign="top" headers="idm140001853764832">
<div class="literallayout"><p>No warning</p></div>
									 </td><td align="center" valign="top" headers="idm140001853763728">
<div class="literallayout"><p>Warning</p></div>
									 </td><td align="center" valign="top" headers="idm140001853762640">
<div class="literallayout"><p>Warning</p></div>
									 </td></tr><tr><td align="left" valign="top" headers="idm140001853765920"> <p>
										Baseline
									</p>
									 </td><td align="center" valign="top" headers="idm140001853764832">
<div class="literallayout"><p>No warning</p></div>
									 </td><td align="center" valign="top" headers="idm140001853763728">
<div class="literallayout"><p>No warning</p></div>
									 </td><td align="center" valign="top" headers="idm140001853762640">
<div class="literallayout"><p>Warning</p></div>
									 </td></tr><tr><td align="left" valign="top" headers="idm140001853765920"> <p>
										Privileged
									</p>
									 </td><td align="center" valign="top" headers="idm140001853764832">
<div class="literallayout"><p>No warning</p></div>
									 </td><td align="center" valign="top" headers="idm140001853763728">
<div class="literallayout"><p>No warning</p></div>
									 </td><td align="center" valign="top" headers="idm140001853762640">
<div class="literallayout"><p>No warning</p></div>
									 </td></tr></tbody></table></div></div></section><section class="section" id="security-profile-audit"><div class="titlepage"><div><div><h4 class="title">5.2.2.4. Pod security profile audit</h4></div></div></div><p>
						The CSI Volume Admission plugin can apply audit annotations to the pod if the CSI driver’s effective profile is more permissive than the pod security audit profile for the pod namespace. The following table shows the audit annotation applied for different pod security profiles for given label values.
					</p><div class="table" id="idm140001853603040"><p class="title"><strong>Table 5.4. Pod security profile audit</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 25%; " class="col_1"><!--Empty--></col><col style="width: 25%; " class="col_2"><!--Empty--></col><col style="width: 25%; " class="col_3"><!--Empty--></col><col style="width: 25%; " class="col_4"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001855861824" scope="col">Pod security profile</th><th align="center" valign="top" id="idm140001855860736" scope="col">Driver label: restricted</th><th align="center" valign="top" id="idm140001855859632" scope="col">Driver label: baseline</th><th align="center" valign="top" id="idm140001855858544" scope="col">Driver label: privileged</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001855861824"> <p>
										Restricted
									</p>
									 </td><td align="center" valign="top" headers="idm140001855860736">
<div class="literallayout"><p>No audit</p></div>
									 </td><td align="center" valign="top" headers="idm140001855859632">
<div class="literallayout"><p>Audit</p></div>
									 </td><td align="center" valign="top" headers="idm140001855858544">
<div class="literallayout"><p>Audit</p></div>
									 </td></tr><tr><td align="left" valign="top" headers="idm140001855861824"> <p>
										Baseline
									</p>
									 </td><td align="center" valign="top" headers="idm140001855860736">
<div class="literallayout"><p>No audit</p></div>
									 </td><td align="center" valign="top" headers="idm140001855859632">
<div class="literallayout"><p>No audit</p></div>
									 </td><td align="center" valign="top" headers="idm140001855858544">
<div class="literallayout"><p>Audit</p></div>
									 </td></tr><tr><td align="left" valign="top" headers="idm140001855861824"> <p>
										Privileged
									</p>
									 </td><td align="center" valign="top" headers="idm140001855860736">
<div class="literallayout"><p>No audit</p></div>
									 </td><td align="center" valign="top" headers="idm140001855859632">
<div class="literallayout"><p>No audit</p></div>
									 </td><td align="center" valign="top" headers="idm140001855858544">
<div class="literallayout"><p>No audit</p></div>
									 </td></tr></tbody></table></div></div></section><section class="section" id="admission-plugin-default-behavior"><div class="titlepage"><div><div><h4 class="title">5.2.2.5. Default behavior for the CSI Volume Admission plugin</h4></div></div></div><p>
						If the referenced CSI driver for a CSI ephemeral volume does not have the <code class="literal">csi-ephemeral-volume-profile</code> label, the CSI Volume Admission plugin considers the driver to have the privileged profile for enforcement, warning, and audit behaviors. Likewise, if the pod’s namespace does not have the pod security admission label set, the Admission plugin assumes the restricted profile is allowed for enforcement, warning, and audit decisions. Therefore, if no labels are set, CSI ephemeral volumes using that CSI driver are only usable in privileged namespaces by default.
					</p><p>
						The CSI drivers that ship with OpenShift Container Platform and support ephemeral volumes have a reasonable default set for the <code class="literal">csi-ephemeral-volume-profile</code> label:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Shared Resource CSI driver: restricted
							</li><li class="listitem">
								Azure File CSI driver: privileged
							</li></ul></div><p>
						An admin can change the default value of the label if desired.
					</p></section></section><section class="section" id="ephemeral-storage-csi-inline-pod_ephemeral-storage-csi-inline"><div class="titlepage"><div><div><h3 class="title">5.2.3. Embedding a CSI inline ephemeral volume in the pod specification</h3></div></div></div><p>
					You can embed a CSI inline ephemeral volume in the <code class="literal">Pod</code> specification in OpenShift Container Platform. At runtime, nested inline volumes follow the ephemeral lifecycle of their associated pods so that the CSI driver handles all phases of volume operations as pods are created and destroyed.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
							Create the <code class="literal">Pod</code> object definition and save it to a file.
						</li><li class="listitem"><p class="simpara">
							Embed the CSI inline ephemeral volume in the file.
						</p><div class="formalpara"><p class="title"><strong>my-csi-app.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: my-csi-app
spec:
  containers:
    - name: my-frontend
      image: busybox
      volumeMounts:
      - mountPath: "/data"
        name: my-csi-inline-vol
      command: [ "sleep", "1000000" ]
  volumes: <span id="CO65-1"><!--Empty--></span><span class="callout">1</span>
    - name: my-csi-inline-vol
      csi:
        driver: inline.storage.kubernetes.io
        volumeAttributes:
          foo: bar</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO65-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the volume that is used by pods.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create the object definition file that you saved in the previous step.
						</p><pre class="programlisting language-terminal">$ oc create -f my-csi-app.yaml</pre></li></ol></div></section><section class="section _additional-resources" id="additional-resources_ephemeral-storage-csi-inline"><div class="titlepage"><div><div><h3 class="title">5.2.4. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://kubernetes.io/docs/concepts/security/pod-security-standards/">Pod Security Standards</a>
						</li></ul></div></section></section><section class="section" id="ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h2 class="title">5.3. Shared Resource CSI Driver Operator</h2></div></div></div><p class="_abstract _abstract">
				As a cluster administrator, you can use the Shared Resource CSI Driver in OpenShift Container Platform to provision inline ephemeral volumes that contain the contents of <code class="literal">Secret</code> or <code class="literal">ConfigMap</code> objects. This way, pods and other Kubernetes types that expose volume mounts, and OpenShift Container Platform Builds can securely use the contents of those objects across potentially any namespace in the cluster. To accomplish this, there are currently two types of shared resources: a <code class="literal">SharedSecret</code> custom resource for <code class="literal">Secret</code> objects, and a <code class="literal">SharedConfigMap</code> custom resource for <code class="literal">ConfigMap</code> objects.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					The Shared Resource CSI Driver is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
				</p><p>
					For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
				</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					To enable the Shared Resource CSI Driver, you must <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/nodes/#nodes-cluster-enabling">enable features using feature gates</a>.
				</p></div></div><section class="section" id="csi-about_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.1. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section" id="ephemeral-storage-sharing-secrets-across-namespaces_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.2. Sharing secrets across namespaces</h3></div></div></div><p class="_abstract _abstract">
					To share a secret across namespaces in a cluster, you create a <code class="literal">SharedSecret</code> custom resource (CR) instance for the <code class="literal">Secret</code> object that you want to share.
				</p><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						You must have permission to perform the following actions:
					</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Create instances of the <code class="literal">sharedsecrets.sharedresource.openshift.io</code> custom resource definition (CRD) at a cluster-scoped level.
						</li><li class="listitem">
							Manage roles and role bindings across the namespaces in the cluster to control which users can get, list, and watch those instances.
						</li><li class="listitem">
							Manage roles and role bindings to control whether the service account specified by a pod can mount a Container Storage Interface (CSI) volume that references the <code class="literal">SharedSecret</code> CR instance you want to use.
						</li><li class="listitem">
							Access the namespaces that contain the Secrets you want to share.
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Create a <code class="literal">SharedSecret</code> CR instance for the <code class="literal">Secret</code> object you want to share across namespaces in the cluster:
						</p><pre class="programlisting language-terminal">$ oc apply -f - &lt;&lt;EOF
apiVersion: sharedresource.openshift.io/v1alpha1
kind: SharedSecret
metadata:
  name: my-share
spec:
  secretRef:
    name: &lt;name of secret&gt;
    namespace: &lt;namespace of secret&gt;
EOF</pre></li></ul></div></section><section class="section" id="ephemeral-storage-using-a-sharedsecrets-resource-in-a-pod_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.3. Using a SharedSecret instance in a pod</h3></div></div></div><p class="_abstract _abstract">
					To access a <code class="literal">SharedSecret</code> custom resource (CR) instance from a pod, you grant a given service account RBAC permissions to use that <code class="literal">SharedSecret</code> CR instance.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You have created a <code class="literal">SharedSecret</code> CR instance for the secret you want to share across namespaces in the cluster.
						</li><li class="listitem"><p class="simpara">
							You must have permission to perform the following actions
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									Discover which <code class="literal">SharedSecret</code> CR instances are available by entering the <code class="literal">oc get sharedsecrets</code> command and getting a non-empty list back.
								</li><li class="listitem">
									Determine if the service account your pod specifies is allowed to use the given <code class="literal">SharedSecret</code> CR instance. That is, you can run <code class="literal">oc adm policy who-can use &lt;identifier of specific SharedSecret&gt;</code> to see if the service account in your namespace is listed.
								</li><li class="listitem">
									Determine if the service account your pod specifies is allowed to use <code class="literal">csi</code> volumes, or if you, as the requesting user who created the pod directly, are allowed to use <code class="literal">csi</code> volumes. See "Understanding and managing pod security admission" for details.
								</li></ul></div></li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If neither of the last two prerequisites in this list are met, create, or ask someone to create, the necessary role-based access control (RBAC) so that you can discover <code class="literal">SharedSecret</code> CR instances and enable service accounts to use <code class="literal">SharedSecret</code> CR instances.
					</p></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Grant a given service account RBAC permissions to use the <code class="literal">SharedSecret</code> CR instance in its pod by using <code class="literal">oc apply</code> with YAML content:
						</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Currently, <code class="literal">kubectl</code> and <code class="literal">oc</code> have hard-coded special case logic restricting the <code class="literal">use</code> verb to roles centered around pod security. Therefore, you cannot use <code class="literal">oc create role …​</code> to create the role needed for consuming <code class="literal">SharedSecret</code> CR instances.
							</p></div></div><pre class="programlisting language-terminal">$ oc apply -f - &lt;&lt;EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: shared-resource-my-share
  namespace: my-namespace
rules:
  - apiGroups:
      - sharedresource.openshift.io
    resources:
      - sharedsecrets
    resourceNames:
      - my-share
    verbs:
      - use
EOF</pre></li><li class="listitem"><p class="simpara">
							Create the <code class="literal">RoleBinding</code> associated with the role by using the <code class="literal">oc</code> command:
						</p><pre class="programlisting language-terminal">$ oc create rolebinding shared-resource-my-share --role=shared-resource-my-share --serviceaccount=my-namespace:builder</pre></li><li class="listitem"><p class="simpara">
							Access the <code class="literal">SharedSecret</code> CR instance from a pod:
						</p><pre class="programlisting language-terminal">$ oc apply -f - &lt;&lt;EOF
kind: Pod
apiVersion: v1
metadata:
  name: my-app
  namespace: my-namespace
spec:
  serviceAccountName: default

# containers omitted …. Follow standard use of ‘volumeMounts’ for referencing your shared resource volume

    volumes:
    - name: my-csi-volume
      csi:
        readOnly: true
        driver: csi.sharedresource.openshift.io
        volumeAttributes:
          sharedSecret: my-share

EOF</pre></li></ol></div></section><section class="section" id="ephemeral-storage-sharing-configmaps-across-namespaces_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.4. Sharing a config map across namespaces</h3></div></div></div><p class="_abstract _abstract">
					To share a config map across namespaces in a cluster, you create a <code class="literal">SharedConfigMap</code> custom resource (CR) instance for that config map.
				</p><div class="formalpara"><p class="title"><strong>Prerequisites</strong></p><p>
						You must have permission to perform the following actions:
					</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Create instances of the <code class="literal">sharedconfigmaps.sharedresource.openshift.io</code> custom resource definition (CRD) at a cluster-scoped level.
						</li><li class="listitem">
							Manage roles and role bindings across the namespaces in the cluster to control which users can get, list, and watch those instances.
						</li><li class="listitem">
							Manage roles and role bindings across the namespaces in the cluster to control which service accounts in pods that mount your Container Storage Interface (CSI) volume can use those instances.
						</li><li class="listitem">
							Access the namespaces that contain the Secrets you want to share.
						</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a <code class="literal">SharedConfigMap</code> CR instance for the config map that you want to share across namespaces in the cluster:
						</p><pre class="programlisting language-terminal">$ oc apply -f - &lt;&lt;EOF
apiVersion: sharedresource.openshift.io/v1alpha1
kind: SharedConfigMap
metadata:
  name: my-share
spec:
  configMapRef:
    name: &lt;name of configmap&gt;
    namespace: &lt;namespace of configmap&gt;
EOF</pre></li></ol></div></section><section class="section" id="ephemeral-storage-using-a-sharedconfigmap-object-in-a-pod_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.5. Using a SharedConfigMap instance in a pod</h3></div></div></div><div class="_abstract _abstract"><p class="title"><strong>Next steps</strong></p><p>
						To access a <code class="literal">SharedConfigMap</code> custom resource (CR) instance from a pod, you grant a given service account RBAC permissions to use that <code class="literal">SharedConfigMap</code> CR instance.
					</p></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You have created a <code class="literal">SharedConfigMap</code> CR instance for the config map that you want to share across namespaces in the cluster.
						</li><li class="listitem"><p class="simpara">
							You must have permission to perform the following actions:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									Discover which <code class="literal">SharedConfigMap</code> CR instances are available by entering the <code class="literal">oc get sharedconfigmaps</code> command and getting a non-empty list back.
								</li><li class="listitem">
									Determine if the service account your pod specifies is allowed to use the given <code class="literal">SharedSecret</code> CR instance. That is, you can run <code class="literal">oc adm policy who-can use &lt;identifier of specific SharedSecret&gt;</code> to see if the service account in your namespace is listed.
								</li><li class="listitem">
									Determine if the service account your pod specifies is allowed to use <code class="literal">csi</code> volumes, or if you, as the requesting user who created the pod directly, are allowed to use <code class="literal">csi</code> volumes. See "Understanding and managing pod security admission" for details.
								</li></ul></div></li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If neither of the last two prerequisites in this list are met, create, or ask someone to create, the necessary role-based access control (RBAC) so that you can discover <code class="literal">SharedConfigMap</code> CR instances and enable service accounts to use <code class="literal">SharedConfigMap</code> CR instances.
					</p></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Grant a given service account RBAC permissions to use the <code class="literal">SharedConfigMap</code> CR instance in its pod by using <code class="literal">oc apply</code> with YAML content.
						</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Currently, <code class="literal">kubectl</code> and <code class="literal">oc</code> have hard-coded special case logic restricting the <code class="literal">use</code> verb to roles centered around pod security. Therefore, you cannot use <code class="literal">oc create role …​</code> to create the role needed for consuming a <code class="literal">SharedConfigMap</code> CR instance.
							</p></div></div><pre class="programlisting language-terminal">$ oc apply -f - &lt;&lt;EOF
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: shared-resource-my-share
  namespace: my-namespace
rules:
  - apiGroups:
      - sharedresource.openshift.io
    resources:
      - sharedconfigmaps
    resourceNames:
      - my-share
    verbs:
      - use
EOF</pre></li><li class="listitem"><p class="simpara">
							Create the <code class="literal">RoleBinding</code> associated with the role by using the <code class="literal">oc</code> command:
						</p><pre class="programlisting language-terminal">oc create rolebinding shared-resource-my-share --role=shared-resource-my-share --serviceaccount=my-namespace:builder</pre></li><li class="listitem"><p class="simpara">
							Access the <code class="literal">SharedConfigMap</code> CR instance from a pod:
						</p><pre class="programlisting language-terminal">$ oc apply -f - &lt;&lt;EOF
kind: Pod
apiVersion: v1
metadata:
  name: my-app
  namespace: my-namespace
spec:
  serviceAccountName: default

# containers omitted …. Follow standard use of ‘volumeMounts’ for referencing your shared resource volume

    volumes:
    - name: my-csi-volume
      csi:
        readOnly: true
        driver: csi.sharedresource.openshift.io
        volumeAttributes:
          sharedConfigMap: my-share

EOF</pre></li></ol></div></section><section class="section" id="ephemeral-storage-additional-support-limitations-for-shared-resource-csi-driver_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.6. Additional support limitations for the Shared Resource CSI Driver</h3></div></div></div><p class="_abstract _abstract">
					The Shared Resource CSI Driver has the following noteworthy limitations:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The driver is subject to the limitations of Container Storage Interface (CSI) inline ephemeral volumes.
						</li><li class="listitem">
							The value of the <code class="literal">readOnly</code> field must be <code class="literal">true</code>. On <code class="literal">Pod</code> creation, a validating admission webhook rejects the pod creation if <code class="literal">readOnly</code> is <code class="literal">false</code>. If for some reason the validating admission webhook cannot be contacted, on volume provisioning during pod startup, the driver returns an error to the kubelet. Requiring <code class="literal">readOnly</code> is <code class="literal">true</code> is in keeping with proposed best practices for the upstream Kubernetes CSI Driver to apply SELinux labels to associated volumes.
						</li><li class="listitem">
							The driver ignores the <code class="literal">FSType</code> field because it only supports <code class="literal">tmpfs</code> volumes.
						</li><li class="listitem">
							The driver ignores the <code class="literal">NodePublishSecretRef</code> field. Instead, it uses <code class="literal">SubjectAccessReviews</code> with the <code class="literal">use</code> verb to evaluate whether a pod can obtain a volume that contains <code class="literal">SharedSecret</code> or <code class="literal">SharedConfigMap</code> custom resource (CR) instances.
						</li><li class="listitem">
							You cannot create <code class="literal">SharedSecret</code> or <code class="literal">SharedConfigMap</code> custom resource (CR) instances whose names start with <code class="literal">openshift</code>.
						</li></ul></div></section><section class="section" id="ephemeral-storage-additional-details-about-volumeattributes-on-shared-resource-pod-volumes_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.7. Additional details about VolumeAttributes on shared resource pod volumes</h3></div></div></div><p class="_abstract _abstract">
					The following attributes affect shared resource pod volumes in various ways:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <code class="literal">refreshResource</code> attribute in the <code class="literal">volumeAttributes</code> properties.
						</li><li class="listitem">
							The <code class="literal">refreshResources</code> attribute in the Shared Resource CSI Driver configuration.
						</li><li class="listitem">
							The <code class="literal">sharedSecret</code> and <code class="literal">sharedConfigMap</code> attributes in the <code class="literal">volumeAttributes</code> properties.
						</li></ul></div><section class="section" id="the-literal-refreshresource-literal-attribute"><div class="titlepage"><div><div><h4 class="title">5.3.7.1. The <code class="literal">refreshResource</code> attribute</h4></div></div></div><p>
						The Shared Resource CSI Driver honors the <code class="literal">refreshResource</code> attribute in <code class="literal">volumeAttributes</code> properties of the volume. This attribute controls whether updates to the contents of the underlying <code class="literal">Secret</code> or <code class="literal">ConfigMap</code> object are copied to the volume <span class="strong strong"><strong>after</strong></span> the volume is initially provisioned as part of pod startup. The default value of <code class="literal">refreshResource</code> is <code class="literal">true</code>, which means that the contents are updated.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							If the Shared Resource CSI Driver configuration has disabled the refreshing of both the shared <code class="literal">SharedSecret</code> and <code class="literal">SharedConfigMap</code> custom resource (CR) instances, then the <code class="literal">refreshResource</code> attribute in the <code class="literal">volumeAttribute</code> properties has no effect. The intent of this attribute is to disable refresh for specific volume mounts when refresh is generally allowed.
						</p></div></div></section><section class="section" id="the-literal-refreshresources-literal-attribute"><div class="titlepage"><div><div><h4 class="title">5.3.7.2. The <code class="literal">refreshResources</code> attribute</h4></div></div></div><p>
						You can use a global switch to enable or disable refreshing of shared resources. This switch is the <code class="literal">refreshResources</code> attribute in the <code class="literal">csi-driver-shared-resource-config</code> config map for the Shared Resource CSI Driver, which you can find in the <code class="literal">openshift-cluster-csi-drivers</code> namespace. If you set this <code class="literal">refreshResources</code> attribute to <code class="literal">false</code>, none of the <code class="literal">Secret</code> or <code class="literal">ConfigMap</code> object-related content stored in the volume is updated after the initial provisioning of the volume.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Using this Shared Resource CSI Driver configuration to disable refreshing affects all the cluster’s volume mounts that use the Shared Resource CSI Driver, regardless of the <code class="literal">refreshResource</code> attribute in the <code class="literal">volumeAttributes</code> properties of any of those volumes.
						</p></div></div></section><section class="section" id="validation-of-volumeattributes-before-provisioning-a-shared-resource-volume-for-a-pod"><div class="titlepage"><div><div><h4 class="title">5.3.7.3. Validation of volumeAttributes before provisioning a shared resource volume for a pod</h4></div></div></div><p>
						In the <code class="literal">volumeAttributes</code> of a single volume, you must set either a <code class="literal">sharedSecret</code> or a <code class="literal">sharedConfigMap</code> attribute to the value of a <code class="literal">SharedSecret</code> or a <code class="literal">SharedConfigMap</code> CS instance. Otherwise, when the volume is provisioned during pod startup, a validation checks the <code class="literal">volumeAttributes</code> of that volume and returns an error to the kubelet under the following conditions:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Both <code class="literal">sharedSecret</code> and <code class="literal">sharedConfigMap</code> attributes have specified values.
							</li><li class="listitem">
								Neither <code class="literal">sharedSecret</code> nor <code class="literal">sharedConfigMap</code> attributes have specified values.
							</li><li class="listitem">
								The value of the <code class="literal">sharedSecret</code> or <code class="literal">sharedConfigMap</code> attribute does not correspond to the name of a <code class="literal">SharedSecret</code> or <code class="literal">SharedConfigMap</code> CR instance on the cluster.
							</li></ul></div></section></section><section class="section" id="ephemeral-storage-integration-between-shared-resources-insights-operator-and-openshift-builds_ephemeral-storage-shared-resource-csi-driver-operator"><div class="titlepage"><div><div><h3 class="title">5.3.8. Integration between shared resources, Insights Operator, and OpenShift Container Platform Builds</h3></div></div></div><p class="_abstract _abstract">
					Integration between shared resources, Insights Operator, and OpenShift Container Platform Builds makes using Red Hat subscriptions (RHEL entitlements) easier in OpenShift Container Platform Builds.
				</p><p>
					Previously, in OpenShift Container Platform 4.9.x and earlier, you manually imported your credentials and copied them to each project or namespace where you were running builds.
				</p><p>
					Now, in OpenShift Container Platform 4.10 and later, OpenShift Container Platform Builds can use Red Hat subscriptions (RHEL entitlements) by referencing shared resources and the simple content access feature provided by Insights Operator:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The simple content access feature imports your subscription credentials to a well-known <code class="literal">Secret</code> object. See the links in the following "Additional resources" section.
						</li><li class="listitem">
							The cluster administrator creates a <code class="literal">SharedSecret</code> custom resource (CR) instance around that <code class="literal">Secret</code> object and grants permission to particular projects or namespaces. In particular, the cluster administrator gives the <code class="literal">builder</code> service account permission to use that <code class="literal">SharedSecret</code> CR instance.
						</li><li class="listitem">
							Builds that run within those projects or namespaces can mount a CSI Volume that references the <code class="literal">SharedSecret</code> CR instance and its entitled RHEL content.
						</li></ul></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/support/#insights-operator-simple-access">Importing simple content access certificates with Insights Operator</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/cicd/#builds-source-secrets-entitlements_running-entitled-builds">Adding subscription entitlements as a build secret</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h2 class="title">5.4. CSI volume snapshots</h2></div></div></div><p>
				This document describes how to use volume snapshots with supported Container Storage Interface (CSI) drivers to help protect against data loss in OpenShift Container Platform. Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-volumes_understanding-persistent-storage">persistent volumes</a> is suggested.
			</p><section class="section" id="persistent-storage-csi-snapshots-overview_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.1. Overview of CSI volume snapshots</h3></div></div></div><p>
					A <span class="emphasis"><em>snapshot</em></span> represents the state of the storage volume in a cluster at a particular point in time. Volume snapshots can be used to provision a new volume.
				</p><p>
					OpenShift Container Platform supports Container Storage Interface (CSI) volume snapshots by default. However, a specific CSI driver is required.
				</p><p>
					With CSI volume snapshots, a cluster administrator can:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Deploy a third-party CSI driver that supports snapshots.
						</li><li class="listitem">
							Create a new persistent volume claim (PVC) from an existing volume snapshot.
						</li><li class="listitem">
							Take a snapshot of an existing PVC.
						</li><li class="listitem">
							Restore a snapshot as a different PVC.
						</li><li class="listitem">
							Delete an existing volume snapshot.
						</li></ul></div><p>
					With CSI volume snapshots, an app developer can:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Use volume snapshots as building blocks for developing application- or cluster-level storage backup solutions.
						</li><li class="listitem">
							Rapidly rollback to a previous development version.
						</li><li class="listitem">
							Use storage more efficiently by not having to make a full copy each time.
						</li></ul></div><p>
					Be aware of the following when using volume snapshots:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Support is only available for CSI drivers. In-tree and FlexVolumes are not supported.
						</li><li class="listitem">
							OpenShift Container Platform only ships with select CSI drivers. For CSI drivers that are not provided by an OpenShift Container Platform Driver Operator, it is recommended to use the CSI drivers provided by <a class="link" href="https://kubernetes-csi.github.io/docs/drivers.html">community or storage vendors</a>. Follow the installation instructions furnished by the CSI driver provider.
						</li><li class="listitem">
							CSI drivers may or may not have implemented the volume snapshot functionality. CSI drivers that have provided support for volume snapshots will likely use the <code class="literal">csi-external-snapshotter</code> sidecar. See documentation provided by the CSI driver for details.
						</li></ul></div></section><section class="section" id="persistent-storage-csi-snapshots-controller-sidecar_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.2. CSI snapshot controller and sidecar</h3></div></div></div><p>
					OpenShift Container Platform provides a snapshot controller that is deployed into the control plane. In addition, your CSI driver vendor provides the CSI snapshot sidecar as a helper container that is installed during the CSI driver installation.
				</p><p>
					The CSI snapshot controller and sidecar provide volume snapshotting through the OpenShift Container Platform API. These external components run in the cluster.
				</p><p>
					The external controller is deployed by the CSI Snapshot Controller Operator.
				</p><section class="section" id="external-controller"><div class="titlepage"><div><div><h4 class="title">5.4.2.1. External controller</h4></div></div></div><p>
						The CSI snapshot controller binds <code class="literal">VolumeSnapshot</code> and <code class="literal">VolumeSnapshotContent</code> objects. The controller manages dynamic provisioning by creating and deleting <code class="literal">VolumeSnapshotContent</code> objects.
					</p></section><section class="section" id="external-sidecar"><div class="titlepage"><div><div><h4 class="title">5.4.2.2. External sidecar</h4></div></div></div><p>
						Your CSI driver vendor provides the <code class="literal">csi-external-snapshotter</code> sidecar. This is a separate helper container that is deployed with the CSI driver. The sidecar manages snapshots by triggering <code class="literal">CreateSnapshot</code> and <code class="literal">DeleteSnapshot</code> operations. Follow the installation instructions provided by your vendor.
					</p></section></section><section class="section" id="persistent-storage-csi-snapshots-operator_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.3. About the CSI Snapshot Controller Operator</h3></div></div></div><p>
					The CSI Snapshot Controller Operator runs in the <code class="literal">openshift-cluster-storage-operator</code> namespace. It is installed by the Cluster Version Operator (CVO) in all clusters by default.
				</p><p>
					The CSI Snapshot Controller Operator installs the CSI snapshot controller, which runs in the <code class="literal">openshift-cluster-storage-operator</code> namespace.
				</p><section class="section" id="volume-snapshot-crds"><div class="titlepage"><div><div><h4 class="title">5.4.3.1. Volume snapshot CRDs</h4></div></div></div><p>
						During OpenShift Container Platform installation, the CSI Snapshot Controller Operator creates the following snapshot custom resource definitions (CRDs) in the <code class="literal">snapshot.storage.k8s.io/v1</code> API group:
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">VolumeSnapshotContent</code></span></dt><dd><p class="simpara">
									A snapshot taken of a volume in the cluster that has been provisioned by a cluster administrator.
								</p><p class="simpara">
									Similar to the <code class="literal">PersistentVolume</code> object, the <code class="literal">VolumeSnapshotContent</code> CRD is a cluster resource that points to a real snapshot in the storage back end.
								</p><p class="simpara">
									For manually pre-provisioned snapshots, a cluster administrator creates a number of <code class="literal">VolumeSnapshotContent</code> CRDs. These carry the details of the real volume snapshot in the storage system.
								</p><p class="simpara">
									The <code class="literal">VolumeSnapshotContent</code> CRD is not namespaced and is for use by a cluster administrator.
								</p></dd><dt><span class="term"><code class="literal">VolumeSnapshot</code></span></dt><dd><p class="simpara">
									Similar to the <code class="literal">PersistentVolumeClaim</code> object, the <code class="literal">VolumeSnapshot</code> CRD defines a developer request for a snapshot. The CSI Snapshot Controller Operator runs the CSI snapshot controller, which handles the binding of a <code class="literal">VolumeSnapshot</code> CRD with an appropriate <code class="literal">VolumeSnapshotContent</code> CRD. The binding is a one-to-one mapping.
								</p><p class="simpara">
									The <code class="literal">VolumeSnapshot</code> CRD is namespaced. A developer uses the CRD as a distinct request for a snapshot.
								</p></dd><dt><span class="term"><code class="literal">VolumeSnapshotClass</code></span></dt><dd><p class="simpara">
									Allows a cluster administrator to specify different attributes belonging to a <code class="literal">VolumeSnapshot</code> object. These attributes may differ among snapshots taken of the same volume on the storage system, in which case they would not be expressed by using the same storage class of a persistent volume claim.
								</p><p class="simpara">
									The <code class="literal">VolumeSnapshotClass</code> CRD defines the parameters for the <code class="literal">csi-external-snapshotter</code> sidecar to use when creating a snapshot. This allows the storage back end to know what kind of snapshot to dynamically create if multiple options are supported.
								</p><p class="simpara">
									Dynamically provisioned snapshots use the <code class="literal">VolumeSnapshotClass</code> CRD to specify storage-provider-specific parameters to use when creating a snapshot.
								</p><p class="simpara">
									The <code class="literal">VolumeSnapshotContentClass</code> CRD is not namespaced and is for use by a cluster administrator to enable global configuration options for their storage back end.
								</p></dd></dl></div></section></section><section class="section" id="persistent-storage-csi-snapshots-provision_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.4. Volume snapshot provisioning</h3></div></div></div><p>
					There are two ways to provision snapshots: dynamically and manually.
				</p><section class="section" id="snapshots-dynamic-provisioning_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h4 class="title">5.4.4.1. Dynamic provisioning</h4></div></div></div><p>
						Instead of using a preexisting snapshot, you can request that a snapshot be taken dynamically from a persistent volume claim. Parameters are specified using a <code class="literal">VolumeSnapshotClass</code> CRD.
					</p></section><section class="section" id="snapshots-manual-provisioning_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h4 class="title">5.4.4.2. Manual provisioning</h4></div></div></div><p>
						As a cluster administrator, you can manually pre-provision a number of <code class="literal">VolumeSnapshotContent</code> objects. These carry the real volume snapshot details available to cluster users.
					</p></section></section><section class="section" id="persistent-storage-csi-snapshots-create_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.5. Creating a volume snapshot</h3></div></div></div><p>
					When you create a <code class="literal">VolumeSnapshot</code> object, OpenShift Container Platform creates a volume snapshot.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Logged in to a running OpenShift Container Platform cluster.
						</li><li class="listitem">
							A PVC created using a CSI driver that supports <code class="literal">VolumeSnapshot</code> objects.
						</li><li class="listitem">
							A storage class to provision the storage back end.
						</li><li class="listitem"><p class="simpara">
							No pods are using the persistent volume claim (PVC) that you want to take a snapshot of.
						</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Do not create a volume snapshot of a PVC if a pod is using it. Doing so might cause data corruption because the PVC is not quiesced (paused). Be sure to first tear down a running pod to ensure consistent snapshots.
							</p></div></div></li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To dynamically create a volume snapshot:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a file with the <code class="literal">VolumeSnapshotClass</code> object described by the following YAML:
						</p><div class="formalpara"><p class="title"><strong>volumesnapshotclass.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snap
driver: hostpath.csi.k8s.io <span id="CO66-1"><!--Empty--></span><span class="callout">1</span>
deletionPolicy: Delete</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO66-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the CSI driver that is used to create snapshots of this <code class="literal">VolumeSnapshotClass</code> object. The name must be the same as the <code class="literal">Provisioner</code> field of the storage class that is responsible for the PVC that is being snapshotted.
								</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Depending on the driver that you used to configure persistent storage, additional parameters might be required. You can also use an existing <code class="literal">VolumeSnapshotClass</code> object.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Create the object you saved in the previous step by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc create -f volumesnapshotclass.yaml</pre></li><li class="listitem"><p class="simpara">
							Create a <code class="literal">VolumeSnapshot</code> object:
						</p><div class="formalpara"><p class="title"><strong>volumesnapshot-dynamic.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: mysnap
spec:
  volumeSnapshotClassName: csi-hostpath-snap <span id="CO67-1"><!--Empty--></span><span class="callout">1</span>
  source:
    persistentVolumeClaimName: myclaim <span id="CO67-2"><!--Empty--></span><span class="callout">2</span></pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO67-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The request for a particular class by the volume snapshot. If the <code class="literal">volumeSnapshotClassName</code> setting is absent and there is a default volume snapshot class, a snapshot is created with the default volume snapshot class name. But if the field is absent and no default volume snapshot class exists, then no snapshot is created.
								</div></dd><dt><a href="#CO67-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The name of the <code class="literal">PersistentVolumeClaim</code> object bound to a persistent volume. This defines what you want to create a snapshot of. Required for dynamically provisioning a snapshot.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create the object you saved in the previous step by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc create -f volumesnapshot-dynamic.yaml</pre></li></ol></div><p>
					To manually provision a snapshot:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Provide a value for the <code class="literal">volumeSnapshotContentName</code> parameter as the source for the snapshot, in addition to defining volume snapshot class as shown above.
						</p><div class="formalpara"><p class="title"><strong>volumesnapshot-manual.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: snapshot-demo
spec:
  source:
    volumeSnapshotContentName: mycontent <span id="CO68-1"><!--Empty--></span><span class="callout">1</span></pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO68-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The <code class="literal">volumeSnapshotContentName</code> parameter is required for pre-provisioned snapshots.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create the object you saved in the previous step by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc create -f volumesnapshot-manual.yaml</pre></li></ol></div><div class="formalpara"><p class="title"><strong>Verification</strong></p><p>
						After the snapshot has been created in the cluster, additional details about the snapshot are available.
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							To display details about the volume snapshot that was created, enter the following command:
						</p><pre class="programlisting language-terminal">$ oc describe volumesnapshot mysnap</pre><p class="simpara">
							The following example displays details about the <code class="literal">mysnap</code> volume snapshot:
						</p><div class="formalpara"><p class="title"><strong>volumesnapshot.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshot
metadata:
  name: mysnap
spec:
  source:
    persistentVolumeClaimName: myclaim
  volumeSnapshotClassName: csi-hostpath-snap
status:
  boundVolumeSnapshotContentName: snapcontent-1af4989e-a365-4286-96f8-d5dcd65d78d6 <span id="CO69-1"><!--Empty--></span><span class="callout">1</span>
  creationTime: "2020-01-29T12:24:30Z" <span id="CO69-2"><!--Empty--></span><span class="callout">2</span>
  readyToUse: true <span id="CO69-3"><!--Empty--></span><span class="callout">3</span>
  restoreSize: 500Mi</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO69-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The pointer to the actual storage content that was created by the controller.
								</div></dd><dt><a href="#CO69-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The time when the snapshot was created. The snapshot contains the volume content that was available at this indicated time.
								</div></dd><dt><a href="#CO69-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									If the value is set to <code class="literal">true</code>, the snapshot can be used to restore as a new PVC. <br/> If the value is set to <code class="literal">false</code>, the snapshot was created. However, the storage back end needs to perform additional tasks to make the snapshot usable so that it can be restored as a new volume. For example, Amazon Elastic Block Store data might be moved to a different, less expensive location, which can take several minutes.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							To verify that the volume snapshot was created, enter the following command:
						</p><pre class="programlisting language-terminal">$ oc get volumesnapshotcontent</pre><p class="simpara">
							The pointer to the actual content is displayed. If the <code class="literal">boundVolumeSnapshotContentName</code> field is populated, a <code class="literal">VolumeSnapshotContent</code> object exists and the snapshot was created.
						</p></li><li class="listitem">
							To verify that the snapshot is ready, confirm that the <code class="literal">VolumeSnapshot</code> object has <code class="literal">readyToUse: true</code>.
						</li></ol></div></section><section class="section" id="persistent-storage-csi-snapshots-delete_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.6. Deleting a volume snapshot</h3></div></div></div><p>
					You can configure how OpenShift Container Platform deletes volume snapshots.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Specify the deletion policy that you require in the <code class="literal">VolumeSnapshotClass</code> object, as shown in the following example:
						</p><div class="formalpara"><p class="title"><strong>volumesnapshotclass.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: snapshot.storage.k8s.io/v1
kind: VolumeSnapshotClass
metadata:
  name: csi-hostpath-snap
driver: hostpath.csi.k8s.io
deletionPolicy: Delete <span id="CO70-1"><!--Empty--></span><span class="callout">1</span></pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO70-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									When deleting the volume snapshot, if the <code class="literal">Delete</code> value is set, the underlying snapshot is deleted along with the <code class="literal">VolumeSnapshotContent</code> object. If the <code class="literal">Retain</code> value is set, both the underlying snapshot and <code class="literal">VolumeSnapshotContent</code> object remain. <br/> If the <code class="literal">Retain</code> value is set and the <code class="literal">VolumeSnapshot</code> object is deleted without deleting the corresponding <code class="literal">VolumeSnapshotContent</code> object, the content remains. The snapshot itself is also retained in the storage back end.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Delete the volume snapshot by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc delete volumesnapshot &lt;volumesnapshot_name&gt;</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">volumesnapshot.snapshot.storage.k8s.io "mysnapshot" deleted</pre>

							</p></div></li><li class="listitem"><p class="simpara">
							If the deletion policy is set to <code class="literal">Retain</code>, delete the volume snapshot content by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc delete volumesnapshotcontent &lt;volumesnapshotcontent_name&gt;</pre></li><li class="listitem"><p class="simpara">
							Optional: If the <code class="literal">VolumeSnapshot</code> object is not successfully deleted, enter the following command to remove any finalizers for the leftover resource so that the delete operation can continue:
						</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								Only remove the finalizers if you are confident that there are no existing references from either persistent volume claims or volume snapshot contents to the <code class="literal">VolumeSnapshot</code> object. Even with the <code class="literal">--force</code> option, the delete operation does not delete snapshot objects until all finalizers are removed.
							</p></div></div><pre class="programlisting language-terminal">$ oc patch -n $PROJECT volumesnapshot/$NAME --type=merge -p '{"metadata": {"finalizers":null}}'</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">volumesnapshotclass.snapshot.storage.k8s.io "csi-ocs-rbd-snapclass" deleted</pre>

							</p></div><p class="simpara">
							The finalizers are removed and the volume snapshot is deleted.
						</p></li></ol></div></section><section class="section" id="persistent-storage-csi-snapshots-restore_persistent-storage-csi-snapshots"><div class="titlepage"><div><div><h3 class="title">5.4.7. Restoring a volume snapshot</h3></div></div></div><p>
					The <code class="literal">VolumeSnapshot</code> CRD content can be used to restore the existing volume to a previous state.
				</p><p>
					After your <code class="literal">VolumeSnapshot</code> CRD is bound and the <code class="literal">readyToUse</code> value is set to <code class="literal">true</code>, you can use that resource to provision a new volume that is pre-populated with data from the snapshot. .Prerequisites * Logged in to a running OpenShift Container Platform cluster. * A persistent volume claim (PVC) created using a Container Storage Interface (CSI) driver that supports volume snapshots. * A storage class to provision the storage back end. * A volume snapshot has been created and is ready to use.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Specify a <code class="literal">VolumeSnapshot</code> data source on a PVC as shown in the following:
						</p><div class="formalpara"><p class="title"><strong>pvc-restore.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: myclaim-restore
spec:
  storageClassName: csi-hostpath-sc
  dataSource:
    name: mysnap <span id="CO71-1"><!--Empty--></span><span class="callout">1</span>
    kind: VolumeSnapshot <span id="CO71-2"><!--Empty--></span><span class="callout">2</span>
    apiGroup: snapshot.storage.k8s.io <span id="CO71-3"><!--Empty--></span><span class="callout">3</span>
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO71-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Name of the <code class="literal">VolumeSnapshot</code> object representing the snapshot to use as source.
								</div></dd><dt><a href="#CO71-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									Must be set to the <code class="literal">VolumeSnapshot</code> value.
								</div></dd><dt><a href="#CO71-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									Must be set to the <code class="literal">snapshot.storage.k8s.io</code> value.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create a PVC by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc create -f pvc-restore.yaml</pre></li><li class="listitem"><p class="simpara">
							Verify that the restored PVC has been created by entering the following command:
						</p><pre class="programlisting language-terminal">$ oc get pvc</pre><p class="simpara">
							A new PVC such as <code class="literal">myclaim-restore</code> is displayed.
						</p></li></ol></div></section></section><section class="section" id="persistent-storage-csi-cloning"><div class="titlepage"><div><div><h2 class="title">5.5. CSI volume cloning</h2></div></div></div><p>
				Volume cloning duplicates an existing persistent volume to help protect against data loss in OpenShift Container Platform. This feature is only available with supported Container Storage Interface (CSI) drivers. You should be familiar with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-volumes_understanding-persistent-storage">persistent volumes</a> before you provision a CSI volume clone.
			</p><section class="section" id="persistent-storage-csi-cloning-overview_persistent-storage-csi-cloning"><div class="titlepage"><div><div><h3 class="title">5.5.1. Overview of CSI volume cloning</h3></div></div></div><p>
					A Container Storage Interface (CSI) volume clone is a duplicate of an existing persistent volume at a particular point in time.
				</p><p>
					Volume cloning is similar to volume snapshots, although it is more efficient. For example, a cluster administrator can duplicate a cluster volume by creating another instance of the existing cluster volume.
				</p><p>
					Cloning creates an exact duplicate of the specified volume on the back-end device, rather than creating a new empty volume. After dynamic provisioning, you can use a volume clone just as you would use any standard volume.
				</p><p>
					No new API objects are required for cloning. The existing <code class="literal">dataSource</code> field in the <code class="literal">PersistentVolumeClaim</code> object is expanded so that it can accept the name of an existing PersistentVolumeClaim in the same namespace.
				</p><section class="section" id="support-limitations-2"><div class="titlepage"><div><div><h4 class="title">5.5.1.1. Support limitations</h4></div></div></div><p>
						By default, OpenShift Container Platform supports CSI volume cloning with these limitations:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								The destination persistent volume claim (PVC) must exist in the same namespace as the source PVC.
							</li><li class="listitem"><p class="simpara">
								Cloning is supported with a different Storage Class.
							</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
										Destination volume can be the same for a different storage class as the source.
									</li><li class="listitem">
										You can use the default storage class and omit <code class="literal">storageClassName</code> in the <code class="literal">spec</code>.
									</li></ul></div></li><li class="listitem">
								Support is only available for CSI drivers. In-tree and FlexVolumes are not supported.
							</li><li class="listitem">
								CSI drivers might not have implemented the volume cloning functionality. For details, see the CSI driver documentation.
							</li></ul></div></section></section><section class="section" id="persistent-storage-csi-cloning-provisioning_persistent-storage-csi-cloning"><div class="titlepage"><div><div><h3 class="title">5.5.2. Provisioning a CSI volume clone</h3></div></div></div><p>
					When you create a cloned persistent volume claim (PVC) API object, you trigger the provisioning of a CSI volume clone. The clone pre-populates with the contents of another PVC, adhering to the same rules as any other persistent volume. The one exception is that you must add a <code class="literal">dataSource</code> that references an existing PVC in the same namespace.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You are logged in to a running OpenShift Container Platform cluster.
						</li><li class="listitem">
							Your PVC is created using a CSI driver that supports volume cloning.
						</li><li class="listitem">
							Your storage back end is configured for dynamic provisioning. Cloning support is not available for static provisioners.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To clone a PVC from an existing PVC:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create and save a file with the <code class="literal">PersistentVolumeClaim</code> object described by the following YAML:
						</p><div class="formalpara"><p class="title"><strong>pvc-clone.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-1-clone
  namespace: mynamespace
spec:
  storageClassName: csi-cloning <span id="CO72-1"><!--Empty--></span><span class="callout">1</span>
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 5Gi
  dataSource:
    kind: PersistentVolumeClaim
    name: pvc-1</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO72-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the storage class that provisions the storage back end. The default storage class can be used and <code class="literal">storageClassName</code> can be omitted in the spec.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create the object you saved in the previous step by running the following command:
						</p><pre class="programlisting language-terminal">$ oc create -f pvc-clone.yaml</pre><p class="simpara">
							A new PVC <code class="literal">pvc-1-clone</code> is created.
						</p></li><li class="listitem"><p class="simpara">
							Verify that the volume clone was created and is ready by running the following command:
						</p><pre class="programlisting language-terminal">$ oc get pvc pvc-1-clone</pre><p class="simpara">
							The <code class="literal">pvc-1-clone</code> shows that it is <code class="literal">Bound</code>.
						</p><p class="simpara">
							You are now ready to use the newly cloned PVC to configure a pod.
						</p></li><li class="listitem"><p class="simpara">
							Create and save a file with the <code class="literal">Pod</code> object described by the YAML. For example:
						</p><pre class="programlisting language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: mypod
spec:
  containers:
    - name: myfrontend
      image: dockerfile/nginx
      volumeMounts:
      - mountPath: "/var/www/html"
        name: mypd
  volumes:
    - name: mypd
      persistentVolumeClaim:
        claimName: pvc-1-clone <span id="CO73-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO73-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The cloned PVC created during the CSI volume cloning operation.
								</div></dd></dl></div><p class="simpara">
							The created <code class="literal">Pod</code> object is now ready to consume, clone, snapshot, or delete your cloned PVC independently of its original <code class="literal">dataSource</code> PVC.
						</p></li></ol></div></section></section><section class="section" id="persistent-storage-csi-sc-manage"><div class="titlepage"><div><div><h2 class="title">5.6. Managing the default storage class</h2></div></div></div><section class="section" id="overview"><div class="titlepage"><div><div><h3 class="title">5.6.1. Overview</h3></div></div></div><p>
					Managing the default storage class allows you to accomplish several different objectives:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Enforcing static provisioning by disabling dynamic provisioning.
						</li><li class="listitem">
							When you have other preferred storage classes, preventing the storage operator from re-creating the initial default storage class.
						</li><li class="listitem">
							Renaming, or otherwise changing, the default storage class
						</li></ul></div><p>
					To accomplish these objectives, you change the setting for the <code class="literal">spec.storageClassState</code> field in the <code class="literal">ClusterCSIDriver</code> object. The possible settings for this field are:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>Managed</strong></span>: (Default) The Container Storage Interface (CSI) operator is actively managing its default storage class, so that most manual changes made by a cluster administrator to the default storage class are removed, and the default storage class is continuously re-created if you attempt to manually delete it.
						</li><li class="listitem">
							<span class="strong strong"><strong>Unmanaged</strong></span>: You can modify the default storage class. The CSI operator is not actively managing storage classes, so that it is not reconciling the default storage class it creates automatically.
						</li><li class="listitem">
							<span class="strong strong"><strong>Removed</strong></span>: The CSI operators deletes the default storage class.
						</li></ul></div><p>
					Managing the default storage classes is supported by the following Container Storage Interface (CSI) driver operators:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-alicloud-disk">AliCloud Disk</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-ebs">Amazon Web Services (AWS) Elastic Block Storage (EBS)</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-azure-disk">Azure Disk</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-azure-file">Azure File</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-gcp-pd">Google Cloud Platform (GCP) Persistent Disk (PD)</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-ibm-vpc-block">IBM VPC Block</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-cinder">OpenStack Cinder</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-ovirt">Red Hat Virtualization</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-vsphere">VMware vSphere</a>
						</li></ul></div></section><section class="section" id="persistent-storage-csi-sc-managing_persistent-storage-csi-sc-manage"><div class="titlepage"><div><div><h3 class="title">5.6.2. Managing the default storage class using the web console</h3></div></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to the OpenShift Container Platform web console.
						</li><li class="listitem">
							Access to the cluster with cluster-admin privileges.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To manage the default storage class using the web console:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Log in to the web console.
						</li><li class="listitem">
							Click <span class="strong strong"><strong>Administration</strong></span> &gt; <span class="strong strong"><strong>CustomResourceDefinitions</strong></span>.
						</li><li class="listitem">
							On the <span class="strong strong"><strong>CustomResourceDefinitions</strong></span> page, type <code class="literal">clustercsidriver</code> to find the <code class="literal">ClusterCSIDriver</code> object.
						</li><li class="listitem">
							Click <span class="strong strong"><strong>ClusterCSIDriver</strong></span>, and then click the <span class="strong strong"><strong>Instances</strong></span> tab.
						</li><li class="listitem">
							Click the name of the desired instance, and then click the <span class="strong strong"><strong>YAML</strong></span> tab.
						</li><li class="listitem"><p class="simpara">
							Add the <code class="literal">spec.storageClassState</code> field with a value of <code class="literal">Managed</code>, <code class="literal">Unmanaged</code>, or <code class="literal">Removed</code>.
						</p><div class="formalpara"><p class="title"><strong>Example</strong></p><p>
								
<pre class="programlisting language-yaml">...
spec:
  driverConfig:
    driverType: ''
  logLevel: Normal
  managementState: Managed
  observedConfig: null
  operatorLogLevel: Normal
  storageClassState: Unmanaged <span id="CO74-1"><!--Empty--></span><span class="callout">1</span>
...</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO74-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									<code class="literal">spec.storageClassState</code> field set to "Unmanaged"
								</div></dd></dl></div></li><li class="listitem">
							Click <span class="strong strong"><strong>Save</strong></span>.
						</li></ol></div></section><section class="section" id="persistent-storage-csi-sc-managing-cli_persistent-storage-csi-sc-manage"><div class="titlepage"><div><div><h3 class="title">5.6.3. Managing the default storage class using the CLI</h3></div></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to the cluster with cluster-admin privileges.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To manage the storage class using the CLI, run the following command:
					</p></div><pre class="programlisting language-terminal">oc patch clustercsidriver $DRIVERNAME --type=merge -p "{\"spec\":{\"storageClassState\":\"${STATE}\"}}" <span id="CO75-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO75-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Where <code class="literal">${STATE}</code> is "Removed" or "Managed" or "Unmanaged".
						</div><p>
							Where <code class="literal">$DRIVERNAME</code> is the provisioner name. You can find the provisioner name by running the command <code class="literal">oc get sc</code>.
						</p></dd></dl></div></section><section class="section" id="persistent-storage-csi-sc-multiple-none_persistent-storage-csi-sc-manage"><div class="titlepage"><div><div><h3 class="title">5.6.4. Absent or multiple default storage classes</h3></div></div></div><section class="section" id="multiple-default-storage-classes"><div class="titlepage"><div><div><h4 class="title">5.6.4.1. Multiple default storage classes</h4></div></div></div><p>
						Multiple default storage classes can occur if you mark a non-default storage class as default and do not unset the existing default storage class, or you create a default storage class when a default storage class is already present. With multiple default storage classes present, any persistent volume claim (PVC) requesting the default storage class (<code class="literal">pvc.spec.storageClassName</code>=nil) gets the most recently created default storage class, regardless of the default status of that storage class, and the administrator receives an alert in the alerts dashboard that there are multiple default storage classes, <code class="literal">MultipleDefaultStorageClasses</code>.
					</p></section><section class="section" id="absent-default-storage-class"><div class="titlepage"><div><div><h4 class="title">5.6.4.2. Absent default storage class</h4></div></div></div><p>
						There are two possible scenarios where PVCs can attempt to use a non-existent default storage class:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								An administrator removes the default storage class or marks it as non-default, and then a user creates a PVC requesting the default storage class.
							</li><li class="listitem">
								During installation, the installer creates a PVC requesting the default storage class, which has not yet been created.
							</li></ul></div><p>
						In the preceding scenarios, the PVCs remain in pending state indefinitely.
					</p><p>
						OpenShift Container Platform provides a feature to retroactively assign the default storage class to PVCs, so that they do not remain in the pending state. With this feature enabled, PVCs requesting the default storage class that are created when no default storage classes exists, remain in the pending state until a default storage class is created, or one of the existing storage classes is declared the default. As soon as the default storage class is created or declared, the PVC gets the new default storage class.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Retroactive default storage class assignment is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
						</p><p>
							For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
						</p></div></div><section class="section" id="procedure"><div class="titlepage"><div><div><h5 class="title">5.6.4.2.1. Procedure</h5></div></div></div><p>
							To enable retroactive default storage class assignment:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Enable feature gates (see <span class="emphasis"><em>Nodes</em></span> → <span class="emphasis"><em>Working with clusters</em></span> → <span class="emphasis"><em>Enabling features using feature gates</em></span>).
								</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
										After turning on Technology Preview features using feature gates, they cannot be turned off. As a result, cluster upgrades are prevented.
									</p></div></div><p class="simpara">
									The following configuration example enables retroactive default storage class assignment, and all other Technology Preview features:
								</p><pre class="programlisting language-yaml">apiVersion: config.openshift.io/v1
kind: FeatureGate
metadata:
  name: cluster
spec:
  featureSet: TechPreviewNoUpgrade <span id="CO76-1"><!--Empty--></span><span class="callout">1</span>
...</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO76-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											Enables retroactive default storage class assignment.
										</div></dd></dl></div></li></ol></div></section></section></section><section class="section" id="change-default-storage-class_persistent-storage-csi-sc-manage"><div class="titlepage"><div><div><h3 class="title">5.6.5. Changing the default storage class</h3></div></div></div><p>
					Use the following procedure to change the default storage class.
				</p><p>
					For example, if you have two defined storage classes, <code class="literal">gp3</code> and <code class="literal">standard</code>, and you want to change the default storage class from <code class="literal">gp3</code> to <code class="literal">standard</code>.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to the cluster with cluster-admin privileges.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To change the default storage class:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							List the storage classes:
						</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME                 TYPE
gp3 (default)        kubernetes.io/aws-ebs <span id="CO77-1"><!--Empty--></span><span class="callout">1</span>
standard             kubernetes.io/aws-ebs</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO77-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									<code class="literal">(default)</code> indicates the default storage class.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Make the desired storage class the default.
						</p><p class="simpara">
							For the desired storage class, set the <code class="literal">storageclass.kubernetes.io/is-default-class</code> annotation to <code class="literal">true</code> by running the following command:
						</p><pre class="programlisting language-terminal">$ oc patch storageclass standard -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "true"}}}'</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								You can have multiple default storage classes for a short time. However, you should ensure that only one default storage class exists eventually.
							</p><p>
								With multiple default storage classes present, any persistent volume claim (PVC) requesting the default storage class (<code class="literal">pvc.spec.storageClassName</code>=nil) gets the most recently created default storage class, regardless of the default status of that storage class, and the administrator receives an alert in the alerts dashboard that there are multiple default storage classes, <code class="literal">MultipleDefaultStorageClasses</code>.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Remove the default storage class setting from the old default storage class.
						</p><p class="simpara">
							For the old default storage class, change the value of the <code class="literal">storageclass.kubernetes.io/is-default-class</code> annotation to <code class="literal">false</code> by running the following command:
						</p><pre class="programlisting language-terminal">$ oc patch storageclass gp3 -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "false"}}}'</pre></li><li class="listitem"><p class="simpara">
							Verify the changes:
						</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME                 TYPE
gp3                  kubernetes.io/aws-ebs
standard (default)   kubernetes.io/aws-ebs</pre>

							</p></div></li></ol></div></section></section><section class="section" id="persistent-storage-csi-migration"><div class="titlepage"><div><div><h2 class="title">5.7. CSI automatic migration</h2></div></div></div><p>
				In-tree storage drivers that are traditionally shipped with OpenShift Container Platform are being deprecated and replaced by their equivalent Container Storage Interface (CSI) drivers. OpenShift Container Platform provides automatic migration for in-tree volume plugins to their equivalent CSI drivers.
			</p><section class="section" id="persistent-storage-csi-migration-overview_persistent-storage-csi-migration"><div class="titlepage"><div><div><h3 class="title">5.7.1. Overview</h3></div></div></div><p>
					This feature automatically migrates volumes that were provisioned using in-tree storage plugins to their counterpart Container Storage Interface (CSI) drivers.
				</p><p>
					This process does not perform any data migration; OpenShift Container Platform only translates the persistent volume object in memory. As a result, the translated persistent volume object is not stored on disk, nor is its contents changed. CSI automatic migration should be seamless. This feature does not change how you use all existing API objects: for example, <code class="literal">PersistentVolumes</code>, <code class="literal">PersistentVolumeClaims</code>, and <code class="literal">StorageClasses</code>.
				</p><p>
					The following in-tree to CSI drivers are automatically migrated:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Azure Disk
						</li><li class="listitem">
							OpenStack Cinder
						</li><li class="listitem">
							Amazon Web Services (AWS) Elastic Block Storage (EBS)
						</li><li class="listitem">
							Google Compute Engine Persistent Disk (GCP PD)
						</li><li class="listitem">
							Azure File
						</li><li class="listitem">
							VMware vSphere (see information below for specific migration behavior for vSphere)
						</li></ul></div><p>
					CSI migration for these volume types is considered generally available (GA), and requires no manual intervention.
				</p><p>
					CSI automatic migration of in-tree persistent volumes (PVs) or persistent volume claims (PVCs) does not enable any new CSI driver features, such as snapshots or expansion, if the original in-tree storage plugin did not support it.
				</p></section><section class="section" id="persistent-storage-csi-migration-sc-implications_persistent-storage-csi-migration"><div class="titlepage"><div><div><h3 class="title">5.7.2. Storage class implications</h3></div></div></div><p>
					For new OpenShift Container Platform 4.13, and later, installations, the default storage class is the CSI storage class. All volumes provisioned using this storage class are CSI persistent volumes (PVs).
				</p><p>
					For clusters upgraded from 4.12, and earlier, to 4.13, and later, the CSI storage class is created, and is set as the default if no default storage class was set prior to the upgrade. In the very unlikely case that there is a storage class with the same name, the existing storage class remains unchanged. Any existing in-tree storage classes remain, and might be necessary for certain features, such as volume expansion to work for existing in-tree PVs. While storage class referencing to the in-tree storage plugin will continue working, we recommend that you switch the default storage class to the CSI storage class.
				</p><p>
					To change the default storage class, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#change-default-storage-class_persistent-storage-csi-sc-manage">Changing the default storage class</a>.
				</p></section><section class="section" id="persistent-storage-csi-migration-sc-vsphere_persistent-storage-csi-migration"><div class="titlepage"><div><div><h3 class="title">5.7.3. vSphere automatic migration</h3></div></div></div><section class="section" id="new-installations-of-openshift-container-platform"><div class="titlepage"><div><div><h4 class="title">5.7.3.1. New installations of OpenShift Container Platform</h4></div></div></div><p>
						For new installations of OpenShift Container Platform 4.13, or later, automatic migration is enabled by default.
					</p></section><section class="section" id="upgrading-openshift_persistent-storage-csi-migration"><div class="titlepage"><div><div><h4 class="title">5.7.3.2. Upgrading OpenShift Container Platform</h4></div></div></div><p>
						When upgrading from OpenShift Container Platform 4.12, or earlier, to 4.13, automatic CSI migration for vSphere only occurs if you opt in.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							Carefully review the following consequences before opting in to migration:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/node/7011683">There are known issues that can occur that can cause the migration to fail</a>.
								</li><li class="listitem">
									Enabling migration cannot be undone.
								</li><li class="listitem">
									Migration can take awhile to complete depending on how many nodes are on the cluster.
								</li><li class="listitem">
									Migration is a disruptive process. The Machine Config Operator (MCO) has to update kubelet, which means degrading each node as it rolls out the new MachineConfig to each machine.
								</li></ul></div></div></div><section class="section" id="using-the-web-console-to-opt-in-to-automatic-csi-migration"><div class="titlepage"><div><div><h5 class="title">5.7.3.2.1. Using the web console to opt in to automatic CSI migration</h5></div></div></div><section class="section" id="prerequisites-2"><div class="titlepage"><div><div><h6 class="title">5.7.3.2.1.1. Prerequisites</h6></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Access to the OpenShift Container Platform web console.
									</li><li class="listitem">
										Access to the cluster with cluster-admin privileges.
									</li></ul></div><section class="section" id="procedure-2"><div class="titlepage"><div><div><h6 class="title">5.7.3.2.1.1.1. Procedure</h6></div></div></div><p>
									To opt in to automatic CSI migration for vSphere:
								</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
											Log in to the web console.
										</li><li class="listitem">
											Click <span class="strong strong"><strong>Administration</strong></span> → <span class="strong strong"><strong>CustomResourceDefinitions</strong></span>.
										</li><li class="listitem">
											On the <span class="strong strong"><strong>CustomResourceDefinitions</strong></span> page, type "Storage" to find the <code class="literal">Storage</code> custom resource (CR).
										</li><li class="listitem">
											Click the <span class="strong strong"><strong>Storage</strong></span> CR.
										</li><li class="listitem">
											On the <span class="strong strong"><strong>storages.operator.openshift.io</strong></span> page, click the <span class="strong strong"><strong>Instances</strong></span> tab.
										</li><li class="listitem">
											Click the name of the desired instance, and then click the <span class="strong strong"><strong>YAML</strong></span> tab.
										</li><li class="listitem"><p class="simpara">
											Set the <code class="literal">spec.vsphereStorageDriver</code> parameter to <code class="literal">CSIWithMigrationDriver</code>, as shown in the following example:
										</p><pre class="programlisting language-yaml">....
spec:
  logLevel: Normal
  managementState: Managed
  operatorLogLevel: Normal
  vsphereStorageDriver: CSIWithMigrationDriver <span id="CO78-1"><!--Empty--></span><span class="callout">1</span>
...</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO78-1"><span class="callout">1</span></a> </dt><dd><div class="para">
													<code class="literal">spec.vsphereStorageDriver</code> parameter set to <code class="literal">CSIWithMigrationDriver</code>
												</div></dd></dl></div></li><li class="listitem">
											Click <span class="strong strong"><strong>Save</strong></span>.
										</li></ol></div></section></section></section><section class="section" id="using-the-cli-to-opt-in-to-automatic-csi-migration"><div class="titlepage"><div><div><h5 class="title">5.7.3.2.2. Using the CLI to opt in to automatic CSI migration</h5></div></div></div><section class="section" id="prerequisites-3"><div class="titlepage"><div><div><h6 class="title">5.7.3.2.2.1. Prerequisites</h6></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										Access to the cluster with cluster-admin privileges.
									</li></ul></div></section><section class="section" id="procedure-3"><div class="titlepage"><div><div><h6 class="title">5.7.3.2.2.2. Procedure</h6></div></div></div><p>
								To opt in to automatic CSI migration for vSphere, run the following command:
							</p><pre class="programlisting language-cli">oc patch storage cluster --type=merge -p '{"spec":{"vsphereStorageDriver":"CSIWithMigrationDriver"}}'</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									You can determine when migration is complete by verifying that the <code class="literal">VSphereMigrationControllerAvailable</code> condition is set to "true" in the <code class="literal">Storage</code> object.
								</p></div></div></section></section></section></section></section><section class="section" id="ephemeral-storage-csi-vol-detach-non-graceful-shutdown"><div class="titlepage"><div><div><h2 class="title">5.8. Detach CSI volumes after non-graceful node shutdown</h2></div></div></div><p>
				This feature allows Container Storage Interface (CSI) drivers to automatically detach volumes when a node goes down non-gracefully.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Detach CSI volumes after non-graceful node shutdown is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
				</p><p>
					For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
				</p></div></div><section class="section" id="persistent-storage-csi-vol-detach-non-graceful-overview_ephemeral-storage-csi-vol-detach-non-graceful-shutdown"><div class="titlepage"><div><div><h3 class="title">5.8.1. Overview</h3></div></div></div><p>
					A graceful node shutdown occurs when the kubelet’s node shutdown manager detects the upcoming node shutdown action. Non-graceful shutdowns occur when the kubelet does not detect a node shutdown action, which can occur because of system or hardware failures. Also, the kubelet may not detect a node shutdown action when the shutdown command does not trigger the Inhibitor Locks mechanism used by the kubelet on Linux, or because of a user error, for example, if the shutdownGracePeriod and shutdownGracePeriodCriticalPods details are not configured correctly for that node.
				</p><p>
					With this feature, when a non-graceful node shutdown occurs, you can manually add an <code class="literal">out-of-service</code> taint on the node to allow volumes to automatically detach from the node.
				</p></section><section class="section" id="persistent-storage-csi-vol-detach-non-graceful-shutdown-procedure_ephemeral-storage-csi-vol-detach-non-graceful-shutdown"><div class="titlepage"><div><div><h3 class="title">5.8.2. Adding an out-of-service taint manually for automatic volume detachment</h3></div></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to the cluster with cluster-admin privileges.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To allow volumes to detach automatically from a node after a non-graceful node shutdown:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							After a node is detected as unhealthy, shut down the worker node.
						</li><li class="listitem"><p class="simpara">
							Ensure that the node is shutdown by running the following command and checking the status:
						</p><pre class="programlisting language-terminal">oc get node &lt;node name&gt; <span id="CO79-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO79-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									&lt;node name&gt; = name of the non-gracefully shutdown node
								</div></dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								If the node is not completely shut down, do not proceed with tainting the node. If the node is still up and the taint is applied, filesystem corruption can occur.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Taint the corresponding node object by running the following command:
						</p><pre class="programlisting language-terminal">oc adm taint node &lt;node name&gt; node.kubernetes.io/out-of-service=nodeshutdown:NoExecute <span id="CO80-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO80-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									&lt;node name&gt; = name of the non-gracefully shutdown node
								</div></dd></dl></div><p class="simpara">
							After the taint is applied, the volumes detach from the shutdown node allowing their disks to be attached to a different node.
						</p><div class="formalpara"><p class="title"><strong>Example</strong></p><p>
								The resulting YAML file resembles the following:
							</p></div><pre class="programlisting language-yaml">spec:
  taints:
  - effect: NoExecute
    key: node.kubernetes.io/out-of-service
    value: nodeshutdown</pre></li><li class="listitem">
							Restart the node.
						</li><li class="listitem">
							Remove the taint.
						</li></ol></div></section></section><section class="section" id="persistent-storage-csi-alicloud-disk"><div class="titlepage"><div><div><h2 class="title">5.9. AliCloud Disk CSI Driver Operator</h2></div></div></div><section class="section" id="persistent-storage-csi-alicloud-disk-overview"><div class="titlepage"><div><div><h3 class="title">5.9.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Alibaba AliCloud Disk Storage.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to AliCloud Disk storage assets, OpenShift Container Platform installs the AliCloud Disk CSI Driver Operator and the AliCloud Disk CSI driver, by default, in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>AliCloud Disk CSI Driver Operator</em></span> provides a storage class (<code class="literal">alicloud-disk</code>) that you can use to create persistent volume claims (PVCs). The AliCloud Disk CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							The <span class="emphasis"><em>AliCloud Disk CSI driver</em></span> enables you to create and mount AliCloud Disk PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-alicloud-disk"><div class="titlepage"><div><div><h3 class="title">5.9.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="itemizedlist"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-ebs"><div class="titlepage"><div><div><h2 class="title">5.10. AWS Elastic Block Store CSI Driver Operator</h2></div></div></div><section class="section" id="overview-2"><div class="titlepage"><div><div><h3 class="title">5.10.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the <a class="link" href="https://github.com/openshift/aws-ebs-csi-driver">AWS EBS CSI driver</a>.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a Container Storage Interface (CSI) Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to AWS EBS storage assets, OpenShift Container Platform installs the <a class="link" href="https://github.com/openshift/aws-ebs-csi-driver-operator">AWS EBS CSI Driver Operator</a> (a Red Hat operator) and the AWS EBS CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>AWS EBS CSI Driver Operator</em></span> provides a StorageClass by default that you can use to create PVCs. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>). You also have the option to create the AWS EBS StorageClass as described in <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-aws">Persistent storage using Amazon Elastic Block Store</a>.
						</li><li class="listitem">
							The <span class="emphasis"><em>AWS EBS CSI driver</em></span> enables you to create and mount AWS EBS PVs.
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If you installed the AWS EBS CSI Operator and driver on an OpenShift Container Platform 4.5 cluster, you must uninstall the 4.5 Operator and driver before you update to OpenShift Container Platform 4.13.
					</p></div></div></section><section class="section" id="csi-about_persistent-storage-csi-ebs"><div class="titlepage"><div><div><h3 class="title">5.10.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						OpenShift Container Platform defaults to using the CSI plugin to provision Amazon Elastic Block Store (Amazon EBS) storage.
					</p></div></div><p>
					For information about dynamically provisioning AWS EBS persistent volumes in OpenShift Container Platform, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-aws">Persistent storage using Amazon Elastic Block Store</a>.
				</p></section><section class="section" id="byok_persistent-storage-csi-ebs"><div class="titlepage"><div><div><h3 class="title">5.10.3. User-managed encryption</h3></div></div></div><p>
					The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <code class="literal">platform.&lt;cloud_type&gt;.defaultMachinePlatform</code> field in the install-config YAML file.
				</p><p>
					This features supports the following storage types:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Amazon Web Services (AWS) Elastic Block storage (EBS)
						</li><li class="listitem">
							Microsoft Azure Disk storage
						</li><li class="listitem">
							Google Cloud Platform (GCP) persistent disk (PD) storage
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If there is no encrypted key defined in the storage class, only set <code class="literal">encrypted: "true"</code> in the storage class. The AWS EBS CSI driver uses the AWS managed alias/aws/ebs, which is created by Amazon EBS automatically in each region by default to encrypt provisioned storage volumes. In addition, the managed storage classes all have the <code class="literal">encrypted: "true"</code> setting.
					</p></div></div><p>
					For information about installing with user-managed encryption for Amazon EBS, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installation-configuration-parameters_installing-aws-customizations">Installation configuration parameters</a>.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-aws">Persistent storage using Amazon Elastic Block Store</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h2 class="title">5.11. AWS Elastic File Service CSI Driver Operator</h2></div></div></div><section class="section" id="overview-3"><div class="titlepage"><div><div><h3 class="title">5.11.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for AWS Elastic File Service (EFS).
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					After installing the AWS EFS CSI Driver Operator, OpenShift Container Platform installs the AWS EFS CSI Operator and the AWS EFS CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace. This allows the AWS EFS CSI Driver Operator to create CSI-provisioned PVs that mount to AWS EFS assets.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>AWS EFS CSI Driver Operator</em></span>, after being installed, does not create a storage class by default to use to create persistent volume claims (PVCs). However, you can manually create the AWS EFS <code class="literal">StorageClass</code>. The AWS EFS CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand. This eliminates the need for cluster administrators to pre-provision storage.
						</li><li class="listitem">
							The <span class="emphasis"><em>AWS EFS CSI driver</em></span> enables you to create and mount AWS EFS PVs.
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						AWS EFS only supports regional volumes, not zonal volumes.
					</p></div></div></section><section class="section" id="csi-about_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section" id="persistent-storage-efs-csi-driver-operator-setup_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.3. Setting up the AWS EFS CSI Driver Operator</h3></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Install the <a class="link" href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</a> (a Red Hat operator).
						</li><li class="listitem">
							Install the AWS EFS CSI Driver.
						</li></ol></div><section class="section" id="persistent-storage-csi-olm-operator-install_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h4 class="title">5.11.3.1. Installing the AWS EFS CSI Driver Operator</h4></div></div></div><p>
						The <a class="link" href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</a> (a Red Hat operator) is not installed in OpenShift Container Platform by default. Use the following procedure to install and configure the AWS EFS CSI Driver Operator in your cluster.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Access to the OpenShift Container Platform web console.
							</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
							To install the AWS EFS CSI Driver Operator from the web console:
						</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Log in to the web console.
							</li><li class="listitem"><p class="simpara">
								Install the AWS EFS CSI Operator:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										Click <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>OperatorHub</strong></span>.
									</li><li class="listitem">
										Locate the AWS EFS CSI Operator by typing <span class="strong strong"><strong>AWS EFS CSI</strong></span> in the filter box.
									</li><li class="listitem"><p class="simpara">
										Click the <span class="strong strong"><strong>AWS EFS CSI Driver Operator</strong></span> button.
									</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
											Be sure to select the <span class="strong strong"><strong>AWS EFS CSI Driver Operator</strong></span> and not the <span class="strong strong"><strong>AWS EFS Operator</strong></span>. The <span class="strong strong"><strong>AWS EFS Operator</strong></span> is a community Operator and is not supported by Red Hat.
										</p></div></div></li><li class="listitem">
										On the <span class="strong strong"><strong>AWS EFS CSI Driver Operator</strong></span> page, click <span class="strong strong"><strong>Install</strong></span>.
									</li><li class="listitem"><p class="simpara">
										On the <span class="strong strong"><strong>Install Operator</strong></span> page, ensure that:
									</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
												<span class="strong strong"><strong>All namespaces on the cluster (default)</strong></span> is selected.
											</li><li class="listitem">
												<span class="strong strong"><strong>Installed Namespace</strong></span> is set to <span class="strong strong"><strong>openshift-cluster-csi-drivers</strong></span>.
											</li></ul></div></li><li class="listitem"><p class="simpara">
										Click <span class="strong strong"><strong>Install</strong></span>.
									</p><p class="simpara">
										After the installation finishes, the AWS EFS CSI Operator is listed in the <span class="strong strong"><strong>Installed Operators</strong></span> section of the web console.
									</p></li></ol></div></li></ol></div><div class="itemizedlist"><p class="title"><strong>Next steps</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								If you are using AWS EFS with AWS Secure Token Service (STS), you must configure the AWS EFS CSI Driver with STS. For more information, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#efs-sts_persistent-storage-csi-aws-efs">Configuring AWS EFS CSI Driver with STS</a>.
							</li></ul></div></section><section class="section" id="efs-sts_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h4 class="title">5.11.3.2. Configuring AWS EFS CSI Driver Operator with Security Token Service</h4></div></div></div><p>
						This procedure explains how to configure the AWS EFS CSI Driver Operator with OpenShift Container Platform on AWS Security Token Service (STS).
					</p><p>
						Perform this procedure before you have installed the AWS EFS CSI Operator, but not yet installed the AWS EFS CSI driver as part of the <span class="emphasis"><em>Installing the AWS EFS CSI Driver Operator</em></span> procedure.
					</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
							If you perform this procedure after installing the driver and creating volumes, your volumes will fail to mount into pods.
						</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								You have access to the cluster as a user with the cluster-admin role.
							</li><li class="listitem">
								AWS account credentials
							</li><li class="listitem">
								You have installed the AWS EFS CSI Operator.
							</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
							To configure the AWS EFS CSI Driver Operator with STS:
						</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								Extract the CCO utility (<code class="literal">ccoctl</code>) binary from the OpenShift Container Platform release image, which you used to install the cluster with STS. For more information, see "Configuring the Cloud Credential Operator utility".
							</li><li class="listitem"><p class="simpara">
								Create and save an EFS <code class="literal">CredentialsRequest</code> YAML file, such as shown in the following example, and then place it in the <code class="literal">credrequests</code> directory:
							</p><div class="formalpara"><p class="title"><strong>Example</strong></p><p>
									
<pre class="programlisting language-yaml">apiVersion: cloudcredential.openshift.io/v1
kind: CredentialsRequest
metadata:
  name: openshift-aws-efs-csi-driver
  namespace: openshift-cloud-credential-operator
spec:
  providerSpec:
    apiVersion: cloudcredential.openshift.io/v1
    kind: AWSProviderSpec
    statementEntries:
    - action:
      - elasticfilesystem:*
      effect: Allow
      resource: '*'
  secretRef:
    name: aws-efs-cloud-credentials
    namespace: openshift-cluster-csi-drivers
  serviceAccountNames:
  - aws-efs-csi-driver-operator
  - aws-efs-csi-driver-controller-sa</pre>

								</p></div></li><li class="listitem"><p class="simpara">
								Run the <code class="literal">ccoctl</code> tool to generate a new IAM role in AWS, and create a YAML file for it in the local file system (<code class="literal">&lt;path_to_ccoctl_output_dir&gt;/manifests/openshift-cluster-csi-drivers-aws-efs-cloud-credentials-credentials.yaml</code>).
							</p><pre class="programlisting language-terminal">$ ccoctl aws create-iam-roles --name=&lt;name&gt; --region=&lt;aws_region&gt; --credentials-requests-dir=&lt;path_to_directory_with_list_of_credentials_requests&gt;/credrequests --identity-provider-arn=arn:aws:iam::&lt;aws_account_id&gt;:oidc-provider/&lt;name&gt;-oidc.s3.&lt;aws_region&gt;.amazonaws.com</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										<code class="literal">name=&lt;name&gt;</code> is the name used to tag any cloud resources that are created for tracking.
									</li><li class="listitem">
										<code class="literal">region=&lt;aws_region&gt;</code> is the AWS region where cloud resources are created.
									</li><li class="listitem">
										<code class="literal">dir=&lt;path_to_directory_with_list_of_credentials_requests&gt;/credrequests</code> is the directory containing the EFS CredentialsRequest file in previous step.
									</li><li class="listitem"><p class="simpara">
										<code class="literal">&lt;aws_account_id&gt;</code> is the AWS account ID.
									</p><div class="formalpara"><p class="title"><strong>Example</strong></p><p>
											
<pre class="programlisting language-terminal">$ ccoctl aws create-iam-roles --name my-aws-efs --credentials-requests-dir credrequests --identity-provider-arn arn:aws:iam::123456789012:oidc-provider/my-aws-efs-oidc.s3.us-east-2.amazonaws.com</pre>

										</p></div><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
											
<pre class="programlisting language-terminal">2022/03/21 06:24:44 Role arn:aws:iam::123456789012:role/my-aws-efs -openshift-cluster-csi-drivers-aws-efs-cloud- created
2022/03/21 06:24:44 Saved credentials configuration to: /manifests/openshift-cluster-csi-drivers-aws-efs-cloud-credentials-credentials.yaml
2022/03/21 06:24:45 Updated Role policy for Role my-aws-efs-openshift-cluster-csi-drivers-aws-efs-cloud-</pre>

										</p></div></li></ul></div></li><li class="listitem"><p class="simpara">
								Create the AWS EFS cloud credentials and secret:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;path_to_ccoctl_output_dir&gt;/manifests/openshift-cluster-csi-drivers-aws-efs-cloud-credentials-credentials.yaml</pre><div class="formalpara"><p class="title"><strong>Example</strong></p><p>
									
<pre class="programlisting language-terminal">$ oc create -f /manifests/openshift-cluster-csi-drivers-aws-efs-cloud-credentials-credentials.yaml</pre>

								</p></div><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
									
<pre class="programlisting language-terminal">secret/aws-efs-cloud-credentials created</pre>

								</p></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-olm-operator-install_persistent-storage-csi-aws-efs">Installing the AWS EFS CSI Driver Operator</a>
							</li><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/authentication_and_authorization/#cco-ccoctl-configuring_cco-mode-sts">Configuring the Cloud Credential Operator utility</a>
							</li><li class="listitem">
								<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-efs-driver-install_persistent-storage-csi-aws-efs">Installing the AWS EFS CSI Driver</a>
							</li></ul></div></section><section class="section" id="persistent-storage-csi-efs-driver-install_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h4 class="title">5.11.3.3. Installing the AWS EFS CSI Driver</h4></div></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Access to the OpenShift Container Platform web console.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
								Click <span class="strong strong"><strong>Administration</strong></span> → <span class="strong strong"><strong>CustomResourceDefinitions</strong></span> → <span class="strong strong"><strong>ClusterCSIDriver</strong></span>.
							</li><li class="listitem">
								On the <span class="strong strong"><strong>Instances</strong></span> tab, click <span class="strong strong"><strong>Create ClusterCSIDriver</strong></span>.
							</li><li class="listitem"><p class="simpara">
								Use the following YAML file:
							</p><pre class="programlisting language-yaml">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
    name: efs.csi.aws.com
spec:
  managementState: Managed</pre></li><li class="listitem">
								Click <span class="strong strong"><strong>Create</strong></span>.
							</li><li class="listitem"><p class="simpara">
								Wait for the following Conditions to change to a "True" status:
							</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
										AWSEFSDriverNodeServiceControllerAvailable
									</li><li class="listitem">
										AWSEFSDriverControllerServiceControllerAvailable
									</li></ul></div></li></ol></div></section></section><section class="section" id="storage-create-storage-class_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.4. Creating the AWS EFS storage class</h3></div></div></div><p>
					Storage classes are used to differentiate and delineate storage levels and usages. By defining a storage class, users can obtain dynamically provisioned persistent volumes.
				</p><p>
					The <span class="emphasis"><em><a class="link" href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</a> (a Red Hat operator)</em></span>, after being installed, does not create a storage class by default. However, you can manually create the AWS EFS storage class.
				</p><section class="section" id="storage-create-storage-class-console_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h4 class="title">5.11.4.1. Creating the AWS EFS storage class using the console</h4></div></div></div><div class="orderedlist _abstract"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist _abstract" type="1"><li class="listitem">
								In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>StorageClasses</strong></span>.
							</li><li class="listitem">
								On the <span class="strong strong"><strong>StorageClasses</strong></span> page, click <span class="strong strong"><strong>Create StorageClass</strong></span>.
							</li><li class="listitem"><p class="simpara">
								On the <span class="strong strong"><strong>StorageClass</strong></span> page, perform the following steps:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										Enter a name to reference the storage class.
									</li><li class="listitem">
										Optional: Enter the description.
									</li><li class="listitem">
										Select the reclaim policy.
									</li><li class="listitem">
										Select <span class="strong strong"><strong><code class="literal">efs.csi.aws.com</code></strong></span> from the <span class="strong strong"><strong>Provisioner</strong></span> drop-down list.
									</li><li class="listitem">
										Optional: Set the configuration parameters for the selected provisioner.
									</li></ol></div></li><li class="listitem">
								Click <span class="strong strong"><strong>Create</strong></span>.
							</li></ol></div></section><section class="section" id="storage-create-storage-class-cli_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h4 class="title">5.11.4.2. Creating the AWS EFS storage class using the CLI</h4></div></div></div><div class="itemizedlist _abstract"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist _abstract" type="disc"><li class="listitem"><p class="simpara">
								Create a <code class="literal">StorageClass</code> object:
							</p><pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: efs-sc
provisioner: efs.csi.aws.com
parameters:
  provisioningMode: efs-ap <span id="CO81-1"><!--Empty--></span><span class="callout">1</span>
  fileSystemId: fs-a5324911 <span id="CO81-2"><!--Empty--></span><span class="callout">2</span>
  directoryPerms: "700" <span id="CO81-3"><!--Empty--></span><span class="callout">3</span>
  gidRangeStart: "1000" <span id="CO81-4"><!--Empty--></span><span class="callout">4</span>
  gidRangeEnd: "2000" <span id="CO81-5"><!--Empty--></span><span class="callout">5</span>
  basePath: "/dynamic_provisioning" <span id="CO81-6"><!--Empty--></span><span class="callout">6</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO81-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										<code class="literal">provisioningMode</code> must be <code class="literal">efs-ap</code> to enable dynamic provisioning.
									</div></dd><dt><a href="#CO81-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										<code class="literal">fileSystemId</code> must be the ID of the EFS volume created manually.
									</div></dd><dt><a href="#CO81-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										<code class="literal">directoryPerms</code> is the default permission of the root directory of the volume. In this example, the volume is accessible only by the owner.
									</div></dd><dt><a href="#CO81-4"><span class="callout">4</span></a> <a href="#CO81-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										<code class="literal">gidRangeStart</code> and <code class="literal">gidRangeEnd</code> set the range of POSIX Group IDs (GIDs) that are used to set the GID of the AWS access point. If not specified, the default range is 50000-7000000. Each provisioned volume, and thus AWS access point, is assigned a unique GID from this range.
									</div></dd><dt><a href="#CO81-6"><span class="callout">6</span></a> </dt><dd><div class="para">
										<code class="literal">basePath</code> is the directory on the EFS volume that is used to create dynamically provisioned volumes. In this case, a PV is provisioned as “/dynamic_provisioning/&lt;random uuid&gt;” on the EFS volume. Only the subdirectory is mounted to pods that use the PV.
									</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
									A cluster admin can create several <code class="literal">StorageClass</code> objects, each using a different EFS volume.
								</p></div></div></li></ul></div></section></section><section class="section" id="persistent-storage-csi-efs-cross-account_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.5. AWS EFS CSI cross account support</h3></div></div></div><p>
					Cross account support allows you to have an OpenShift Container Platform cluster in one AWS account and mount your file system in another AWS account using the AWS Elastic File System (EFS) Container Storage Interface (CSI) driver.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Both the OpenShift Container Platform cluster and EFS file system must be in the same region.
					</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to an OpenShift Container Platform cluster with administrator rights
						</li><li class="listitem">
							Two valid AWS accounts
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						The following procedure demonstrates how to set up:
					</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							OpenShift Container Platform cluster in AWS account A
						</li><li class="listitem">
							Mount an AWS EFS file system in account B
						</li></ul></div><p>
					To use AWS EFS across accounts:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Install OpenShift Container Platform cluster with AWS account A and install the EFS CSI Driver Operator.
						</li><li class="listitem"><p class="simpara">
							Create an EFS volume in AWS account B:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Create a virtual private cloud (VPC) called, for example, "my-efs-vpc” with CIDR, for example, “172.20.0.0/16” and subnet for the AWS EFS volume.
								</li><li class="listitem">
									On the AWS console, go to <a class="link" href="https://console.aws.amazon.com/efs">https://console.aws.amazon.com/efs</a>.
								</li><li class="listitem"><p class="simpara">
									Click <span class="strong strong"><strong>Create new filesystem</strong></span>:
								</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
											Create a filesystem named, for example, "my-filesystem”.
										</li><li class="listitem">
											Select the VPC created earlier (“my-efs-vpc”).
										</li><li class="listitem">
											Accept the default for the remaining settings.
										</li></ol></div></li><li class="listitem"><p class="simpara">
									Ensure that the volume and Mount Targets have been created:
								</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
											Check <a class="link" href="https://console.aws.amazon.com/efs#/file-systems">https://console.aws.amazon.com/efs#/file-systems</a>.
										</li><li class="listitem">
											Click your volume, and on the <span class="strong strong"><strong>Network</strong></span> tab wait for all Mount Targets to be available (approximately 1-2 minutes).
										</li></ol></div></li><li class="listitem">
									On the <span class="strong strong"><strong>Network</strong></span> tab, copy the Security Group ID. You will need it for the next step.
								</li></ol></div></li><li class="listitem"><p class="simpara">
							Configure networking access to the AWS EFS volume on AWS account B:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Go to <a class="link" href="https://console.aws.amazon.com/ec2/v2/home#SecurityGroups">https://console.aws.amazon.com/ec2/v2/home#SecurityGroups</a>.
								</li><li class="listitem">
									Find the Security Group used by the AWS EFS volume by filtering for the group ID copied earlier.
								</li><li class="listitem"><p class="simpara">
									On the <span class="strong strong"><strong>Inbound rules</strong></span> tab, click <span class="strong strong"><strong>Edit inbound rules</strong></span>, and then add a new rule to allow OpenShift Container Platform nodes to access the AWS EFS volumes (that is, use NFS ports from the cluster):
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											<span class="strong strong"><strong>Type</strong></span>: NFS
										</li><li class="listitem">
											<span class="strong strong"><strong>Protocol</strong></span>: TCP
										</li><li class="listitem">
											<span class="strong strong"><strong>Port range</strong></span>: 2049
										</li><li class="listitem">
											<span class="strong strong"><strong>Source</strong></span>: Custom/IP address range of your OpenShift Container Platform cluster nodes (for example, “10.0.0.0/16”)
										</li></ul></div></li><li class="listitem"><p class="simpara">
									Save the rule.
								</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										If you encounter mounting issues, re-check the port number, IP address range, and verify that the AWS EFS volume uses the expected security group.
									</p></div></div></li></ol></div></li><li class="listitem"><p class="simpara">
							Create VPC peering between the OpenShift Container Platform cluster VPC in AWS account A and the AWS EFS VPC in AWS account B:
						</p><p class="simpara">
							Ensure the two VPCs are using different network CIDRs, and after creating the VPC peering, add routes in each VPC to connect the two VPC networks.
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Create a peering connection called, for example, “my-efs-crossaccount-peering-connection” in account B. For the local VPC ID, use the EFS-located VPC. To peer with the VPC for account A, for the VPC ID use the OpenShift Container Platform cluster VPC ID.
								</li><li class="listitem">
									Accept the peer connection in AWS account A.
								</li><li class="listitem"><p class="simpara">
									Modify the route table of each subnet (EFS-volume used subnets) in AWS account B:
								</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
											On the left pane, under <span class="strong strong"><strong>Virtual private cloud</strong></span>, click the down arrow to expand the available options.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Virtual private cloud</strong></span>, click <span class="strong strong"><strong>Route tables"</strong></span>.
										</li><li class="listitem">
											Click the <span class="strong strong"><strong>Routes</strong></span> tab.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Destination</strong></span>, enter 10.0.0.0/16.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Target</strong></span>, use the peer connection type point from the created peer connection.
										</li></ol></div></li><li class="listitem"><p class="simpara">
									Modify the route table of each subnet (OpenShift Container Platform cluster nodes used subnets) in AWS account A:
								</p><div class="orderedlist"><ol class="orderedlist" type="i"><li class="listitem">
											On the left pane, under <span class="strong strong"><strong>Virtual private cloud</strong></span>, click the down arrow to expand the available options.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Virtual private cloud</strong></span>, click <span class="strong strong"><strong>Route tables"</strong></span>.
										</li><li class="listitem">
											Click the <span class="strong strong"><strong>Routes</strong></span> tab.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Destination</strong></span>, enter the CIDR for the VPC in account B, which for this example is 172.20.0.0/16.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Target</strong></span>, use the peer connection type point from the created peer connection.
										</li></ol></div></li></ol></div></li><li class="listitem"><p class="simpara">
							Create an IAM role, for example, “my-efs-acrossaccount-role” in AWS account B, which has a trust relationship with AWS account A, and add an inline AWS EFS policy with permissions to call “my-efs-acrossaccount-driver-policy”.
						</p><p class="simpara">
							This role is used by the CSI driver’s controller service running on the OpenShift Container Platform cluster in AWS account A to determine the mount targets for your file system in AWS account B.
						</p><pre class="programlisting language-json"># Trust relationships trusted entity trusted account A configuration on my-efs-acrossaccount-role in account B

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::301721915996:root"
            },
            "Action": "sts:AssumeRole",
            "Condition": {}
        }
    ]
}

# my-cross-account-assume-policy policy attached to my-efs-acrossaccount-role in account B

{
    "Version": "2012-10-17",
    "Statement": {
        "Effect": "Allow",
        "Action": "sts:AssumeRole",
        "Resource": "arn:aws:iam::589722580343:role/my-efs-acrossaccount-role"
    }
}

# my-efs-acrossaccount-driver-policy attached to my-efs-acrossaccount-role in account B

{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": [
                "ec2:DescribeNetworkInterfaces",
                "ec2:DescribeSubnets"
            ],
            "Resource": "*"
        },
        {
            "Sid": "VisualEditor1",
            "Effect": "Allow",
            "Action": [
                "elasticfilesystem:DescribeMountTargets",
                "elasticfilesystem:DeleteAccessPoint",
                "elasticfilesystem:ClientMount",
                "elasticfilesystem:DescribeAccessPoints",
                "elasticfilesystem:ClientWrite",
                "elasticfilesystem:ClientRootAccess",
                "elasticfilesystem:DescribeFileSystems",
                "elasticfilesystem:CreateAccessPoint"
            ],
            "Resource": [
                "arn:aws:elasticfilesystem:*:589722580343:access-point/*",
                "arn:aws:elasticfilesystem:*:589722580343:file-system/*"
            ]
        }
    ]
}</pre></li><li class="listitem"><p class="simpara">
							In AWS account A, attach an inline policy to the IAM role of the AWS EFS CSI driver’s controller service account with the necessary permissions to perform Security Token Service (STS) assume role on the IAM role created earlier.
						</p><pre class="programlisting language-json"># my-cross-account-assume-policy policy attached to Openshift cluster efs csi driver user in account A

{
    "Version": "2012-10-17",
    "Statement": {
        "Effect": "Allow",
        "Action": "sts:AssumeRole",
        "Resource": "arn:aws:iam::589722580343:role/my-efs-acrossaccount-role"
    }
}</pre></li><li class="listitem">
							In AWS account A, attach the AWS-managed policy “AmazonElasticFileSystemClientFullAccess” to OpenShift Container Platform cluster master role. The role name is in the form <code class="literal">&lt;clusterID&gt;-master-role</code> (for example, <code class="literal">my-0120ef-czjrl-master-role</code>).
						</li><li class="listitem"><p class="simpara">
							Create a Kubernetes secret with <code class="literal">awsRoleArn</code> as the key and the role created earlier as the value:
						</p><pre class="programlisting language-cli">$ oc -n openshift-cluster-csi-drivers create secret generic my-efs-cross-account --from-literal=awsRoleArn='arn:aws:iam::589722580343:role/my-efs-acrossaccount-role'</pre><p class="simpara">
							Since the driver controller needs to get the cross account role information from the secret, you need to add the secret role binding to the AWS EFS CSI driver controller ServiceAccount (SA):
						</p><pre class="programlisting language-cli">$ oc -n openshift-cluster-csi-drivers create role access-secrets --verb=get,list,watch --resource=secrets

$ oc -n openshift-cluster-csi-drivers create rolebinding --role=access-secrets default-to-secrets --serviceaccount=openshift-cluster-csi-drivers:aws-efs-csi-driver-controller-sa</pre></li><li class="listitem"><p class="simpara">
							Create a <code class="literal">filesystem</code> policy for the file system (AWS EFS volume) in account B, which allows AWS account A to perform a mount on it.
						</p><pre class="screen">This step is not mandatory, but can be safer for AWS EFS volume usage.</pre><pre class="programlisting language-json"># EFS volume filesystem policy in account B
{
    "Version": "2012-10-17",
    "Id": "efs-policy-wizard-8089bf4a-9787-40f0-958e-bc2363012ace",
    "Statement": [
        {
            "Sid": "efs-statement-bd285549-cfa2-4f8b-861e-c372399fd238",
            "Effect": "Allow",
            "Principal": {
                "AWS": "*"
            },
            "Action": [
                "elasticfilesystem:ClientRootAccess",
                "elasticfilesystem:ClientWrite",
                "elasticfilesystem:ClientMount"
            ],
            "Resource": "arn:aws:elasticfilesystem:us-east-2:589722580343:file-system/fs-091066a9bf9becbd5",
            "Condition": {
                "Bool": {
                    "elasticfilesystem:AccessedViaMountTarget": "true"
                }
            }
        },
        {
            "Sid": "efs-statement-03646e39-d80f-4daf-b396-281be1e43bab",
            "Effect": "Allow",
            "Principal": {
                "AWS": "arn:aws:iam::589722580343:role/my-efs-acrossaccount-role"
            },
            "Action": [
                "elasticfilesystem:ClientRootAccess",
                "elasticfilesystem:ClientWrite",
                "elasticfilesystem:ClientMount"
            ],
            "Resource": "arn:aws:elasticfilesystem:us-east-2:589722580343:file-system/fs-091066a9bf9becbd5"
        }
    ]
}</pre></li><li class="listitem"><p class="simpara">
							Create an AWS EFS volume storage class using a similar configuration to the following:
						</p><pre class="programlisting language-yaml"># The cross account efs volume storageClass
kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: efs-cross-account-mount-sc
provisioner: efs.csi.aws.com
mountOptions:
  - tls
parameters:
  provisioningMode: efs-ap
  fileSystemId: fs-00f6c3ae6f06388bb
  directoryPerms: "700"
  gidRangeStart: "1000"
  gidRangeEnd: "2000"
  basePath: "/account-a-data"
  csi.storage.k8s.io/provisioner-secret-name: my-efs-cross-account
  csi.storage.k8s.io/provisioner-secret-namespace: openshift-cluster-csi-drivers
volumeBindingMode: Immediate</pre></li></ol></div></section><section class="section" id="efs-create-volume_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.6. Creating and configuring access to EFS volumes in AWS</h3></div></div></div><p>
					This procedure explains how to create and configure EFS volumes in AWS so that you can use them in OpenShift Container Platform.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							AWS account credentials
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To create and configure access to an EFS volume in AWS:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							On the AWS console, open <a class="link" href="https://console.aws.amazon.com/efs">https://console.aws.amazon.com/efs</a>.
						</li><li class="listitem"><p class="simpara">
							Click <span class="strong strong"><strong>Create file system</strong></span>:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									Enter a name for the file system.
								</li><li class="listitem">
									For <span class="strong strong"><strong>Virtual Private Cloud (VPC)</strong></span>, select your OpenShift Container Platform’s' virtual private cloud (VPC).
								</li><li class="listitem">
									Accept default settings for all other selections.
								</li></ul></div></li><li class="listitem"><p class="simpara">
							Wait for the volume and mount targets to finish being fully created:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Go to <a class="link" href="https://console.aws.amazon.com/efs#/file-systems">https://console.aws.amazon.com/efs#/file-systems</a>.
								</li><li class="listitem">
									Click your volume, and on the <span class="strong strong"><strong>Network</strong></span> tab wait for all mount targets to become available (~1-2 minutes).
								</li></ol></div></li><li class="listitem">
							On the <span class="strong strong"><strong>Network</strong></span> tab, copy the Security Group ID (you will need this in the next step).
						</li><li class="listitem">
							Go to <a class="link" href="https://console.aws.amazon.com/ec2/v2/home#SecurityGroups">https://console.aws.amazon.com/ec2/v2/home#SecurityGroups</a>, and find the Security Group used by the EFS volume.
						</li><li class="listitem"><p class="simpara">
							On the <span class="strong strong"><strong>Inbound rules</strong></span> tab, click <span class="strong strong"><strong>Edit inbound rules</strong></span>, and then add a new rule with the following settings to allow OpenShift Container Platform nodes to access EFS volumes :
						</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									<span class="strong strong"><strong>Type</strong></span>: NFS
								</li><li class="listitem">
									<span class="strong strong"><strong>Protocol</strong></span>: TCP
								</li><li class="listitem">
									<span class="strong strong"><strong>Port range</strong></span>: 2049
								</li><li class="listitem"><p class="simpara">
									<span class="strong strong"><strong>Source</strong></span>: Custom/IP address range of your nodes (for example: “10.0.0.0/16”)
								</p><p class="simpara">
									This step allows OpenShift Container Platform to use NFS ports from the cluster.
								</p></li></ul></div></li><li class="listitem">
							Save the rule.
						</li></ol></div></section><section class="section" id="csi-dynamic-provisioning-aws-efs_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.7. Dynamic provisioning for Amazon Elastic File Storage</h3></div></div></div><p class="_abstract _abstract">
					The <a class="link" href="https://github.com/openshift/aws-efs-csi-driver">AWS EFS CSI driver</a> supports a different form of dynamic provisioning than other CSI drivers. It provisions new PVs as subdirectories of a pre-existing EFS volume. The PVs are independent of each other. However, they all share the same EFS volume. When the volume is deleted, all PVs provisioned out of it are deleted too. The EFS CSI driver creates an AWS Access Point for each such subdirectory. Due to AWS AccessPoint limits, you can only dynamically provision 1000 PVs from a single <code class="literal">StorageClass</code>/EFS volume.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						Note that <code class="literal">PVC.spec.resources</code> is not enforced by EFS.
					</p><p>
						In the example below, you request 5 GiB of space. However, the created PV is limitless and can store any amount of data (like petabytes). A broken application, or even a rogue application, can cause significant expenses when it stores too much data on the volume.
					</p><p>
						Using monitoring of EFS volume sizes in AWS is strongly recommended.
					</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You have created Amazon Elastic File Storage (Amazon EFS) volumes.
						</li><li class="listitem">
							You have created the AWS EFS storage class.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To enable dynamic provisioning:
					</p></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Create a PVC (or StatefulSet or Template) as usual, referring to the <code class="literal">StorageClass</code> created previously.
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: test
spec:
  storageClassName: efs-sc
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi</pre></li></ul></div><p>
					If you have problems setting up dynamic provisioning, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#efs-troubleshooting_persistent-storage-csi-aws-efs">AWS EFS troubleshooting</a>.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#efs-create-volume_persistent-storage-csi-aws-efs">Creating and configuring access to AWS EFS volume(s)</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#storage-create-storage-class_persistent-storage-csi-aws-efs">Creating the AWS EFS storage class</a>
						</li></ul></div></section><section class="section" id="efs-create-static-pv_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.8. Creating static PVs with Amazon Elastic File Storage</h3></div></div></div><p>
					It is possible to use an Amazon Elastic File Storage (Amazon EFS) volume as a single PV without any dynamic provisioning. The whole volume is mounted to pods.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You have created Amazon EFS volumes.
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							Create the PV using the following YAML file:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolume
metadata:
  name: efs-pv
spec:
  capacity: <span id="CO82-1"><!--Empty--></span><span class="callout">1</span>
    storage: 5Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteMany
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  csi:
    driver: efs.csi.aws.com
    volumeHandle: fs-ae66151a <span id="CO82-2"><!--Empty--></span><span class="callout">2</span>
    volumeAttributes:
      encryptInTransit: "false" <span id="CO82-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO82-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									<code class="literal">spec.capacity</code> does not have any meaning and is ignored by the CSI driver. It is used only when binding to a PVC. Applications can store any amount of data to the volume.
								</div></dd><dt><a href="#CO82-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									<code class="literal">volumeHandle</code> must be the same ID as the EFS volume you created in AWS. If you are providing your own access point, <code class="literal">volumeHandle</code> should be <code class="literal">&lt;EFS volume ID&gt;::&lt;access point ID&gt;</code>. For example: <code class="literal">fs-6e633ada::fsap-081a1d293f0004630</code>.
								</div></dd><dt><a href="#CO82-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									If desired, you can disable encryption in transit. Encryption is enabled by default.
								</div></dd></dl></div></li></ul></div><p>
					If you have problems setting up static PVs, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#efs-troubleshooting_persistent-storage-csi-aws-efs">AWS EFS troubleshooting</a>.
				</p></section><section class="section" id="efs-security_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.9. Amazon Elastic File Storage security</h3></div></div></div><p>
					The following information is important for Amazon Elastic File Storage (Amazon EFS) security.
				</p><p>
					When using access points, for example, by using dynamic provisioning as described earlier, Amazon automatically replaces GIDs on files with the GID of the access point. In addition, EFS considers the user ID, group ID, and secondary group IDs of the access point when evaluating file system permissions. EFS ignores the NFS client’s IDs. For more information about access points, see <a class="link" href="https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html">https://docs.aws.amazon.com/efs/latest/ug/efs-access-points.html</a>.
				</p><p>
					As a consequence, EFS volumes silently ignore FSGroup; OpenShift Container Platform is not able to replace the GIDs of files on the volume with FSGroup. Any pod that can access a mounted EFS access point can access any file on it.
				</p><p>
					Unrelated to this, encryption in transit is enabled by default. For more information, see <a class="link" href="https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html">https://docs.aws.amazon.com/efs/latest/ug/encryption-in-transit.html</a>.
				</p></section><section class="section" id="efs-troubleshooting_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.10. Amazon Elastic File Storage troubleshooting</h3></div></div></div><p>
					The following information provides guidance on how to troubleshoot issues with Amazon Elastic File Storage (Amazon EFS):
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The AWS EFS Operator and CSI driver run in namespace <code class="literal">openshift-cluster-csi-drivers</code>.
						</li><li class="listitem"><p class="simpara">
							To initiate gathering of logs of the AWS EFS Operator and CSI driver, run the following command:
						</p><pre class="programlisting language-terminal">$ oc adm must-gather
[must-gather      ] OUT Using must-gather plugin-in image: quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:125f183d13601537ff15b3239df95d47f0a604da2847b561151fedd699f5e3a5
[must-gather      ] OUT namespace/openshift-must-gather-xm4wq created
[must-gather      ] OUT clusterrolebinding.rbac.authorization.k8s.io/must-gather-2bd8x created
[must-gather      ] OUT pod for plug-in image quay.io/openshift-release-dev/ocp-v4.0-art-dev@sha256:125f183d13601537ff15b3239df95d47f0a604da2847b561151fedd699f5e3a5 created</pre></li><li class="listitem"><p class="simpara">
							To show AWS EFS Operator errors, view the <code class="literal">ClusterCSIDriver</code> status:
						</p><pre class="programlisting language-terminal">$ oc get clustercsidriver efs.csi.aws.com -o yaml</pre></li><li class="listitem"><p class="simpara">
							If a volume cannot be mounted to a pod (as shown in the output of the following command):
						</p><pre class="programlisting language-terminal">$ oc describe pod
...
  Type     Reason       Age    From               Message
  ----     ------       ----   ----               -------
  Normal   Scheduled    2m13s  default-scheduler  Successfully assigned default/efs-app to ip-10-0-135-94.ec2.internal
  Warning  FailedMount  13s    kubelet            MountVolume.SetUp failed for volume "pvc-d7c097e6-67ec-4fae-b968-7e7056796449" : rpc error: code = DeadlineExceeded desc = context deadline exceeded <span id="CO83-1"><!--Empty--></span><span class="callout">1</span>
  Warning  FailedMount  10s    kubelet            Unable to attach or mount volumes: unmounted volumes=[persistent-storage], unattached volumes=[persistent-storage kube-api-access-9j477]: timed out waiting for the condition</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO83-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Warning message indicating volume not mounted.
								</div></dd></dl></div><p class="simpara">
							This error is frequently caused by AWS dropping packets between an OpenShift Container Platform node and Amazon EFS.
						</p><p class="simpara">
							Check that the following are correct:
						</p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
									AWS firewall and Security Groups
								</li><li class="listitem">
									Networking: port number and IP addresses
								</li></ul></div></li></ul></div></section><section class="section" id="persistent-storage-csi-olm-operator-uninstall_persistent-storage-csi-aws-efs"><div class="titlepage"><div><div><h3 class="title">5.11.11. Uninstalling the AWS EFS CSI Driver Operator</h3></div></div></div><p>
					All EFS PVs are inaccessible after uninstalling the <a class="link" href="https://github.com/openshift/aws-efs-csi-driver-operator">AWS EFS CSI Driver Operator</a> (a Red Hat operator).
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to the OpenShift Container Platform web console.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To uninstall the AWS EFS CSI Driver Operator from the web console:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Log in to the web console.
						</li><li class="listitem">
							Stop all applications that use AWS EFS PVs.
						</li><li class="listitem"><p class="simpara">
							Delete all AWS EFS PVs:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>PersistentVolumeClaims</strong></span>.
								</li><li class="listitem">
									Select each PVC that is in use by the AWS EFS CSI Driver Operator, click the drop-down menu on the far right of the PVC, and then click <span class="strong strong"><strong>Delete PersistentVolumeClaims</strong></span>.
								</li></ol></div></li><li class="listitem"><p class="simpara">
							Uninstall the <a class="link" href="https://github.com/openshift/aws-efs-csi-driver">AWS EFS CSI driver</a>:
						</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								Before you can uninstall the Operator, you must remove the CSI driver first.
							</p></div></div><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Click <span class="strong strong"><strong>Administration</strong></span> → <span class="strong strong"><strong>CustomResourceDefinitions</strong></span> → <span class="strong strong"><strong>ClusterCSIDriver</strong></span>.
								</li><li class="listitem">
									On the <span class="strong strong"><strong>Instances</strong></span> tab, for <span class="strong strong"><strong>efs.csi.aws.com</strong></span>, on the far left side, click the drop-down menu, and then click <span class="strong strong"><strong>Delete ClusterCSIDriver</strong></span>.
								</li><li class="listitem">
									When prompted, click <span class="strong strong"><strong>Delete</strong></span>.
								</li></ol></div></li><li class="listitem"><p class="simpara">
							Uninstall the AWS EFS CSI Operator:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Click <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>Installed Operators</strong></span>.
								</li><li class="listitem">
									On the <span class="strong strong"><strong>Installed Operators</strong></span> page, scroll or type AWS EFS CSI into the <span class="strong strong"><strong>Search by name</strong></span> box to find the Operator, and then click it.
								</li><li class="listitem">
									On the upper, right of the <span class="strong strong"><strong>Installed Operators &gt; Operator details</strong></span> page, click <span class="strong strong"><strong>Actions</strong></span> → <span class="strong strong"><strong>Uninstall Operator</strong></span>.
								</li><li class="listitem"><p class="simpara">
									When prompted on the <span class="strong strong"><strong>Uninstall Operator</strong></span> window, click the <span class="strong strong"><strong>Uninstall</strong></span> button to remove the Operator from the namespace. Any applications deployed by the Operator on the cluster need to be cleaned up manually.
								</p><p class="simpara">
									After uninstalling, the AWS EFS CSI Driver Operator is no longer listed in the <span class="strong strong"><strong>Installed Operators</strong></span> section of the web console.
								</p></li></ol></div></li></ol></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Before you can destroy a cluster (<code class="literal">openshift-install destroy cluster</code>), you must delete the EFS volume in AWS. An OpenShift Container Platform cluster cannot be destroyed when there is an EFS volume that uses the cluster’s VPC. Amazon does not allow deletion of such a VPC.
					</p></div></div></section><section class="section _additional-resources" id="additional-resources"><div class="titlepage"><div><div><h3 class="title">5.11.12. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-azure-disk"><div class="titlepage"><div><div><h2 class="title">5.12. Azure Disk CSI Driver Operator</h2></div></div></div><section class="section" id="overview-4"><div class="titlepage"><div><div><h3 class="title">5.12.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Microsoft Azure Disk Storage.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to Azure Disk storage assets, OpenShift Container Platform installs the Azure Disk CSI Driver Operator and the Azure Disk CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>Azure Disk CSI Driver Operator</em></span> provides a storage class named <code class="literal">managed-csi</code> that you can use to create persistent volume claims (PVCs). The Azure Disk CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							The <span class="emphasis"><em>Azure Disk CSI driver</em></span> enables you to create and mount Azure Disk PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-azure"><div class="titlepage"><div><div><h3 class="title">5.12.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						OpenShift Container Platform defaults to using the CSI plugin to provision Azure Disk storage.
					</p></div></div></section><section class="section" id="persistent-storage-csi-azure-disk-sc-zrs_persistent-storage-csi-azure"><div class="titlepage"><div><div><h3 class="title">5.12.3. Creating a storage class with storage account type</h3></div></div></div><p>
					Storage classes are used to differentiate and delineate storage levels and usages. By defining a storage class, you can obtain dynamically provisioned persistent volumes.
				</p><p>
					When creating a storage class, you can designate the storage account type. This corresponds to your Azure storage account SKU tier. Valid options are <code class="literal">Standard_LRS</code>, <code class="literal">Premium_LRS</code>, <code class="literal">StandardSSD_LRS</code>, <code class="literal">UltraSSD_LRS</code>, <code class="literal">Premium_ZRS</code>, <code class="literal">StandardSSD_ZRS</code>, and <code class="literal">PremiumV2_LRS</code>. For information about finding your Azure SKU tier, see <a class="link" href="https://learn.microsoft.com/en-us/rest/api/storagerp/srp_sku_types">SKU Types</a>.
				</p><p>
					Both ZRS and PremiumV2_LRS have some region limitations. For information about these limitations, see <a class="link" href="https://learn.microsoft.com/en-us/azure/virtual-machines/disks-deploy-zrs?tabs=portal#limitations">ZRS limitations</a> and <a class="link" href="https://learn.microsoft.com/en-us/azure/virtual-machines/disks-deploy-premium-v2?tabs=azure-cli#limitations">Premium_LRS limitations</a>.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to an OpenShift Container Platform cluster with administrator rights
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						Use the following steps to create a storage class with a storage account type.
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a storage class designating the storage account type using a YAML file similar to the following:
						</p><pre class="programlisting language-terminal">$ oc create -f - &lt;&lt; EOF
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class&gt; <span id="CO84-1"><!--Empty--></span><span class="callout">1</span>
provisioner: disk.csi.azure.com
parameters:
  skuName: &lt;storage-class-account-type&gt; <span id="CO84-2"><!--Empty--></span><span class="callout">2</span>
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
EOF</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO84-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Storage class name.
								</div></dd><dt><a href="#CO84-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									Storage account type. This corresponds to your Azure storage account SKU tier:`Standard_LRS`, <code class="literal">Premium_LRS</code>, <code class="literal">StandardSSD_LRS</code>, <code class="literal">UltraSSD_LRS</code>, <code class="literal">Premium_ZRS</code>, <code class="literal">StandardSSD_ZRS</code>, <code class="literal">PremiumV2_LRS</code>.
								</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								For PremiumV2_LRS, specify <code class="literal">cachingMode: None</code> in <code class="literal">storageclass.parameters</code>.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Ensure that the storage class was created by listing the storage classes:
						</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">$ oc get storageclass
NAME                    PROVISIONER          RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
azurefile-csi           file.csi.azure.com   Delete          Immediate              true                   68m
managed-csi (default)   disk.csi.azure.com   Delete          WaitForFirstConsumer   true                   68m
sc-prem-zrs             disk.csi.azure.com   Delete          WaitForFirstConsumer   true                   4m25s <span id="CO85-1"><!--Empty--></span><span class="callout">1</span></pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO85-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									New storage class with storage account type.
								</div></dd></dl></div></li></ol></div></section><section class="section" id="byok_persistent-storage-csi-azure"><div class="titlepage"><div><div><h3 class="title">5.12.4. User-managed encryption</h3></div></div></div><p>
					The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <code class="literal">platform.&lt;cloud_type&gt;.defaultMachinePlatform</code> field in the install-config YAML file.
				</p><p>
					This features supports the following storage types:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Amazon Web Services (AWS) Elastic Block storage (EBS)
						</li><li class="listitem">
							Microsoft Azure Disk storage
						</li><li class="listitem">
							Google Cloud Platform (GCP) persistent disk (PD) storage
						</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If the OS (root) disk is encrypted, and there is no encrypted key defined in the storage class, Azure Disk CSI driver uses the OS disk encryption key by default to encrypt provisioned storage volumes.
					</p></div></div><p>
					For information about installing with user-managed encryption for Azure, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#enabling-user-managed-encryption-on-azure">Enabling user-managed encryption for Azure</a>.
				</p></section><section class="section" id="machineset-azure-ultra-disk_persistent-storage-csi-azure"><div class="titlepage"><div><div><h3 class="title">5.12.5. Machine sets that deploy machines with ultra disks using PVCs</h3></div></div></div><p>
					You can create a machine set running on Azure that deploys machines with ultra disks. Ultra disks are high-performance storage that are intended for use with the most demanding data workloads.
				</p><p>
					Both the in-tree plugin and CSI driver support using PVCs to enable ultra disks. You can also deploy machines with ultra disks as data disks without creating a PVC.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://docs.microsoft.com/en-us/azure/virtual-machines/disks-types#ultra-disks">Microsoft Azure ultra disks documentation</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#machineset-azure-ultra-disk_persistent-storage-azure">Machine sets that deploy machines on ultra disks using in-tree PVCs</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/machine_management/#machineset-azure-ultra-disk_creating-machineset-azure">Machine sets that deploy machines on ultra disks as data disks</a>
						</li></ul></div><section class="section" id="machineset-creating-azure-ultra-disk_persistent-storage-csi-azure"><div class="titlepage"><div><div><h4 class="title">5.12.5.1. Creating machines with ultra disks by using machine sets</h4></div></div></div><p>
						You can deploy machines with ultra disks on Azure by editing your machine set YAML file.
					</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
								Have an existing Microsoft Azure cluster.
							</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Copy an existing Azure <code class="literal">MachineSet</code> custom resource (CR) and edit it by running the following command:
							</p><pre class="programlisting language-terminal">$ oc edit machineset &lt;machine-set-name&gt;</pre><p class="simpara">
								where <code class="literal">&lt;machine-set-name&gt;</code> is the machine set that you want to provision machines with ultra disks.
							</p></li><li class="listitem"><p class="simpara">
								Add the following lines in the positions indicated:
							</p><pre class="programlisting language-yaml">apiVersion: machine.openshift.io/v1beta1
kind: MachineSet
spec:
  template:
    spec:
      metadata:
        labels:
          disk: ultrassd <span id="CO86-1"><!--Empty--></span><span class="callout">1</span>
      providerSpec:
        value:
          ultraSSDCapability: Enabled <span id="CO86-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO86-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify a label to use to select a node that is created by this machine set. This procedure uses <code class="literal">disk.ultrassd</code> for this value.
									</div></dd><dt><a href="#CO86-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										These lines enable the use of ultra disks.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create a machine set using the updated configuration by running the following command:
							</p><pre class="programlisting language-terminal">$ oc create -f &lt;machine-set-name&gt;.yaml</pre></li><li class="listitem"><p class="simpara">
								Create a storage class that contains the following YAML definition:
							</p><pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: ultra-disk-sc <span id="CO87-1"><!--Empty--></span><span class="callout">1</span>
parameters:
  cachingMode: None
  diskIopsReadWrite: "2000" <span id="CO87-2"><!--Empty--></span><span class="callout">2</span>
  diskMbpsReadWrite: "320" <span id="CO87-3"><!--Empty--></span><span class="callout">3</span>
  kind: managed
  skuname: UltraSSD_LRS
provisioner: disk.csi.azure.com <span id="CO87-4"><!--Empty--></span><span class="callout">4</span>
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer <span id="CO87-5"><!--Empty--></span><span class="callout">5</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO87-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the name of the storage class. This procedure uses <code class="literal">ultra-disk-sc</code> for this value.
									</div></dd><dt><a href="#CO87-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										Specify the number of IOPS for the storage class.
									</div></dd><dt><a href="#CO87-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										Specify the throughput in MBps for the storage class.
									</div></dd><dt><a href="#CO87-4"><span class="callout">4</span></a> </dt><dd><div class="para">
										For Azure Kubernetes Service (AKS) version 1.21 or later, use <code class="literal">disk.csi.azure.com</code>. For earlier versions of AKS, use <code class="literal">kubernetes.io/azure-disk</code>.
									</div></dd><dt><a href="#CO87-5"><span class="callout">5</span></a> </dt><dd><div class="para">
										Optional: Specify this parameter to wait for the creation of the pod that will use the disk.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create a persistent volume claim (PVC) to reference the <code class="literal">ultra-disk-sc</code> storage class that contains the following YAML definition:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ultra-disk <span id="CO88-1"><!--Empty--></span><span class="callout">1</span>
spec:
  accessModes:
  - ReadWriteOnce
  storageClassName: ultra-disk-sc <span id="CO88-2"><!--Empty--></span><span class="callout">2</span>
  resources:
    requests:
      storage: 4Gi <span id="CO88-3"><!--Empty--></span><span class="callout">3</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO88-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the name of the PVC. This procedure uses <code class="literal">ultra-disk</code> for this value.
									</div></dd><dt><a href="#CO88-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										This PVC references the <code class="literal">ultra-disk-sc</code> storage class.
									</div></dd><dt><a href="#CO88-3"><span class="callout">3</span></a> </dt><dd><div class="para">
										Specify the size for the storage class. The minimum value is <code class="literal">4Gi</code>.
									</div></dd></dl></div></li><li class="listitem"><p class="simpara">
								Create a pod that contains the following YAML definition:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: nginx-ultra
spec:
  nodeSelector:
    disk: ultrassd <span id="CO89-1"><!--Empty--></span><span class="callout">1</span>
  containers:
  - name: nginx-ultra
    image: alpine:latest
    command:
      - "sleep"
      - "infinity"
    volumeMounts:
    - mountPath: "/mnt/azure"
      name: volume
  volumes:
    - name: volume
      persistentVolumeClaim:
        claimName: ultra-disk <span id="CO89-2"><!--Empty--></span><span class="callout">2</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO89-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Specify the label of the machine set that enables the use of ultra disks. This procedure uses <code class="literal">disk.ultrassd</code> for this value.
									</div></dd><dt><a href="#CO89-2"><span class="callout">2</span></a> </dt><dd><div class="para">
										This pod references the <code class="literal">ultra-disk</code> PVC.
									</div></dd></dl></div></li></ol></div><div class="orderedlist"><p class="title"><strong>Verification</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Validate that the machines are created by running the following command:
							</p><pre class="programlisting language-terminal">$ oc get machines</pre><p class="simpara">
								The machines should be in the <code class="literal">Running</code> state.
							</p></li><li class="listitem"><p class="simpara">
								For a machine that is running and has a node attached, validate the partition by running the following command:
							</p><pre class="programlisting language-terminal">$ oc debug node/&lt;node-name&gt; -- chroot /host lsblk</pre><p class="simpara">
								In this command, <code class="literal">oc debug node/&lt;node-name&gt;</code> starts a debugging shell on the node <code class="literal">&lt;node-name&gt;</code> and passes a command with <code class="literal">--</code>. The passed command <code class="literal">chroot /host</code> provides access to the underlying host OS binaries, and <code class="literal">lsblk</code> shows the block devices that are attached to the host OS machine.
							</p></li></ol></div><div class="itemizedlist"><p class="title"><strong>Next steps</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								To use an ultra disk from within a pod, create a workload that uses the mount point. Create a YAML file similar to the following example:
							</p><pre class="programlisting language-yaml">apiVersion: v1
kind: Pod
metadata:
  name: ssd-benchmark1
spec:
  containers:
  - name: ssd-benchmark1
    image: nginx
    ports:
      - containerPort: 80
        name: "http-server"
    volumeMounts:
    - name: lun0p1
      mountPath: "/tmp"
  volumes:
    - name: lun0p1
      hostPath:
        path: /var/lib/lun0p1
        type: DirectoryOrCreate
  nodeSelector:
    disktype: ultrassd</pre></li></ul></div></section><section class="section" id="machineset-troubleshooting-azure-ultra-disk_persistent-storage-csi-azure"><div class="titlepage"><div><div><h4 class="title">5.12.5.2. Troubleshooting resources for machine sets that enable ultra disks</h4></div></div></div><p>
						Use the information in this section to understand and recover from issues you might encounter.
					</p><section class="section" id="ts-pvc-mounting-ultra_persistent-storage-csi-azure"><div class="titlepage"><div><div><h5 class="title">5.12.5.2.1. Unable to mount a persistent volume claim backed by an ultra disk</h5></div></div></div><p>
							If there is an issue mounting a persistent volume claim backed by an ultra disk, the pod becomes stuck in the <code class="literal">ContainerCreating</code> state and an alert is triggered.
						</p><p>
							For example, if the <code class="literal">additionalCapabilities.ultraSSDEnabled</code> parameter is not set on the machine that backs the node that hosts the pod, the following error message appears:
						</p><pre class="programlisting language-terminal">StorageAccountType UltraSSD_LRS can be used only when additionalCapabilities.ultraSSDEnabled is set.</pre><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
									To resolve this issue, describe the pod by running the following command:
								</p><pre class="programlisting language-terminal">$ oc -n &lt;stuck_pod_namespace&gt; describe pod &lt;stuck_pod_name&gt;</pre></li></ul></div></section></section></section><section class="section _additional-resources" id="additional-resources_persistent-storage-csi-azure"><div class="titlepage"><div><div><h3 class="title">5.12.6. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-using-azure">Persistent storage using Azure Disk</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-azure-file"><div class="titlepage"><div><div><h2 class="title">5.13. Azure File CSI Driver Operator</h2></div></div></div><section class="section" id="overview-5"><div class="titlepage"><div><div><h3 class="title">5.13.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) by using the Container Storage Interface (CSI) driver for Microsoft Azure File Storage.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to Azure File storage assets, OpenShift Container Platform installs the Azure File CSI Driver Operator and the Azure File CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>Azure File CSI Driver Operator</em></span> provides a storage class that is named <code class="literal">azurefile-csi</code> that you can use to create persistent volume claims (PVCs). You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							The <span class="emphasis"><em>Azure File CSI driver</em></span> enables you to create and mount Azure File PVs. The Azure File CSI driver supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage.
						</li></ul></div><p>
					Azure File CSI Driver Operator does not support:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Virtual hard disks (VHD)
						</li><li class="listitem">
							Network File System (NFS): OpenShift Container Platform does not deploy a NFS-backed storage class.
						</li></ul></div><p>
					For more information about supported features, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#csi-drivers-supported_persistent-storage-csi">Supported CSI drivers and features</a>.
				</p></section><section class="section" id="csi-about_persistent-storage-csi-azure-file"><div class="titlepage"><div><div><h3 class="title">5.13.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="itemizedlist"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-using-azure-file">Persistent storage using Azure File</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-azure-stack-hub"><div class="titlepage"><div><div><h2 class="title">5.14. Azure Stack Hub CSI Driver Operator</h2></div></div></div><section class="section" id="overview-6"><div class="titlepage"><div><div><h3 class="title">5.14.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Azure Stack Hub Storage. Azure Stack Hub, which is part of the Azure Stack portfolio, allows you to run apps in an on-premises environment and deliver Azure services in your datacenter.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to Azure Stack Hub storage assets, OpenShift Container Platform installs the Azure Stack Hub CSI Driver Operator and the Azure Stack Hub CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>Azure Stack Hub CSI Driver Operator</em></span> provides a storage class (<code class="literal">managed-csi</code>), with "Standard_LRS" as the default storage account type, that you can use to create persistent volume claims (PVCs). The Azure Stack Hub CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage.
						</li><li class="listitem">
							The <span class="emphasis"><em>Azure Stack Hub CSI driver</em></span> enables you to create and mount Azure Stack Hub PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-azure-stack-hub"><div class="titlepage"><div><div><h3 class="title">5.14.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section _additional-resources" id="additional-resources-2"><div class="titlepage"><div><div><h3 class="title">5.14.3. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-gcp-pd"><div class="titlepage"><div><div><h2 class="title">5.15. GCP PD CSI Driver Operator</h2></div></div></div><section class="section" id="overview-7"><div class="titlepage"><div><div><h3 class="title">5.15.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform can provision persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Google Cloud Platform (GCP) persistent disk (PD) storage.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a Container Storage Interface (CSI) Operator and driver.
				</p><p>
					To create CSI-provisioned persistent volumes (PVs) that mount to GCP PD storage assets, OpenShift Container Platform installs the GCP PD CSI Driver Operator and the GCP PD CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>GCP PD CSI Driver Operator</strong></span>: By default, the Operator provides a storage class that you can use to create PVCs. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>). You also have the option to create the GCP PD storage class as described in <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-using-gce">Persistent storage using GCE Persistent Disk</a>.
						</li><li class="listitem">
							<span class="strong strong"><strong>GCP PD driver</strong></span>: The driver enables you to create and mount GCP PD PVs.
						</li></ul></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						OpenShift Container Platform defaults to using the CSI plugin to provision GCP PD storage.
					</p></div></div></section><section class="section" id="csi-about_persistent-storage-csi-gcp-pd"><div class="titlepage"><div><div><h3 class="title">5.15.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section" id="persistent-storage-csi-gcp-pd-storage-class-ref_persistent-storage-csi-gcp-pd"><div class="titlepage"><div><div><h3 class="title">5.15.3. GCP PD CSI driver storage class parameters</h3></div></div></div><p>
					The Google Cloud Platform (GCP) persistent disk (PD) Container Storage Interface (CSI) driver uses the CSI <code class="literal">external-provisioner</code> sidecar as a controller. This is a separate helper container that is deployed with the CSI driver. The sidecar manages persistent volumes (PVs) by triggering the <code class="literal">CreateVolume</code> operation.
				</p><p>
					The GCP PD CSI driver uses the <code class="literal">csi.storage.k8s.io/fstype</code> parameter key to support dynamic provisioning. The following table describes all the GCP PD CSI storage class parameters that are supported by OpenShift Container Platform.
				</p><div class="table" id="idm140001854532608"><p class="title"><strong>Table 5.5. CreateVolume Parameters</strong></p><div class="table-contents"><table class="gt-4-cols lt-7-rows"><colgroup><col style="width: 18%; " class="col_1"><!--Empty--></col><col style="width: 27%; " class="col_2"><!--Empty--></col><col style="width: 18%; " class="col_3"><!--Empty--></col><col style="width: 36%; " class="col_4"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001854525920" scope="col">Parameter</th><th align="left" valign="top" id="idm140001854524832" scope="col">Values</th><th align="left" valign="top" id="idm140001854523744" scope="col">Default</th><th align="left" valign="top" id="idm140001854522656" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001854525920"> <p>
									<code class="literal">type</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854524832"> <p>
									<code class="literal">pd-ssd</code> or <code class="literal">pd-standard</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854523744"> <p>
									<code class="literal">pd-standard</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854522656"> <p>
									Allows you to choose between standard PVs or solid-state-drive PVs.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001854525920"> <p>
									<code class="literal">replication-type</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854524832"> <p>
									<code class="literal">none</code> or <code class="literal">regional-pd</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854523744"> <p>
									<code class="literal">none</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854522656"> <p>
									Allows you to choose between zonal or regional PVs.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001854525920"> <p>
									<code class="literal">disk-encryption-kms-key</code>
								</p>
								 </td><td align="left" valign="top" headers="idm140001854524832"> <p>
									Fully qualified resource identifier for the key to use to encrypt new disks.
								</p>
								 </td><td align="left" valign="top" headers="idm140001854523744"> <p>
									Empty string
								</p>
								 </td><td align="left" valign="top" headers="idm140001854522656"> <p>
									Uses customer-managed encryption keys (CMEK) to encrypt new disks.
								</p>
								 </td></tr></tbody></table></div></div></section><section class="section" id="persistent-storage-csi-gcp-pd-encrypted-pv_persistent-storage-csi-gcp-pd"><div class="titlepage"><div><div><h3 class="title">5.15.4. Creating a custom-encrypted persistent volume</h3></div></div></div><p>
					When you create a <code class="literal">PersistentVolumeClaim</code> object, OpenShift Container Platform provisions a new persistent volume (PV) and creates a <code class="literal">PersistentVolume</code> object. You can add a custom encryption key in Google Cloud Platform (GCP) to protect a PV in your cluster by encrypting the newly created PV.
				</p><p>
					For encryption, the newly attached PV that you create uses customer-managed encryption keys (CMEK) on a cluster by using a new or existing Google Cloud Key Management Service (KMS) key.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You are logged in to a running OpenShift Container Platform cluster.
						</li><li class="listitem">
							You have created a Cloud KMS key ring and key version.
						</li></ul></div><p>
					For more information about CMEK and Cloud KMS resources, see <a class="link" href="https://cloud.google.com/kubernetes-engine/docs/how-to/using-cmek">Using customer-managed encryption keys (CMEK)</a>.
				</p><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To create a custom-encrypted PV, complete the following steps:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a storage class with the Cloud KMS key. The following example enables dynamic provisioning of encrypted volumes:
						</p><pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: csi-gce-pd-cmek
provisioner: pd.csi.storage.gke.io
volumeBindingMode: "WaitForFirstConsumer"
allowVolumeExpansion: true
parameters:
  type: pd-standard
  disk-encryption-kms-key: projects/&lt;key-project-id&gt;/locations/&lt;location&gt;/keyRings/&lt;key-ring&gt;/cryptoKeys/&lt;key&gt; <span id="CO90-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO90-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									This field must be the resource identifier for the key that will be used to encrypt new disks. Values are case-sensitive. For more information about providing key ID values, see <a class="link" href="https://cloud.google.com/kms/docs/resource-hierarchy#retrieve_resource_id">Retrieving a resource’s ID</a> and <a class="link" href="https://cloud.google.com/kms/docs/getting-resource-ids">Getting a Cloud KMS resource ID</a>.
								</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								You cannot add the <code class="literal">disk-encryption-kms-key</code> parameter to an existing storage class. However, you can delete the storage class and recreate it with the same name and a different set of parameters. If you do this, the provisioner of the existing class must be <code class="literal">pd.csi.storage.gke.io</code>.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Deploy the storage class on your OpenShift Container Platform cluster using the <code class="literal">oc</code> command:
						</p><pre class="programlisting language-terminal">$ oc describe storageclass csi-gce-pd-cmek</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">Name:                  csi-gce-pd-cmek
IsDefaultClass:        No
Annotations:           None
Provisioner:           pd.csi.storage.gke.io
Parameters:            disk-encryption-kms-key=projects/key-project-id/locations/location/keyRings/ring-name/cryptoKeys/key-name,type=pd-standard
AllowVolumeExpansion:  true
MountOptions:          none
ReclaimPolicy:         Delete
VolumeBindingMode:     WaitForFirstConsumer
Events:                none</pre>

							</p></div></li><li class="listitem"><p class="simpara">
							Create a file named <code class="literal">pvc.yaml</code> that matches the name of your storage class object that you created in the previous step:
						</p><pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: podpvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: csi-gce-pd-cmek
  resources:
    requests:
      storage: 6Gi</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								If you marked the new storage class as default, you can omit the <code class="literal">storageClassName</code> field.
							</p></div></div></li><li class="listitem"><p class="simpara">
							Apply the PVC on your cluster:
						</p><pre class="programlisting language-terminal">$ oc apply -f pvc.yaml</pre></li><li class="listitem"><p class="simpara">
							Get the status of your PVC and verify that it is created and bound to a newly provisioned PV:
						</p><pre class="programlisting language-terminal">$ oc get pvc</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME      STATUS    VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS     AGE
podpvc    Bound     pvc-e36abf50-84f3-11e8-8538-42010a800002   10Gi       RWO            csi-gce-pd-cmek  9s</pre>

							</p></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
								If your storage class has the <code class="literal">volumeBindingMode</code> field set to <code class="literal">WaitForFirstConsumer</code>, you must create a pod to use the PVC before you can verify it.
							</p></div></div></li></ol></div><p>
					Your CMEK-protected PV is now ready to use with your OpenShift Container Platform cluster.
				</p></section><section class="section" id="byok_persistent-storage-csi-gcp-pd"><div class="titlepage"><div><div><h3 class="title">5.15.5. User-managed encryption</h3></div></div></div><p>
					The user-managed encryption feature allows you to provide keys during installation that encrypt OpenShift Container Platform node root volumes, and enables all managed storage classes to use these keys to encrypt provisioned storage volumes. You must specify the custom key in the <code class="literal">platform.&lt;cloud_type&gt;.defaultMachinePlatform</code> field in the install-config YAML file.
				</p><p>
					This features supports the following storage types:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Amazon Web Services (AWS) Elastic Block storage (EBS)
						</li><li class="listitem">
							Microsoft Azure Disk storage
						</li><li class="listitem">
							Google Cloud Platform (GCP) persistent disk (PD) storage
						</li></ul></div><p>
					For information about installing with user-managed encryption for GCP PD, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installation-configuration-parameters_installing-gcp-customizations">Installation configuration parameters</a>.
				</p></section><section class="section _additional-resources" id="additional-resources-3"><div class="titlepage"><div><div><h3 class="title">5.15.6. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-using-gce">Persistent storage using GCE Persistent Disk</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-google-cloud-file"><div class="titlepage"><div><div><h2 class="title">5.16. Google Compute Platform Filestore CSI Driver Operator</h2></div></div></div><section class="section" id="persistent-storage-csi-google-cloud-file-overview"><div class="titlepage"><div><div><h3 class="title">5.16.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Google Compute Platform (GCP) Filestore Storage.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						GCP Filestore CSI Driver Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
					</p><p>
						For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
					</p></div></div><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to GCP Filestore Storage assets, you install the GCP Filestore CSI Driver Operator and the GCP Filestore CSI driver in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>GCP Filestore CSI Driver Operator</em></span> does not provide a storage class by default, but <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-google-cloud-file-create-sc_persistent-storage-csi-google-cloud-file">you can create one if needed</a>. The GCP Filestore CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage.
						</li><li class="listitem">
							The <span class="emphasis"><em>GCP Filestore CSI driver</em></span> enables you to create and mount GCP Filestore PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-google-cloud-file"><div class="titlepage"><div><div><h3 class="title">5.16.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section" id="persistent-storage-csi-olm-operator-install_persistent-storage-csi-google-cloud-file"><div class="titlepage"><div><div><h3 class="title">5.16.3. Installing the GCP Filestore CSI Driver Operator</h3></div></div></div><p>
					The Google Compute Platform (GCP) Filestore Container Storage Interface (CSI) Driver Operator is not installed in OpenShift Container Platform by default. Use the following procedure to install the GCP Filestore CSI Driver Operator in your cluster.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							Access to the OpenShift Container Platform web console.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To install the GCP Filestore CSI Driver Operator from the web console:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Log in to the web console.
						</li><li class="listitem"><p class="simpara">
							Enable the Filestore API in the GCE project by running the following command:
						</p><pre class="programlisting language-command">$ gcloud services enable file.googleapis.com  --project &lt;my_gce_project&gt; <span id="CO91-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO91-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Replace <code class="literal">&lt;my_gce_project&gt;</code> with your Google Cloud project.
								</div></dd></dl></div><p class="simpara">
							You can also do this using Google Cloud web console.
						</p></li><li class="listitem"><p class="simpara">
							Install the GCP Filestore CSI Operator:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Click <span class="strong strong"><strong>Operators</strong></span> → <span class="strong strong"><strong>OperatorHub</strong></span>.
								</li><li class="listitem">
									Locate the GCP Filestore CSI Operator by typing <span class="strong strong"><strong>GCP Filestore</strong></span> in the filter box.
								</li><li class="listitem">
									Click the <span class="strong strong"><strong>GCP Filestore CSI Driver Operator</strong></span> button.
								</li><li class="listitem">
									On the <span class="strong strong"><strong>GCP Filestore CSI Driver Operator</strong></span> page, click <span class="strong strong"><strong>Install</strong></span>.
								</li><li class="listitem"><p class="simpara">
									On the <span class="strong strong"><strong>Install Operator</strong></span> page, ensure that:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											<span class="strong strong"><strong>All namespaces on the cluster (default)</strong></span> is selected.
										</li><li class="listitem">
											<span class="strong strong"><strong>Installed Namespace</strong></span> is set to <span class="strong strong"><strong>openshift-cluster-csi-drivers</strong></span>.
										</li></ul></div></li><li class="listitem"><p class="simpara">
									Click <span class="strong strong"><strong>Install</strong></span>.
								</p><p class="simpara">
									After the installation finishes, the GCP Filestore CSI Operator is listed in the <span class="strong strong"><strong>Installed Operators</strong></span> section of the web console.
								</p></li></ol></div></li><li class="listitem"><p class="simpara">
							Install the GCP Filestore CSI Driver:
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Click <span class="strong strong"><strong>administration</strong></span> → <span class="strong strong"><strong>CustomResourceDefinitions</strong></span> → <span class="strong strong"><strong>ClusterCSIDriver</strong></span>.
								</li><li class="listitem"><p class="simpara">
									On the <span class="strong strong"><strong>Instances</strong></span> tab, click <span class="strong strong"><strong>Create ClusterCSIDriver</strong></span>.
								</p><p class="simpara">
									Use the following YAML file:
								</p><pre class="programlisting language-yaml">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
    name: filestore.csi.storage.gke.io
spec:
  managementState: Managed</pre></li><li class="listitem">
									Click <span class="strong strong"><strong>Create</strong></span>.
								</li><li class="listitem"><p class="simpara">
									Wait for the following Conditions to change to a "true" status:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											GCPFilestoreDriverCredentialsRequestControllerAvailable
										</li><li class="listitem">
											GCPFilestoreDriverNodeServiceControllerAvailable
										</li><li class="listitem">
											GCPFilestoreDriverControllerServiceControllerAvailable
										</li></ul></div></li></ol></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://cloud.google.com/endpoints/docs/openapi/enable-api">Enabling an API in your Google Cloud</a>.
						</li><li class="listitem">
							<a class="link" href="https://support.google.com/googleapi/answer/6158841?hl=en">Enabling an API using the Google Cloud web console</a>.
						</li></ul></div></section><section class="section" id="persistent-storage-csi-google-cloud-file-create-sc_persistent-storage-csi-google-cloud-file"><div class="titlepage"><div><div><h3 class="title">5.16.4. Creating a storage class for GCP Filestore Storage</h3></div></div></div><p>
					After installing the Operator, you should create a storage class for dynamic provisioning of Google Compute Platform (GCP) Filestore volumes.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You are logged in to the running OpenShift Container Platform cluster.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To create a storage class:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create a storage class using the following example YAML file:
						</p><div class="formalpara"><p class="title"><strong>Example YAML file</strong></p><p>
								
<pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: filestore-csi
provisioner: filestore.csi.storage.gke.io
parameters:
  network: network-name <span id="CO92-1"><!--Empty--></span><span class="callout">1</span>
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer</pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO92-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Specify the name of the GCP virtual private cloud (VPC) network where Filestore instances should be created in.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Specify the name of the VPC network where Filestore instances should be created in.
						</p><p class="simpara">
							It is recommended to specify the VPC network that the Filestore instances should be created in. If no VPC network is specified, the Container Storage Interface (CSI) driver tries to create the instances in the default VPC network of the project. On IPI installations, the VPC network name is typically the cluster name with the suffix "-network". However, on UPI installations, the VPC network name can be any value chosen by the user.
						</p><p class="simpara">
							You can find out the VPC network name by inspecting the <code class="literal">MachineSets</code> objects with the following command:
						</p><pre class="programlisting language-command">$ oc -n openshift-machine-api get machinesets -o yaml | grep "network:"
            - network: gcp-filestore-network
(...)</pre><p class="simpara">
							In this example, the VPC network name in this cluster is "gcp-filestore-network".
						</p></li></ol></div></section><section class="section" id="persistent-storage-csi-gcp-cloud-file-delete-instances_persistent-storage-csi-google-cloud-file"><div class="titlepage"><div><div><h3 class="title">5.16.5. Destroying clusters and GCP Filestore</h3></div></div></div><p>
					Typically, if you destroy a cluster, the OpenShift Container Platform installer deletes all of the cloud resources that belong to that cluster. However, when a cluster is destroyed, Google Compute Platform (GCP) Filestore instances are not automatically deleted, so you must manually delete all persistent volume claims (PVCs) that use the Filestore storage class before destroying the cluster.
				</p><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						To delete all GCP Filestore PVCs:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							List all PVCs that were created using the storage class <code class="literal">filestore-csi</code>:
						</p><pre class="programlisting language-command">$ oc get pvc -o json -A | jq -r '.items[] | select(.spec.storageClassName == "filestore-csi")</pre></li><li class="listitem"><p class="simpara">
							Delete all of the PVCs listed by the previous command:
						</p><pre class="programlisting language-command">$ oc delete &lt;pvc-name&gt; <span id="CO93-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO93-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Replace &lt;pvc-name&gt; with the name of any PVC that you need to delete.
								</div></dd></dl></div></li></ol></div></section><section class="section _additional-resources" id="additional-resources-4"><div class="titlepage"><div><div><h3 class="title">5.16.6. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-ibm-vpc-block"><div class="titlepage"><div><div><h2 class="title">5.17. IBM VPC Block CSI Driver Operator</h2></div></div></div><section class="section" id="overview-8"><div class="titlepage"><div><div><h3 class="title">5.17.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for IBM Virtual Private Cloud (VPC) Block Storage.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to IBM VPC Block storage assets, OpenShift Container Platform installs the IBM VPC Block CSI Driver Operator and the IBM VPC Block CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>IBM VPC Block CSI Driver Operator</em></span> provides three storage classes named <code class="literal">ibmc-vpc-block-10iops-tier</code> (default), <code class="literal">ibmc-vpc-block-5iops-tier</code>, and <code class="literal">ibmc-vpc-block-custom</code> for different tiers that you can use to create persistent volume claims (PVCs). The IBM VPC Block CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							The <span class="emphasis"><em>IBM VPC Block CSI driver</em></span> enables you to create and mount IBM VPC Block PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-ibm-vpc-block"><div class="titlepage"><div><div><h3 class="title">5.17.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="itemizedlist"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-ibm-powervs-block"><div class="titlepage"><div><div><h2 class="title">5.18. IBM Power Virtual Server Block CSI Driver Operator</h2></div></div></div><section class="section" id="persistent-storage-csi-ibm-powervs-block-introduction_persistent-storage-csi-ibm-powervs-block"><div class="titlepage"><div><div><h3 class="title">5.18.1. Introduction</h3></div></div></div><p>
					The IBM Power Virtual Server Block CSI Driver will be installed through IBM Power Virtual Server Block CSI Driver Operator and the operator is based on libarary-go. The OpenShift library-go is a collection of functions that allow us to build OpenShift operators easily. Most of the functionality of a CSI driver operator is already available there. The IBM Power Virtual Server Block CSI Driver Operator is installed by the cluster-storage-operator. The Cluster-storage-operator installs the IBM Power Virtual Server Block CSI Driver Operator if the Platform type is Power Virtual Servers.
				</p></section><section class="section" id="persistent-storage-csi-ibm-powervs-block-overview_persistent-storage-csi-ibm-powervs-block"><div class="titlepage"><div><div><h3 class="title">5.18.2. Overview</h3></div></div></div><p>
					OpenShift Container Platform can provision persistent volumes (PVs) by using the Container Storage Interface (CSI) driver for IBM Power Virtual Server Block Storage.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						IBM Power Virtual Server Block CSI Driver Operator is a Technology Preview feature only. Technology Preview features are not supported with Red Hat production service level agreements (SLAs) and might not be functionally complete. Red Hat does not recommend using them in production. These features provide early access to upcoming product features, enabling customers to test functionality and provide feedback during the development process.
					</p><p>
						For more information about the support scope of Red Hat Technology Preview features, see <a class="link" href="https://access.redhat.com/support/offerings/techpreview/">Technology Preview Features Support Scope</a>.
					</p></div></div><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is helpful when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to IBM Power Virtual Server Block storage assets, OpenShift Container Platform installs the IBM Power Virtual Server Block CSI Driver Operator and the IBM Power Virtual Server Block CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>IBM Power Virtual Server Block CSI Driver Operator</em></span> provides two storage classes named <code class="literal">ibm-powervs-tier1</code> (default), and <code class="literal">ibm-powervs-tier3</code> for different tiers that you can use to create persistent volume claims (PVCs). The IBM Power Virtual Server Block CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on demand, eliminating the need for cluster administrators to pre-provision storage.
						</li><li class="listitem">
							The <span class="emphasis"><em>IBM Power Virtual Server Block CSI driver</em></span> allows you to create and mount IBM Power Virtual Server Block PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-ibm-powervs-block"><div class="titlepage"><div><div><h3 class="title">5.18.3. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-cinder"><div class="titlepage"><div><div><h2 class="title">5.19. OpenStack Cinder CSI Driver Operator</h2></div></div></div><section class="section" id="overview-9"><div class="titlepage"><div><div><h3 class="title">5.19.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for OpenStack Cinder.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a Container Storage Interface (CSI) Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to OpenStack Cinder storage assets, OpenShift Container Platform installs the OpenStack Cinder CSI Driver Operator and the OpenStack Cinder CSI driver in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>OpenStack Cinder CSI Driver Operator</em></span> provides a CSI storage class that you can use to create PVCs. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							The <span class="emphasis"><em>OpenStack Cinder CSI driver</em></span> enables you to create and mount OpenStack Cinder PVs.
						</li></ul></div><p>
					For OpenShift Container Platform, automatic migration from OpenStack Cinder in-tree to the CSI driver is available as a Technology Preview (TP) feature. With migration enabled, volumes provisioned using the existing in-tree plugin are automatically migrated to use the OpenStack Cinder CSI driver. For more information, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration feature</a>.
				</p></section><section class="section" id="csi-about_persistent-storage-csi-cinder"><div class="titlepage"><div><div><h3 class="title">5.19.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						OpenShift Container Platform defaults to using the CSI plugin to provision Cinder storage.
					</p></div></div></section><section class="section" id="persistent-storage-csi-cinder_persistent-storage-csi-cinder"><div class="titlepage"><div><div><h3 class="title">5.19.3. Making OpenStack Cinder CSI the default storage class</h3></div></div></div><p>
					The OpenStack Cinder CSI driver uses the <code class="literal">cinder.csi.openstack.org</code> parameter key to support dynamic provisioning.
				</p><p>
					To enable OpenStack Cinder CSI provisioning in OpenShift Container Platform, it is recommended that you overwrite the default in-tree storage class with <code class="literal">standard-csi</code>. Alternatively, you can create the persistent volume claim (PVC) and specify the storage class as "standard-csi".
				</p><p>
					In OpenShift Container Platform, the default storage class references the in-tree Cinder driver. However, with CSI automatic migration enabled, volumes created using the default storage class actually use the CSI driver.
				</p><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
						Use the following steps to apply the <code class="literal">standard-csi</code> storage class by overwriting the default in-tree storage class.
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							List the storage class:
						</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME                   PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
standard(default)      cinder.csi.openstack.org   Delete          WaitForFirstConsumer   true                   46h
standard-csi           kubernetes.io/cinder       Delete          WaitForFirstConsumer   true                   46h</pre>

							</p></div></li><li class="listitem"><p class="simpara">
							Change the value of the annotation <code class="literal">storageclass.kubernetes.io/is-default-class</code> to <code class="literal">false</code> for the default storage class, as shown in the following example:
						</p><pre class="programlisting language-terminal">$ oc patch storageclass standard -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "false"}}}'</pre></li><li class="listitem"><p class="simpara">
							Make another storage class the default by adding or modifying the annotation as <code class="literal">storageclass.kubernetes.io/is-default-class=true</code>.
						</p><pre class="programlisting language-terminal">$ oc patch storageclass standard-csi -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "true"}}}'</pre></li><li class="listitem"><p class="simpara">
							Verify that the PVC is now referencing the CSI storage class by default:
						</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
								
<pre class="programlisting language-terminal">NAME                   PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE
standard               kubernetes.io/cinder       Delete          WaitForFirstConsumer   true                   46h
standard-csi(default)  cinder.csi.openstack.org   Delete          WaitForFirstConsumer   true                   46h</pre>

							</p></div></li><li class="listitem"><p class="simpara">
							Optional: You can define a new PVC without having to specify the storage class:
						</p><pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: cinder-claim
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi</pre><p class="simpara">
							A PVC that does not specify a specific storage class is automatically provisioned by using the default storage class.
						</p></li><li class="listitem"><p class="simpara">
							Optional: After the new file has been configured, create it in your cluster:
						</p><pre class="programlisting language-terminal">$ oc create -f cinder-claim.yaml</pre></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-manila"><div class="titlepage"><div><div><h2 class="title">5.20. OpenStack Manila CSI Driver Operator</h2></div></div></div><section class="section" id="overview-10"><div class="titlepage"><div><div><h3 class="title">5.20.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for the <a class="link" href="https://wiki.openstack.org/wiki/Manila">OpenStack Manila</a> shared file system service.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a Container Storage Interface (CSI) Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to Manila storage assets, OpenShift Container Platform installs the Manila CSI Driver Operator and the Manila CSI driver by default on any OpenStack cluster that has the Manila service enabled.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>Manila CSI Driver Operator</em></span> creates the required storage class that is needed to create PVCs for all available Manila share types. The Operator is installed in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
						</li><li class="listitem">
							The <span class="emphasis"><em>Manila CSI driver</em></span> enables you to create and mount Manila PVs. The driver is installed in the <code class="literal">openshift-manila-csi-driver</code> namespace.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-manila"><div class="titlepage"><div><div><h3 class="title">5.20.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section" id="persistent-storage-csi-manila-limitations_persistent-storage-csi-manila"><div class="titlepage"><div><div><h3 class="title">5.20.3. Manila CSI Driver Operator limitations</h3></div></div></div><p>
					The following limitations apply to the Manila Container Storage Interface (CSI) Driver Operator:
				</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Only NFS is supported</span></dt><dd>
								OpenStack Manila supports many network-attached storage protocols, such as NFS, CIFS, and CEPHFS, and these can be selectively enabled in the OpenStack cloud. The Manila CSI Driver Operator in OpenShift Container Platform only supports using the NFS protocol. If NFS is not available and enabled in the underlying OpenStack cloud, you cannot use the Manila CSI Driver Operator to provision storage for OpenShift Container Platform.
							</dd><dt><span class="term">Snapshots are not supported if the back end is CephFS-NFS</span></dt><dd>
								To take snapshots of persistent volumes (PVs) and revert volumes to snapshots, you must ensure that the Manila share type that you are using supports these features. A Red Hat OpenStack administrator must enable support for snapshots (<code class="literal">share type extra-spec snapshot_support</code>) and for creating shares from snapshots (<code class="literal">share type extra-spec create_share_from_snapshot_support</code>) in the share type associated with the storage class you intend to use.
							</dd><dt><span class="term">FSGroups are not supported</span></dt><dd>
								Since Manila CSI provides shared file systems for access by multiple readers and multiple writers, it does not support the use of FSGroups. This is true even for persistent volumes created with the ReadWriteOnce access mode. It is therefore important not to specify the <code class="literal">fsType</code> attribute in any storage class that you manually create for use with Manila CSI Driver.
							</dd></dl></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						In Red Hat OpenStack Platform 16.x and 17.x, the Shared File Systems service (Manila) with CephFS through NFS fully supports serving shares to OpenShift Container Platform through the Manila CSI. However, this solution is not intended for massive scale. Be sure to review important recommendations in <a class="link" href="https://access.redhat.com/articles/6667651">CephFS NFS Manila-CSI Workload Recommendations for Red Hat OpenStack Platform</a>.
					</p></div></div></section><section class="section" id="persistent-storage-csi-manila-dynamic-provisioning_persistent-storage-csi-manila"><div class="titlepage"><div><div><h3 class="title">5.20.4. Dynamically provisioning Manila CSI volumes</h3></div></div></div><p>
					OpenShift Container Platform installs a storage class for each available Manila share type.
				</p><p>
					The YAML files that are created are completely decoupled from Manila and from its Container Storage Interface (CSI) plugin. As an application developer, you can dynamically provision ReadWriteMany (RWX) storage and deploy pods with applications that safely consume the storage using YAML manifests.
				</p><p>
					You can use the same pod and persistent volume claim (PVC) definitions on-premise that you use with OpenShift Container Platform on AWS, GCP, Azure, and other platforms, with the exception of the storage class reference in the PVC definition.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						Manila service is optional. If the service is not enabled in Red Hat OpenStack Platform (RHOSP), the Manila CSI driver is not installed and the storage classes for Manila are not created.
					</p></div></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							RHOSP is deployed with appropriate Manila share infrastructure so that it can be used to dynamically provision and mount volumes in OpenShift Container Platform.
						</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure (UI)</strong></p><p>
						To dynamically create a Manila CSI volume using the web console:
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Persistent Volume Claims</strong></span>.
						</li><li class="listitem">
							In the persistent volume claims overview, click <span class="strong strong"><strong>Create Persistent Volume Claim</strong></span>.
						</li><li class="listitem"><p class="simpara">
							Define the required options on the resulting page.
						</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									Select the appropriate storage class.
								</li><li class="listitem">
									Enter a unique name for the storage claim.
								</li><li class="listitem"><p class="simpara">
									Select the access mode to specify read and write access for the PVC you are creating.
								</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
										Use RWX if you want the persistent volume (PV) that fulfills this PVC to be mounted to multiple pods on multiple nodes in the cluster.
									</p></div></div></li></ol></div></li><li class="listitem">
							Define the size of the storage claim.
						</li><li class="listitem">
							Click <span class="strong strong"><strong>Create</strong></span> to create the persistent volume claim and generate a persistent volume.
						</li></ol></div><div class="formalpara"><p class="title"><strong>Procedure (CLI)</strong></p><p>
						To dynamically create a Manila CSI volume using the command-line interface (CLI):
					</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Create and save a file with the <code class="literal">PersistentVolumeClaim</code> object described by the following YAML:
						</p><div class="formalpara"><p class="title"><strong>pvc-manila.yaml</strong></p><p>
								
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-manila
spec:
  accessModes: <span id="CO94-1"><!--Empty--></span><span class="callout">1</span>
    - ReadWriteMany
  resources:
    requests:
      storage: 10Gi
  storageClassName: csi-manila-gold <span id="CO94-2"><!--Empty--></span><span class="callout">2</span></pre>

							</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO94-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Use RWX if you want the persistent volume (PV) that fulfills this PVC to be mounted to multiple pods on multiple nodes in the cluster.
								</div></dd><dt><a href="#CO94-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									The name of the storage class that provisions the storage back end. Manila storage classes are provisioned by the Operator and have the <code class="literal">csi-manila-</code> prefix.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Create the object you saved in the previous step by running the following command:
						</p><pre class="programlisting language-terminal">$ oc create -f pvc-manila.yaml</pre><p class="simpara">
							A new PVC is created.
						</p></li><li class="listitem"><p class="simpara">
							To verify that the volume was created and is ready, run the following command:
						</p><pre class="programlisting language-terminal">$ oc get pvc pvc-manila</pre><p class="simpara">
							The <code class="literal">pvc-manila</code> shows that it is <code class="literal">Bound</code>.
						</p></li></ol></div><p>
					You can now use the new PVC to configure a pod.
				</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-csi-ovirt"><div class="titlepage"><div><div><h2 class="title">5.21. Red Hat Virtualization CSI Driver Operator</h2></div></div></div><section class="section" id="overview-11"><div class="titlepage"><div><div><h3 class="title">5.21.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform is capable of provisioning persistent volumes (PVs) using the Container Storage Interface (CSI) driver for Red Hat Virtualization (RHV).
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a Container Storage Interface (CSI) Operator and driver.
				</p><p>
					To create CSI-provisioned PVs that mount to RHV storage assets, OpenShift Container Platform installs the oVirt CSI Driver Operator and the oVirt CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							The <span class="emphasis"><em>oVirt CSI Driver Operator</em></span> provides a default <code class="literal">StorageClass</code> object that you can use to create Persistent Volume Claims (PVCs). You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							The <span class="emphasis"><em>oVirt CSI driver</em></span> enables you to create and mount oVirt PVs.
						</li></ul></div></section><section class="section" id="csi-about_persistent-storage-csi-ovirt"><div class="titlepage"><div><div><h3 class="title">5.21.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The oVirt CSI driver does not support snapshots.
					</p></div></div></section><section class="section" id="ovirt-csi-driver-storage-class_persistent-storage-csi-ovirt"><div class="titlepage"><div><div><h3 class="title">5.21.3. Red Hat Virtualization (RHV) CSI driver storage class</h3></div></div></div><p>
					OpenShift Container Platform creates a default object of type <code class="literal">StorageClass</code> named <code class="literal">ovirt-csi-sc</code> which is used for creating dynamically provisioned persistent volumes.
				</p><p>
					To create additional storage classes for different configurations, create and save a file with the <code class="literal">StorageClass</code> object described by the following sample YAML:
				</p><div class="formalpara"><p class="title"><strong>ovirt-storageclass.yaml</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage_class_name&gt;  <span id="CO95-1"><!--Empty--></span><span class="callout">1</span>
  annotations:
    storageclass.kubernetes.io/is-default-class: "&lt;boolean&gt;"  <span id="CO95-2"><!--Empty--></span><span class="callout">2</span>
provisioner: csi.ovirt.org
allowVolumeExpansion: &lt;boolean&gt; <span id="CO95-3"><!--Empty--></span><span class="callout">3</span>
reclaimPolicy: Delete <span id="CO95-4"><!--Empty--></span><span class="callout">4</span>
volumeBindingMode: Immediate <span id="CO95-5"><!--Empty--></span><span class="callout">5</span>
parameters:
  storageDomainName: &lt;rhv-storage-domain-name&gt; <span id="CO95-6"><!--Empty--></span><span class="callout">6</span>
  thinProvisioning: "&lt;boolean&gt;"  <span id="CO95-7"><!--Empty--></span><span class="callout">7</span>
  csi.storage.k8s.io/fstype: &lt;file_system_type&gt; <span id="CO95-8"><!--Empty--></span><span class="callout">8</span></pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO95-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Name of the storage class.
						</div></dd><dt><a href="#CO95-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							Set to <code class="literal">false</code> if the storage class is the default storage class in the cluster. If set to <code class="literal">true</code>, the existing default storage class must be edited and set to <code class="literal">false</code>.
						</div></dd><dt><a href="#CO95-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							<code class="literal">true</code> enables dynamic volume expansion, <code class="literal">false</code> prevents it. <code class="literal">true</code> is recommended.
						</div></dd><dt><a href="#CO95-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							Dynamically provisioned persistent volumes of this storage class are created with this reclaim policy. This default policy is <code class="literal">Delete</code>.
						</div></dd><dt><a href="#CO95-5"><span class="callout">5</span></a> </dt><dd><div class="para">
							Indicates how to provision and bind <code class="literal">PersistentVolumeClaims</code>. When not set, <code class="literal">VolumeBindingImmediate</code> is used. This field is only applied by servers that enable the <code class="literal">VolumeScheduling</code> feature.
						</div></dd><dt><a href="#CO95-6"><span class="callout">6</span></a> </dt><dd><div class="para">
							The RHV storage domain name to use.
						</div></dd><dt><a href="#CO95-7"><span class="callout">7</span></a> </dt><dd><div class="para">
							If <code class="literal">true</code>, the disk is thin provisioned. If <code class="literal">false</code>, the disk is preallocated. Thin provisioning is recommended.
						</div></dd><dt><a href="#CO95-8"><span class="callout">8</span></a> </dt><dd><div class="para">
							Optional: File system type to be created. Possible values: <code class="literal">ext4</code> (default) or <code class="literal">xfs</code>.
						</div></dd></dl></div></section><section class="section" id="persistent-storage-rhv_persistent-storage-csi-ovirt"><div class="titlepage"><div><div><h3 class="title">5.21.4. Creating a persistent volume on RHV</h3></div></div></div><p>
					When you create a <code class="literal">PersistentVolumeClaim</code> (PVC) object, OpenShift Container Platform provisions a new persistent volume (PV) and creates a <code class="literal">PersistentVolume</code> object.
				</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
							You are logged in to a running OpenShift Container Platform cluster.
						</li><li class="listitem">
							You provided the correct RHV credentials in <code class="literal">ovirt-credentials</code> secret.
						</li><li class="listitem">
							You have installed the oVirt CSI driver.
						</li><li class="listitem">
							You have defined at least one storage class.
						</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
							If you are using the web console to dynamically create a persistent volume on RHV:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
									In the OpenShift Container Platform console, click <span class="strong strong"><strong>Storage</strong></span> → <span class="strong strong"><strong>Persistent Volume Claims</strong></span>.
								</li><li class="listitem">
									In the persistent volume claims overview, click <span class="strong strong"><strong>Create Persistent Volume Claim</strong></span>.
								</li><li class="listitem">
									Define the required options on the resulting page.
								</li><li class="listitem">
									Select the appropriate <code class="literal">StorageClass</code> object, which is <code class="literal">ovirt-csi-sc</code> by default.
								</li><li class="listitem">
									Enter a unique name for the storage claim.
								</li><li class="listitem">
									Select the access mode. Currently, RWO (ReadWriteOnce) is the only supported access mode.
								</li><li class="listitem">
									Define the size of the storage claim.
								</li><li class="listitem"><p class="simpara">
									Select the Volume Mode:
								</p><p class="simpara">
									<code class="literal">Filesystem</code>: Mounted into pods as a directory. This mode is the default.
								</p><p class="simpara">
									<code class="literal">Block</code>: Block device, without any file system on it
								</p></li><li class="listitem">
									Click <span class="strong strong"><strong>Create</strong></span> to create the <code class="literal">PersistentVolumeClaim</code> object and generate a <code class="literal">PersistentVolume</code> object.
								</li></ol></div></li><li class="listitem"><p class="simpara">
							If you are using the command-line interface (CLI) to dynamically create a RHV CSI volume:
						</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									Create and save a file with the <code class="literal">PersistentVolumeClaim</code> object described by the following sample YAML:
								</p><div class="formalpara"><p class="title"><strong>pvc-ovirt.yaml</strong></p><p>
										
<pre class="programlisting language-yaml">apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-ovirt
spec:
  storageClassName: ovirt-csi-sc <span id="CO96-1"><!--Empty--></span><span class="callout">1</span>
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: &lt;volume size&gt;  <span id="CO96-2"><!--Empty--></span><span class="callout">2</span>
  volumeMode: &lt;volume mode&gt; <span id="CO96-3"><!--Empty--></span><span class="callout">3</span></pre>

									</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO96-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											Name of the required storage class.
										</div></dd><dt><a href="#CO96-2"><span class="callout">2</span></a> </dt><dd><div class="para">
											Volume size in GiB.
										</div></dd><dt><a href="#CO96-3"><span class="callout">3</span></a> </dt><dd><div class="para">
											Supported options:
										</div><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem">
													<code class="literal">Filesystem</code>: Mounted into pods as a directory. This mode is the default.
												</li><li class="listitem">
													<code class="literal">Block</code>: Block device, without any file system on it.
												</li></ul></div></dd></dl></div></li><li class="listitem"><p class="simpara">
									Create the object you saved in the previous step by running the following command:
								</p><pre class="screen">$ oc create -f pvc-ovirt.yaml</pre></li><li class="listitem"><p class="simpara">
									To verify that the volume was created and is ready, run the following command:
								</p><pre class="screen">$ oc get pvc pvc-ovirt</pre><p class="simpara">
									The <code class="literal">pvc-ovirt</code> shows that it is Bound.
								</p></li></ol></div></li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						If you need to update the Operator credentials, see the instructions in <a class="link" href="https://access.redhat.com/solutions/6115581">How to modify the RHV credentials in OCP 4</a>.
					</p></div></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#csi-dynamic-provisioning_persistent-storage-csi">Dynamic Provisioning</a>
						</li></ul></div></section></section><section class="section" id="persistent-storage-vsphere"><div class="titlepage"><div><div><h2 class="title">5.22. VMware vSphere CSI Driver Operator</h2></div></div></div><section class="section" id="overview-12"><div class="titlepage"><div><div><h3 class="title">5.22.1. Overview</h3></div></div></div><p>
					OpenShift Container Platform can provision persistent volumes (PVs) using the Container Storage Interface (CSI) VMware vSphere driver for Virtual Machine Disk (VMDK) volumes.
				</p><p>
					Familiarity with <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#understanding-persistent-storage">persistent storage</a> and <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">configuring CSI volumes</a> is recommended when working with a CSI Operator and driver.
				</p><p>
					To create CSI-provisioned persistent volumes (PVs) that mount to vSphere storage assets, OpenShift Container Platform installs the vSphere CSI Driver Operator and the vSphere CSI driver by default in the <code class="literal">openshift-cluster-csi-drivers</code> namespace.
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<span class="strong strong"><strong>vSphere CSI Driver Operator</strong></span>: The Operator provides a storage class, called <code class="literal">thin-csi</code>, that you can use to create persistent volumes claims (PVCs). The vSphere CSI Driver Operator supports dynamic volume provisioning by allowing storage volumes to be created on-demand, eliminating the need for cluster administrators to pre-provision storage. You can disable this default storage class if desired (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-sc-manage">Managing the default storage class</a>).
						</li><li class="listitem">
							<span class="strong strong"><strong>vSphere CSI driver</strong></span>: The driver enables you to create and mount vSphere PVs. In OpenShift Container Platform 4.13, the driver version is 3.0.1. The vSphere CSI driver supports all of the file systems supported by the underlying Red Hat Core OS release, including XFS and Ext4. For more information about supported file systems, see <a class="link" href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/managing_file_systems/assembly_overview-of-available-file-systems_managing-file-systems">Overview of available file systems</a>.
						</li></ul></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
						For vSphere:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
								For new installations of OpenShift Container Platform 4.13, or later, automatic migration is enabled by default.
							</p><p class="simpara">
								CSI automatic migration should be seamless. Migration does not change how you use all existing API objects, such as persistent volumes, persistent volume claims, and storage classes. For more information about migration, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-migration">CSI automatic migration</a>.
							</p></li><li class="listitem">
								When upgrading from OpenShift Container Platform 4.12, or earlier, to 4.13, automatic CSI migration for vSphere only occurs if you opt in. If you do not opt in, OpenShift Container Platform defaults to using the in-tree (non-CSI) plugin to provision vSphere storage. <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#upgrading-openshift_persistent-storage-csi-migration">Carefully review the indicated consequences before opting in to migration</a>.
							</li></ul></div><p>
						After full migration, in-tree plugins will eventually be removed in future versions of OpenShift Container Platform.
					</p></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The vSphere CSI Driver supports dynamic and static provisioning. When using static provisioning in the PV specifications, do not use the key <code class="literal">storage.kubernetes.io/csiProvisionerIdentity</code> in <code class="literal">csi.volumeAttributes</code> because this key indicates dynamically provisioned PVs.
					</p></div></div></section><section class="section" id="csi-about_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h3 class="title">5.22.2. About CSI</h3></div></div></div><p>
					Storage vendors have traditionally provided storage drivers as part of Kubernetes. With the implementation of the Container Storage Interface (CSI), third-party providers can instead deliver storage plugins using a standard interface without ever having to change the core Kubernetes code.
				</p><p>
					CSI Operators give OpenShift Container Platform users storage options, such as volume snapshots, that are not possible with in-tree volume plugins.
				</p></section><section class="section" id="persistent-storage-csi-vsphere-stor-policy_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h3 class="title">5.22.3. vSphere storage policy</h3></div></div></div><p>
					The vSphere CSI Operator Driver storage class uses vSphere’s storage policy. OpenShift Container Platform automatically creates a storage policy that targets datastore configured in cloud configuration:
				</p><pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: thin-csi
provisioner: csi.vsphere.vmware.com
parameters:
  StoragePolicyName: "$openshift-storage-policy-xxxx"
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: false
reclaimPolicy: Delete</pre></section><section class="section" id="persistent-storage-csi-vsphere-rwx_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h3 class="title">5.22.4. ReadWriteMany vSphere volume support</h3></div></div></div><p>
					If the underlying vSphere environment supports the vSAN file service, then vSphere Container Storage Interface (CSI) Driver Operator installed by OpenShift Container Platform supports provisioning of ReadWriteMany (RWX) volumes. If vSAN file service is not configured, then ReadWriteOnce (RWO) is the only access mode available. If you do not have vSAN file service configured, and you request RWX, the volume fails to get created and an error is logged.
				</p><p>
					For more information about configuring the vSAN file service in your environment, see <a class="link" href="https://docs.vmware.com/en/VMware-vSphere/7.0/com.vmware.vsphere.vsan.doc/GUID-82565B82-C911-42F7-85B1-E9EF973EE90C.html">vSAN File Service</a>.
				</p><p>
					You can request RWX volumes by making the following persistent volume claim (PVC):
				</p><pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: myclaim
spec:
  resources:
    requests:
      storage: 1Gi
  accessModes:
     - ReadWriteMany
  storageClassName: thin-csi</pre><p>
					Requesting a PVC of the RWX volume type should result in provisioning of persistent volumes (PVs) backed by the vSAN file service.
				</p></section><section class="section" id="vsphere-csi-driver-reqs_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h3 class="title">5.22.5. VMware vSphere CSI Driver Operator requirements</h3></div></div></div><p>
					To install the vSphere CSI Driver Operator, the following requirements must be met:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							VMware vSphere version 7.0 Update 2 or later
						</li><li class="listitem">
							vCenter 7.0 Update 2 or later
						</li><li class="listitem">
							Virtual machines of hardware version 15 or later
						</li><li class="listitem">
							No third-party vSphere CSI driver already installed in the cluster
						</li></ul></div><p>
					If a third-party vSphere CSI driver is present in the cluster, OpenShift Container Platform does not overwrite it. The presence of a third-party vSphere CSI driver prevents OpenShift Container Platform from updating to OpenShift Container Platform 4.13 or later.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The VMware vSphere CSI Driver Operator is supported only on clusters deployed with <code class="literal">platform: vsphere</code> in the installation manifest.
					</p></div></div><p>
					To remove a third-party CSI driver, see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-vsphere-install-issues_persistent-storage-csi-vsphere">Removing a third-party vSphere CSI Driver</a>.
				</p></section><section class="section" id="persistent-storage-csi-vsphere-install-issues_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h3 class="title">5.22.6. Removing a third-party vSphere CSI Operator Driver</h3></div></div></div><p>
					OpenShift Container Platform 4.10, and later, includes a built-in version of the vSphere Container Storage Interface (CSI) Operator Driver that is supported by Red Hat. If you have installed a vSphere CSI driver provided by the community or another vendor, updates to the next major version of OpenShift Container Platform, such as 4.13, or later, might be disabled for your cluster.
				</p><p>
					OpenShift Container Platform 4.12, and later, clusters are still fully supported, and updates to z-stream releases of 4.12, such as 4.12.z, are not blocked, but you must correct this state by removing the third-party vSphere CSI Driver before updates to next major version of OpenShift Container Platform can occur. Removing the third-party vSphere CSI driver does not require deletion of associated persistent volume (PV) objects, and no data loss should occur.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						These instructions may not be complete, so consult the vendor or community provider uninstall guide to ensure removal of the driver and components.
					</p></div></div><p>
					To uninstall the third-party vSphere CSI Driver:
				</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
							Delete the third-party vSphere CSI Driver (VMware vSphere Container Storage Plugin) Deployment and Daemonset objects.
						</li><li class="listitem">
							Delete the configmap and secret objects that were installed previously with the third-party vSphere CSI Driver.
						</li><li class="listitem"><p class="simpara">
							Delete the third-party vSphere CSI driver <code class="literal">CSIDriver</code> object:
						</p><pre class="programlisting language-terminal">~ $ oc delete CSIDriver csi.vsphere.vmware.com</pre><pre class="programlisting language-terminal">csidriver.storage.k8s.io "csi.vsphere.vmware.com" deleted</pre></li></ol></div><p>
					After you have removed the third-party vSphere CSI Driver from the OpenShift Container Platform cluster, installation of Red Hat’s vSphere CSI Operator Driver automatically resumes, and any conditions that could block upgrades to OpenShift Container Platform 4.11, or later, are automatically removed. If you had existing vSphere CSI PV objects, their lifecycle is now managed by Red Hat’s vSphere CSI Operator Driver.
				</p></section><section class="section" id="vsphere-pv-encryption"><div class="titlepage"><div><div><h3 class="title">5.22.7. vSphere persistent disks encryption</h3></div></div></div><p>
					You can encrypt virtual machines (VMs) and dynamically provisioned persistent volumes (PVs) on OpenShift Container Platform running on top of vSphere.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						OpenShift Container Platform does not support RWX-encrypted PVs. You cannot request RWX PVs out of a storage class that uses an encrypted storage policy.
					</p></div></div><p>
					You must encrypt VMs before you can encrypt PVs, which you can do during installation or post-installation.
				</p><p>
					For information about encrypting VMs, see:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installation-vsphere-encrypted-vms_installing-vsphere">Requirements for encrypting virtual machines</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#installation-vsphere-machines_installing-vsphere">During installation: Step 7 of Installing RHCOS and starting the OpenShift Container Platform bootstrap process</a>
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/post-installation_configuration/#enabling-encryption-on-a-vsphere-cluster">Post-installation enabling encryption on a vSphere cluster</a>
						</li></ul></div><p>
					After encrypting VMs, you can configure a storage class that supports dynamic encryption volume provisioning using the vSphere Container Storage Interface (CSI) driver. This can be accomplished in one of two ways using:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-vsphere-encryption-datastore-url_persistent-storage-csi-vsphere">Datastore URL</a>: This approach is not very flexible, and forces you to use a single datastore. It also does not support topology-aware provisioning.
						</li><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi-vsphere-encryption-tag-based_persistent-storage-csi-vsphere">Tag-based placement</a>: Encrypts the provisioned volumes and uses tag-based placement to target specific datastores.
						</li></ul></div><section class="section" id="persistent-storage-csi-vsphere-encryption-datastore-url_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h4 class="title">5.22.7.1. Using datastore URL</h4></div></div></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
							To encrypt using the datastore URL:
						</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
								Find out the name of the default storage policy in your datastore that supports encryption.
							</p><p class="simpara">
								This is same policy that was used for encrypting your VMs.
							</p></li><li class="listitem"><p class="simpara">
								Create a storage class that uses this storage policy:
							</p><pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
 name: encryption
provisioner: csi.vsphere.vmware.com
parameters:
 storagePolicyName: &lt;storage-policy-name&gt; <span id="CO97-1"><!--Empty--></span><span class="callout">1</span>
 datastoreurl: "ds:///vmfs/volumes/vsan:522e875627d-b090c96b526bb79c/"</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO97-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Name of default storage policy in your datastore that supports encryption
									</div></dd></dl></div></li></ol></div></section><section class="section" id="persistent-storage-csi-vsphere-encryption-tag-based_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h4 class="title">5.22.7.2. Using tag-based placement</h4></div></div></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
							To encrypt using tag-based placement:
						</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
								In vCenter create a category for tagging datastores that will be made available to this storage class. Also, ensure that <span class="strong strong"><strong>StoragePod(Datastore clusters)</strong></span>, <span class="strong strong"><strong>Datastore</strong></span>, and <span class="strong strong"><strong>Folder</strong></span> are selected as Associable Entities for the created category.
							</li><li class="listitem">
								In vCenter, create a tag that uses the category created earlier.
							</li><li class="listitem">
								Assign the previously created tag to each datastore that will be made available to the storage class. Make sure that datastores are shared with hosts participating in the OpenShift Container Platform cluster.
							</li><li class="listitem">
								In vCenter, from the main menu, click <span class="strong strong"><strong>Policies and Profiles</strong></span>.
							</li><li class="listitem">
								On the <span class="strong strong"><strong>Policies and Profiles</strong></span> page, in the navigation pane, click <span class="strong strong"><strong>VM Storage Policies</strong></span>.
							</li><li class="listitem">
								Click <span class="strong strong"><strong>CREATE</strong></span>.
							</li><li class="listitem">
								Type a name for the storage policy.
							</li><li class="listitem">
								Select <span class="strong strong"><strong>Enable host based rules</strong></span> and <span class="strong strong"><strong>Enable tag based placement rules</strong></span>.
							</li><li class="listitem"><p class="simpara">
								In the <span class="strong strong"><strong>Next</strong></span> tab:
							</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
										Select <span class="strong strong"><strong>Encryption</strong></span> and <span class="strong strong"><strong>Default Encryption Properties</strong></span>.
									</li><li class="listitem">
										Select the tag category created earlier, and select tag selected. Verify that the policy is selecting matching datastores.
									</li></ol></div></li><li class="listitem">
								Create the storage policy.
							</li><li class="listitem"><p class="simpara">
								Create a storage class that uses the storage policy:
							</p><pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
 name:  csi-encrypted
provisioner: csi.vsphere.vmware.com
reclaimPolicy: Delete
volumeBindingMode: WaitForFirstConsumer
parameters:
 storagePolicyName: &lt;storage-policy-name&gt; <span id="CO98-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO98-1"><span class="callout">1</span></a> </dt><dd><div class="para">
										Name of the storage policy that you created for encryption
									</div></dd></dl></div></li></ol></div></section></section><section class="section" id="persistent-storage-csi-vsphere-top-aware-overview_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h3 class="title">5.22.8. vSphere CSI topology overview</h3></div></div></div><p>
					OpenShift Container Platform provides the ability to deploy OpenShift Container Platform for vSphere on different zones and regions, which allows you to deploy over multiple compute clusters and datacenters, thus helping to avoid a single point of failure.
				</p><p>
					This is accomplished by defining zone and region categories in vCenter, and then assigning these categories to different failure domains, such as a compute cluster, by creating tags for these zone and region categories. After you have created the appropriate categories, and assigned tags to vCenter objects, you can create additional machinesets that create virtual machines (VMs) that are responsible for scheduling pods in those failure domains.
				</p><p>
					The following example defines two failure domains with one region and two zones:
				</p><div class="table" id="idm140001856154752"><p class="title"><strong>Table 5.6. vSphere storage topology with one region and two zones</strong></p><div class="table-contents"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"><!--Empty--></col><col style="width: 33%; " class="col_2"><!--Empty--></col><col style="width: 33%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001856148960" scope="col">Compute cluster</th><th align="left" valign="top" id="idm140001856147872" scope="col">Failure domain</th><th align="left" valign="top" id="idm140001856146784" scope="col">Description</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001856148960"> <p>
									Compute cluster: ocp1, Datacenter: Atlanta
								</p>
								 </td><td align="left" valign="top" headers="idm140001856147872"> <p>
									openshift-region: us-east-1 (tag), openshift-zone: us-east-1a (tag)
								</p>
								 </td><td align="left" valign="top" headers="idm140001856146784"> <p>
									This defines a failure domain in region us-east-1 with zone us-east-1a.
								</p>
								 </td></tr><tr><td align="left" valign="top" headers="idm140001856148960"> <p>
									Computer cluster: ocp2, Datacenter: Atlanta
								</p>
								 </td><td align="left" valign="top" headers="idm140001856147872"> <p>
									openshift-region: us-east-1 (tag), openshift-zone: us-east-1b (tag)
								</p>
								 </td><td align="left" valign="top" headers="idm140001856146784"> <p>
									This defines a different failure domain within the same region called us-east-1b.
								</p>
								 </td></tr></tbody></table></div></div><section class="section" id="persistent-storage-csi-vsphere-top-aware-during-install_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h4 class="title">5.22.8.1. Creating vSphere storage topology during installation</h4></div></div></div><section class="section" id="procedure-4"><div class="titlepage"><div><div><h5 class="title">5.22.8.1.1. Procedure</h5></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
									Specify the topology during installation. See the <span class="emphasis"><em>Configuring regions and zones for a VMware vCenter</em></span> section.
								</li></ul></div><p>
							No additional action is necessary and the default storage class that is created by OpenShift Container Platform is topology aware and should allow provisioning of volumes in different failure domains.
						</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/installing/#configuring-vsphere-regions-zones_installing-vsphere-installer-provisioned-network-customizations">Configuring regions and zones for a VMware vCenter</a>
								</li></ul></div></section></section><section class="section" id="persistent-storage-csi-vsphere-top-aware-post-install_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h4 class="title">5.22.8.2. Creating vSphere storage topology post-installation</h4></div></div></div><section class="section" id="procedure-5"><div class="titlepage"><div><div><h5 class="title">5.22.8.2.1. Procedure</h5></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									In the VMware vCenter vSphere client GUI, define appropriate zone and region catagories and tags.
								</p><p class="simpara">
									While vSphere allows you to create categories with any arbitrary name, OpenShift Container Platform strongly recommends use of <code class="literal">openshift-region</code> and <code class="literal">openshift-zone</code> names for defining topology categories.
								</p><p class="simpara">
									For more information about vSphere categories and tags, see the VMware vSphere documentation.
								</p></li><li class="listitem">
									In OpenShift Container Platform, create failure domains. See the <span class="emphasis"><em>Specifying multiple regions and zones for your cluster on vSphere</em></span> section.
								</li><li class="listitem"><p class="simpara">
									Create a tag to assign to datastores across failure domains:
								</p><p class="simpara">
									When an OpenShift Container Platform spans more than one failure domain, the datastore might not be shared across those failure domains, which is where topology-aware provisioning of persistent volumes (PVs) is useful.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											In vCenter, create a category for tagging the datastores. For example, <code class="literal">openshift-zonal-datastore-cat</code>. You can use any other category name, provided the category uniquely is used for tagging datastores participating in OpenShift Container Platform cluster. Also, ensure that <code class="literal">StoragePod</code>, <code class="literal">Datastore</code>, and <code class="literal">Folder</code> are selected as Associable Entities for the created category.
										</li><li class="listitem">
											In vCenter, create a tag that uses the previously created category. This example uses the tag name <code class="literal">openshift-zonal-datastore</code>.
										</li><li class="listitem"><p class="simpara">
											Assign the previously created tag (in this example <code class="literal">openshift-zonal-datastore</code>) to each datastore in a failure domain that would be considered for dynamic provisioning.
										</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
												You can use any names you like for datastore categories and tags. The names used in this example are provided as recommendations. Ensure that the tags and categories that you define uniquely identify only datastores that are shared with all hosts in the OpenShift Container Platform cluster.
											</p></div></div></li></ol></div></li><li class="listitem"><p class="simpara">
									As needed, create a storage policy that targets the tag-based datastores in each failure domain:
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											In vCenter, from the main menu, click <span class="strong strong"><strong>Policies and Profiles</strong></span>.
										</li><li class="listitem">
											On the <span class="strong strong"><strong>Policies and Profiles</strong></span> page, in the navigation pane, click <span class="strong strong"><strong>VM Storage Policies</strong></span>.
										</li><li class="listitem">
											Click <span class="strong strong"><strong>CREATE</strong></span>.
										</li><li class="listitem">
											Type a name for the storage policy.
										</li><li class="listitem"><p class="simpara">
											For the rules, choose Tag Placement rules and select the tag and category that targets the desired datastores (in this example, the <code class="literal">openshift-zonal-datastore</code> tag).
										</p><p class="simpara">
											The datastores are listed in the storage compatibility table.
										</p></li></ol></div></li><li class="listitem"><p class="simpara">
									Create a new storage class that uses the new zoned storage policy:
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											Click <span class="strong strong"><strong>Storage</strong></span> &gt; <span class="strong strong"><strong>StorageClasses</strong></span>.
										</li><li class="listitem">
											On the <span class="strong strong"><strong>StorageClasses</strong></span> page, click <span class="strong strong"><strong>Create StorageClass</strong></span>.
										</li><li class="listitem">
											Type a name for the new storage class in <span class="strong strong"><strong>Name</strong></span>.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Provisioner</strong></span>, select <span class="strong strong"><strong>csi.vsphere.vmware.com</strong></span>.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Additional parameters</strong></span>, for the StoragePolicyName parameter, set <span class="strong strong"><strong>Value</strong></span> to the name of the new zoned storage policy that you created earlier.
										</li><li class="listitem"><p class="simpara">
											Click <span class="strong strong"><strong>Create</strong></span>.
										</p><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
												
<pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: zoned-sc <span id="CO99-1"><!--Empty--></span><span class="callout">1</span>
provisioner: csi.vsphere.vmware.com
parameters:
  StoragePolicyName: zoned-storage-policy <span id="CO99-2"><!--Empty--></span><span class="callout">2</span>
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer</pre>

											</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO99-1"><span class="callout">1</span></a> </dt><dd><div class="para">
													New topology aware storage class name.
												</div></dd><dt><a href="#CO99-2"><span class="callout">2</span></a> </dt><dd><div class="para">
													Specify zoned storage policy.
												</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
												You can also create the storage class by editing the preceding YAML file and running the command <code class="literal">oc create -f $FILE</code>.
											</p></div></div></li></ol></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/post-installation_configuration/#specifying-regions-zones-infrastructure-vsphere_post-install-vsphere-zones-regions-configuration">Specifying multiple regions and zones for your cluster on vSphere</a>
								</li><li class="listitem">
									<a class="link" href="https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vcenter-esxi-management/GUID-16422FF7-235B-4A44-92E2-532F6AED0923.html?hWord=N4IghgNiBcIC5gOYgL5A">VMware vSphere tag documenation</a>
								</li></ul></div></section></section><section class="section" id="persistent-storage-csi-vsphere-top-aware-infra-top_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h4 class="title">5.22.8.3. Creating vSphere storage topology without an infra topology</h4></div></div></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							OpenShift Container Platform recommends using the infrastructure object for specifying failure domains in a topology aware setup. Specifying failure domains in the infrastructure object and specify topology-categories in the <code class="literal">ClusterCSIDriver</code> object at the same time is an unsupported operation.
						</p></div></div><section class="section" id="procedure-6"><div class="titlepage"><div><div><h5 class="title">5.22.8.3.1. Procedure</h5></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
									In the VMware vCenter vSphere client GUI, define appropriate zone and region catagories and tags.
								</p><p class="simpara">
									While vSphere allows you to create categories with any arbitrary name, OpenShift Container Platform strongly recommends use of <code class="literal">openshift-region</code> and <code class="literal">openshift-zone</code> names for defining topology.
								</p><p class="simpara">
									For more information about vSphere categories and tags, see the VMware vSphere documentation.
								</p></li><li class="listitem"><p class="simpara">
									To allow the container storage interface (CSI) driver to detect this topology, edit the <code class="literal">clusterCSIDriver</code> object YAML file <code class="literal">driverConfig</code> section:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											Specify the <code class="literal">openshift-zone</code> and <code class="literal">openshift-region</code> categories that you created earlier.
										</li><li class="listitem"><p class="simpara">
											Set <code class="literal">driverType</code> to <code class="literal">vSphere</code>.
										</p><pre class="programlisting language-terminal">~ $ oc edit clustercsidriver csi.vsphere.vmware.com -o yaml</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
												
<pre class="programlisting language-terminal">apiVersion: operator.openshift.io/v1
kind: ClusterCSIDriver
metadata:
  name: csi.vsphere.vmware.com
spec:
  logLevel: Normal
  managementState: Managed
  observedConfig: null
  operatorLogLevel: Normal
  unsupportedConfigOverrides: null
  driverConfig:
    driverType: vSphere <span id="CO100-1"><!--Empty--></span><span class="callout">1</span>
      vSphere:
        topologyCategories: <span id="CO100-2"><!--Empty--></span><span class="callout">2</span>
        - openshift-zone
        - openshift-region</pre>

											</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO100-1"><span class="callout">1</span></a> </dt><dd><div class="para">
													Ensure that <code class="literal">driverType</code> is set to <code class="literal">vSphere</code>.
												</div></dd><dt><a href="#CO100-2"><span class="callout">2</span></a> </dt><dd><div class="para">
													<code class="literal">openshift-zone</code> and <code class="literal">openshift-region</code> categories created earlier in vCenter.
												</div></dd></dl></div></li></ul></div></li><li class="listitem"><p class="simpara">
									Verify that <code class="literal">CSINode</code> object has topology keys by running the following commands:
								</p><pre class="programlisting language-terminal">~ $ oc get csinode</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
										
<pre class="programlisting language-terminal">NAME DRIVERS AGE
co8-4s88d-infra-2m5vd 1 27m
co8-4s88d-master-0 1 70m
co8-4s88d-master-1 1 70m
co8-4s88d-master-2 1 70m
co8-4s88d-worker-j2hmg 1 47m
co8-4s88d-worker-mbb46 1 47m
co8-4s88d-worker-zlk7d 1 47m</pre>

									</p></div><pre class="programlisting language-terminal">~ $ oc get csinode co8-4s88d-worker-j2hmg -o yaml</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
										
<pre class="programlisting language-terminal">...
spec:
  drivers:
  - allocatable:
      count: 59
  name: csi-vsphere.vmware.com
  nodeID: co8-4s88d-worker-j2hmg
  topologyKeys: <span id="CO101-1"><!--Empty--></span><span class="callout">1</span>
  - topology.csi.vmware.com/openshift-zone
  - topology.csi.vmware.com/openshift-region</pre>

									</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO101-1"><span class="callout">1</span></a> </dt><dd><div class="para">
											Topology keys from vSphere <code class="literal">openshift-zone</code> and <code class="literal">openshift-region</code> catagories.
										</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
										<code class="literal">CSINode</code> objects might take some time to receive updated topology information. After the driver is updated, <code class="literal">CSINode</code> objects should have topology keys in them.
									</p></div></div></li><li class="listitem"><p class="simpara">
									Create a tag to assign to datastores across failure domains:
								</p><p class="simpara">
									When an OpenShift Container Platform spans more than one failure domain, the datastore might not be shared across those failure domains, which is where topology-aware provisioning of persistent volumes (PVs) is useful.
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											In vCenter, create a category for tagging the datastores. For example, <code class="literal">openshift-zonal-datastore-cat</code>. You can use any other category name, provided the category uniquely is used for tagging datastores participating in OpenShift Container Platform cluster. Also, ensure that <code class="literal">StoragePod</code>, <code class="literal">Datastore</code>, and <code class="literal">Folder</code> are selected as Associable Entities for the created category.
										</li><li class="listitem">
											In vCenter, create a tag that uses the previously created category. This example uses the tag name <code class="literal">openshift-zonal-datastore</code>.
										</li><li class="listitem"><p class="simpara">
											Assign the previously created tag (in this example <code class="literal">openshift-zonal-datastore</code>) to each datastore in a failure domain that would be considered for dynamic provisioning.
										</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
												You can use any names you like for categories and tags. The names used in this example are provided as recommendations. Ensure that the tags and categories that you define uniquely identify only datastores that are shared with all hosts in the OpenShift Container Platform cluster.
											</p></div></div></li></ol></div></li><li class="listitem"><p class="simpara">
									Create a storage policy that targets the tag-based datastores in each failure domain:
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											In vCenter, from the main menu, click <span class="strong strong"><strong>Policies and Profiles</strong></span>.
										</li><li class="listitem">
											On the <span class="strong strong"><strong>Policies and Profiles</strong></span> page, in the navigation pane, click <span class="strong strong"><strong>VM Storage Policies</strong></span>.
										</li><li class="listitem">
											Click <span class="strong strong"><strong>CREATE</strong></span>.
										</li><li class="listitem">
											Type a name for the storage policy.
										</li><li class="listitem"><p class="simpara">
											For the rules, choose Tag Placement rules and select the tag and category that targets the desired datastores (in this example, the <code class="literal">openshift-zonal-datastore</code> tag).
										</p><p class="simpara">
											The datastores are listed in the storage compatibility table.
										</p></li></ol></div></li><li class="listitem"><p class="simpara">
									Create a new storage class that uses the new zoned storage policy:
								</p><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
											Click <span class="strong strong"><strong>Storage</strong></span> &gt; <span class="strong strong"><strong>StorageClasses</strong></span>.
										</li><li class="listitem">
											On the <span class="strong strong"><strong>StorageClasses</strong></span> page, click <span class="strong strong"><strong>Create StorageClass</strong></span>.
										</li><li class="listitem">
											Type a name for the new storage class in <span class="strong strong"><strong>Name</strong></span>.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Provisioner</strong></span>, select <span class="strong strong"><strong>csi.vsphere.vmware.com</strong></span>.
										</li><li class="listitem">
											Under <span class="strong strong"><strong>Additional parameters</strong></span>, for the StoragePolicyName parameter, set <span class="strong strong"><strong>Value</strong></span> to the name of the new zoned storage policy that you created earlier.
										</li><li class="listitem"><p class="simpara">
											Click <span class="strong strong"><strong>Create</strong></span>.
										</p><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
												
<pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: zoned-sc <span id="CO102-1"><!--Empty--></span><span class="callout">1</span>
provisioner: csi.vsphere.vmware.com
parameters:
  StoragePolicyName: zoned-storage-policy <span id="CO102-2"><!--Empty--></span><span class="callout">2</span>
reclaimPolicy: Delete
allowVolumeExpansion: true
volumeBindingMode: WaitForFirstConsumer</pre>

											</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO102-1"><span class="callout">1</span></a> </dt><dd><div class="para">
													New topology aware storage class name.
												</div></dd><dt><a href="#CO102-2"><span class="callout">2</span></a> </dt><dd><div class="para">
													Specify zoned storage policy.
												</div></dd></dl></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
												You can also create the storage class by editing the preceding YAML file and running the command <code class="literal">oc create -f $FILE</code>.
											</p></div></div></li></ol></div></li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
									<a class="link" href="https://docs.vmware.com/en/VMware-vSphere/8.0/vsphere-vcenter-esxi-management/GUID-16422FF7-235B-4A44-92E2-532F6AED0923.html?hWord=N4IghgNiBcIC5gOYgL5A">VMware vSphere tag documenation</a>
								</li></ul></div></section></section><section class="section" id="persistent-storage-csi-vsphere-top-aware-results_persistent-storage-csi-vsphere"><div class="titlepage"><div><div><h4 class="title">5.22.8.4. Results</h4></div></div></div><p>
						Creating persistent volume claims (PVCs) and PVs from the topology aware storage class are truly zonal, and should use the datastore in their respective zone depending on how pods are scheduled:
					</p><pre class="programlisting language-terminal">~ $ oc get pv &lt;pv-name&gt; -o yaml</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
							
<pre class="programlisting language-terminal">...
nodeAffinity:
  required:
    nodeSelectorTerms:
    - matchExpressions:
      - key: topology.csi.vmware.com/openshift-zone <span id="CO103-1"><!--Empty--></span><span class="callout">1</span>
        operator: In
        values:
        - &lt;openshift-zone&gt;
      -key: topology.csi.vmware.com/openshift-region <span id="CO103-2"><!--Empty--></span><span class="callout">2</span>
        operator: In
        values:
        - &lt;openshift-region&gt;
...
peristentVolumeclaimPolicy: Delete
storageClassName: &lt;zoned-storage-class-name&gt; <span id="CO103-3"><!--Empty--></span><span class="callout">3</span>
volumeMode: Filesystem
...</pre>

						</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO103-1"><span class="callout">1</span></a> <a href="#CO103-2"><span class="callout">2</span></a> </dt><dd><div class="para">
								PV has zoned keys.
							</div></dd><dt><a href="#CO103-3"><span class="callout">3</span></a> </dt><dd><div class="para">
								PV is using the zoned storage class.
							</div></dd></dl></div></section></section><section class="section" id="additional-resources-5"><div class="titlepage"><div><div><h3 class="title">5.22.9. Additional resources</h3></div></div></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#persistent-storage-csi">Configuring CSI volumes</a>
						</li></ul></div></section></section></section><section class="chapter" id="generic-ephemeral-volumes"><div class="titlepage"><div><div><h1 class="title">Chapter 6. Generic ephemeral volumes</h1></div></div></div><section class="section" id="generic-ephemeral-vols-overview_generic-ephemeral-volumes"><div class="titlepage"><div><div><h2 class="title">6.1. Overview</h2></div></div></div><p>
				Generic ephemeral volumes are a type of ephemeral volume that can be provided by all storage drivers that support persistent volumes and dynamic provisioning. Generic ephemeral volumes are similar to <code class="literal">emptyDir</code> volumes in that they provide a per-pod directory for scratch data, which is usually empty after provisioning.
			</p><p>
				Generic ephemeral volumes are specified inline in the pod spec and follow the pod’s lifecycle. They are created and deleted along with the pod.
			</p><p>
				Generic ephemeral volumes have the following features:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Storage can be local or network-attached.
					</li><li class="listitem">
						Volumes can have a fixed size that pods are not able to exceed.
					</li><li class="listitem">
						Volumes might have some initial data, depending on the driver and parameters.
					</li><li class="listitem">
						Typical operations on volumes are supported, assuming that the driver supports them, including snapshotting, cloning, resizing, and storage capacity tracking.
					</li></ul></div><div class="admonition note"><div class="admonition_header">Note</div><div><p>
					Generic ephemeral volumes do not support offline snapshots and resize.
				</p><p>
					Due to this limitation, the following Container Storage Interface (CSI) drivers do not support the following features for generic ephemeral volumes:
				</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
							Azure Disk CSI driver does not support resize.
						</li><li class="listitem">
							Cinder CSI driver does not support snapshot.
						</li></ul></div></div></div></section><section class="section" id="generic-ephemeral-vols-lifecycle_generic-ephemeral-volumes"><div class="titlepage"><div><div><h2 class="title">6.2. Lifecycle and persistent volume claims</h2></div></div></div><p>
				The parameters for a volume claim are allowed inside a volume source of a pod. Labels, annotations, and the whole set of fields for persistent volume claims (PVCs) are supported. When such a pod is created, the ephemeral volume controller then creates an actual PVC object (from the template shown in the <span class="emphasis"><em>Creating generic ephemeral volumes</em></span> procedure) in the same namespace as the pod, and ensures that the PVC is deleted when the pod is deleted. This triggers volume binding and provisioning in one of two ways:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						Either immediately, if the storage class uses immediate volume binding.
					</p><p class="simpara">
						With immediate binding, the scheduler is forced to select a node that has access to the volume after it is available.
					</p></li><li class="listitem"><p class="simpara">
						When the pod is tentatively scheduled onto a node (<code class="literal">WaitForFirstConsumervolume</code> binding mode).
					</p><p class="simpara">
						This volume binding option is recommended for generic ephemeral volumes because then the scheduler can choose a suitable node for the pod.
					</p></li></ul></div><p>
				In terms of resource ownership, a pod that has generic ephemeral storage is the owner of the PVCs that provide that ephemeral storage. When the pod is deleted, the Kubernetes garbage collector deletes the PVC, which then usually triggers deletion of the volume because the default reclaim policy of storage classes is to delete volumes. You can create quasi-ephemeral local storage by using a storage class with a reclaim policy of retain: the storage outlives the pod, and in this case, you must ensure that volume clean-up happens separately. While these PVCs exist, they can be used like any other PVC. In particular, they can be referenced as data source in volume cloning or snapshotting. The PVC object also holds the current status of the volume.
			</p><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						<a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#generic-ephemeral-vols-procedure_generic-ephemeral-volumes">Creating generic ephemeral volumes</a>
					</li></ul></div></section><section class="section" id="generic-ephemeral-security_generic-ephemeral-volumes"><div class="titlepage"><div><div><h2 class="title">6.3. Security</h2></div></div></div><p>
				You can enable the generic ephemeral volume feature to allows users who can create pods to also create persistent volume claims (PVCs) indirectly. This feature works even if these users do not have permission to create PVCs directly. Cluster administrators must be aware of this. If this does not fit your security model, use an admission webhook that rejects objects such as pods that have a generic ephemeral volume.
			</p><p>
				The normal namespace quota for PVCs still applies, so even if users are allowed to use this new mechanism, they cannot use it to circumvent other policies.
			</p></section><section class="section" id="generic-ephemeral-vols-pvc-naming_generic-ephemeral-volumes"><div class="titlepage"><div><div><h2 class="title">6.4. Persistent volume claim naming</h2></div></div></div><p>
				Automatically created persistent volume claims (PVCs) are named by a combination of the pod name and the volume name, with a hyphen (-) in the middle. This naming convention also introduces a potential conflict between different pods, and between pods and manually created PVCs.
			</p><p>
				For example, <code class="literal">pod-a</code> with volume <code class="literal">scratch</code> and <code class="literal">pod</code> with volume <code class="literal">a-scratch</code> both end up with the same PVC name, <code class="literal">pod-a-scratch</code>.
			</p><p>
				Such conflicts are detected, and a PVC is only used for an ephemeral volume if it was created for the pod. This check is based on the ownership relationship. An existing PVC is not overwritten or modified, but this does not resolve the conflict. Without the right PVC, a pod cannot start.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Be careful when naming pods and volumes inside the same namespace so that naming conflicts do not occur.
				</p></div></div></section><section class="section" id="generic-ephemeral-vols-procedure_generic-ephemeral-volumes"><div class="titlepage"><div><div><h2 class="title">6.5. Creating generic ephemeral volumes</h2></div></div></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
						Create the <code class="literal">pod</code> object definition and save it to a file.
					</li><li class="listitem"><p class="simpara">
						Include the generic ephemeral volume information in the file.
					</p><div class="formalpara"><p class="title"><strong>my-example-pod-with-generic-vols.yaml</strong></p><p>
							
<pre class="programlisting language-yaml">kind: Pod
apiVersion: v1
metadata:
  name: my-app
spec:
  containers:
    - name: my-frontend
      image: busybox:1.28
      volumeMounts:
      - mountPath: "/mnt/storage"
        name: data
      command: [ "sleep", "1000000" ]
  volumes:
    - name: data <span id="CO104-1"><!--Empty--></span><span class="callout">1</span>
      ephemeral:
        volumeClaimTemplate:
          metadata:
            labels:
              type: my-app-ephvol
          spec:
            accessModes: [ "ReadWriteOnce" ]
            storageClassName: "gp2-csi"
            resources:
              requests:
                storage: 1Gi</pre>

						</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO104-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Generic ephemeral volume claim.
							</div></dd></dl></div></li></ol></div></section></section><section class="chapter" id="expanding-persistent-volumes"><div class="titlepage"><div><div><h1 class="title">Chapter 7. Expanding persistent volumes</h1></div></div></div><section class="section" id="add-volume-expansion_expanding-persistent-volumes"><div class="titlepage"><div><div><h2 class="title">7.1. Enabling volume expansion support</h2></div></div></div><p>
				Before you can expand persistent volumes, the <code class="literal">StorageClass</code> object must have the <code class="literal">allowVolumeExpansion</code> field set to <code class="literal">true</code>.
			</p><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						Edit the <code class="literal">StorageClass</code> object and add the <code class="literal">allowVolumeExpansion</code> attribute by running the following command:
					</p><pre class="programlisting language-terminal">$ oc edit storageclass &lt;storage_class_name&gt; <span id="CO105-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO105-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Specifies the name of the storage class.
							</div></dd></dl></div><p class="simpara">
						The following example demonstrates adding this line at the bottom of the storage class configuration.
					</p><pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
...
parameters:
  type: gp2
reclaimPolicy: Delete
allowVolumeExpansion: true <span id="CO106-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO106-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Setting this attribute to <code class="literal">true</code> allows PVCs to be expanded after creation.
							</div></dd></dl></div></li></ul></div></section><section class="section" id="expanding-csi-volumes_expanding-persistent-volumes"><div class="titlepage"><div><div><h2 class="title">7.2. Expanding CSI volumes</h2></div></div></div><p>
				You can use the Container Storage Interface (CSI) to expand storage volumes after they have already been created.
			</p><p>
				CSI volume expansion does not support the following:
			</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
						Recovering from failure when expanding volumes
					</li><li class="listitem">
						Shrinking
					</li></ul></div><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
						The underlying CSI driver supports resize.
					</li><li class="listitem">
						Dynamic provisioning is used.
					</li><li class="listitem">
						The controlling <code class="literal">StorageClass</code> object has <code class="literal">allowVolumeExpansion</code> set to <code class="literal">true</code>. For more information, see "Enabling volume expansion support."
					</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
						For the persistent volume claim (PVC), set <code class="literal">.spec.resources.requests.storage</code> to the desired new size.
					</li><li class="listitem">
						Watch the <code class="literal">status.conditions</code> field of the PVC to see if the resize has completed. OpenShift Container Platform adds the <code class="literal">Resizing</code> condition to the PVC during expansion, which is removed after expansion completes.
					</li></ol></div></section><section class="section" id="expanding-flexvolume_expanding-persistent-volumes"><div class="titlepage"><div><div><h2 class="title">7.3. Expanding FlexVolume with a supported driver</h2></div></div></div><p>
				When using FlexVolume to connect to your back-end storage system, you can expand persistent storage volumes after they have already been created. This is done by manually updating the persistent volume claim (PVC) in OpenShift Container Platform.
			</p><p>
				FlexVolume allows expansion if the driver is set with <code class="literal">RequiresFSResize</code> to <code class="literal">true</code>. The FlexVolume can be expanded on pod restart.
			</p><p>
				Similar to other volume types, FlexVolume volumes can also be expanded when in use by a pod.
			</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
						The underlying volume driver supports resize.
					</li><li class="listitem">
						The driver is set with the <code class="literal">RequiresFSResize</code> capability to <code class="literal">true</code>.
					</li><li class="listitem">
						Dynamic provisioning is used.
					</li><li class="listitem">
						The controlling <code class="literal">StorageClass</code> object has <code class="literal">allowVolumeExpansion</code> set to <code class="literal">true</code>.
					</li></ul></div><div class="itemizedlist"><p class="title"><strong>Procedure</strong></p><ul class="itemizedlist" type="disc"><li class="listitem"><p class="simpara">
						To use resizing in the FlexVolume plugin, you must implement the <code class="literal">ExpandableVolumePlugin</code> interface using these methods:
					</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">RequiresFSResize</code></span></dt><dd>
									If <code class="literal">true</code>, updates the capacity directly. If <code class="literal">false</code>, calls the <code class="literal">ExpandFS</code> method to finish the filesystem resize.
								</dd><dt><span class="term"><code class="literal">ExpandFS</code></span></dt><dd>
									If <code class="literal">true</code>, calls <code class="literal">ExpandFS</code> to resize filesystem after physical volume expansion is done. The volume driver can also perform physical volume resize together with filesystem resize.
								</dd></dl></div></li></ul></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Because OpenShift Container Platform does not support installation of FlexVolume plugins on control plane nodes, it does not support control-plane expansion of FlexVolume.
				</p></div></div></section><section class="section" id="expanding-local-volumes_expanding-persistent-volumes"><div class="titlepage"><div><div><h2 class="title">7.4. Expanding local volumes</h2></div></div></div><p>
				You can manually expand persistent volumes (PVs) and persistent volume claims (PVCs) created by using the local storage operator (LSO).
			</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
						Expand the underlying devices. Ensure that appropriate capacity is available on these devices.
					</li><li class="listitem">
						Update the corresponding PV objects to match the new device sizes by editing the <code class="literal">.spec.capacity</code> field of the PV.
					</li><li class="listitem">
						For the storage class that is used for binding the PVC to PVet, set <code class="literal">allowVolumeExpansion:true</code>.
					</li><li class="listitem">
						For the PVC, set <code class="literal">.spec.resources.requests.storage</code> to match the new size.
					</li></ol></div><p>
				Kubelet should automatically expand the underlying file system on the volume, if necessary, and update the status field of the PVC to reflect the new size.
			</p></section><section class="section" id="expanding-pvc-filesystem_expanding-persistent-volumes"><div class="titlepage"><div><div><h2 class="title">7.5. Expanding persistent volume claims (PVCs) with a file system</h2></div></div></div><p>
				Expanding PVCs based on volume types that need file system resizing, such as GCE, EBS, and Cinder, is a two-step process. First, expand the volume objects in the cloud provider. Second, expand the file system on the node.
			</p><p>
				Expanding the file system on the node only happens when a new pod is started with the volume.
			</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
						The controlling <code class="literal">StorageClass</code> object must have <code class="literal">allowVolumeExpansion</code> set to <code class="literal">true</code>.
					</li></ul></div><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						Edit the PVC and request a new size by editing <code class="literal">spec.resources.requests</code>. For example, the following expands the <code class="literal">ebs</code> PVC to 8 Gi:
					</p><pre class="programlisting language-yaml">kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: ebs
spec:
  storageClass: "storageClassWithFlagSet"
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 8Gi <span id="CO107-1"><!--Empty--></span><span class="callout">1</span></pre><div class="calloutlist small"><dl class="calloutlist small"><dt><a href="#CO107-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Updating <code class="literal">spec.resources.requests</code> to a larger amount expands the PVC.
							</div></dd></dl></div></li><li class="listitem"><p class="simpara">
						After the cloud provider object has finished resizing, the PVC is set to <code class="literal">FileSystemResizePending</code>. Check the condition by entering the following command:
					</p><pre class="programlisting language-terminal">$ oc describe pvc &lt;pvc_name&gt;</pre></li><li class="listitem">
						When the cloud provider object has finished resizing, the <code class="literal">PersistentVolume</code> object reflects the newly requested size in <code class="literal">PersistentVolume.Spec.Capacity</code>. At this point, you can create or recreate a new pod from the PVC to finish the file system resizing. Once the pod is running, the newly requested size is available and the <code class="literal">FileSystemResizePending</code> condition is removed from the PVC.
					</li></ol></div></section><section class="section" id="expanding-recovering-from-failure_expanding-persistent-volumes"><div class="titlepage"><div><div><h2 class="title">7.6. Recovering from failure when expanding volumes</h2></div></div></div><p>
				If expanding underlying storage fails, the OpenShift Container Platform administrator can manually recover the persistent volume claim (PVC) state and cancel the resize requests. Otherwise, the resize requests are continuously retried by the controller.
			</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem">
						Mark the persistent volume (PV) that is bound to the PVC with the <code class="literal">Retain</code> reclaim policy. This can be done by editing the PV and changing <code class="literal">persistentVolumeReclaimPolicy</code> to <code class="literal">Retain</code>.
					</li><li class="listitem">
						Delete the PVC.
					</li><li class="listitem">
						Manually edit the PV and delete the <code class="literal">claimRef</code> entry from the PV specs to ensure that the newly created PVC can bind to the PV marked <code class="literal">Retain</code>. This marks the PV as <code class="literal">Available</code>.
					</li><li class="listitem">
						Re-create the PVC in a smaller size, or a size that can be allocated by the underlying storage provider.
					</li><li class="listitem">
						Set the <code class="literal">volumeName</code> field of the PVC to the name of the PV. This binds the PVC to the provisioned PV only.
					</li><li class="listitem">
						Restore the reclaim policy on the PV.
					</li></ol></div><div class="itemizedlist _additional-resources"><p class="title"><strong>Additional resources</strong></p><ul class="itemizedlist _additional-resources" type="disc"><li class="listitem">
						The controlling <code class="literal">StorageClass</code> object has <code class="literal">allowVolumeExpansion</code> set to <code class="literal">true</code> (see <a class="link" href="https://access.redhat.com/documentation/en-us/openshift_container_platform/4.13/html-single/storage/#add-volume-expansion_expanding-persistent-volumes">Enabling volume expansion support</a>).
					</li></ul></div></section></section><section class="chapter" id="dynamic-provisioning"><div class="titlepage"><div><div><h1 class="title">Chapter 8. Dynamic provisioning</h1></div></div></div><section class="section" id="about_dynamic-provisioning"><div class="titlepage"><div><div><h2 class="title">8.1. About dynamic provisioning</h2></div></div></div><p>
				The <code class="literal">StorageClass</code> resource object describes and classifies storage that can be requested, as well as provides a means for passing parameters for dynamically provisioned storage on demand. <code class="literal">StorageClass</code> objects can also serve as a management mechanism for controlling different levels of storage and access to the storage. Cluster Administrators (<code class="literal">cluster-admin</code>) or Storage Administrators (<code class="literal">storage-admin</code>) define and create the <code class="literal">StorageClass</code> objects that users can request without needing any detailed knowledge about the underlying storage volume sources.
			</p><p>
				The OpenShift Container Platform persistent volume framework enables this functionality and allows administrators to provision a cluster with persistent storage. The framework also gives users a way to request those resources without having any knowledge of the underlying infrastructure.
			</p><p>
				Many storage types are available for use as persistent volumes in OpenShift Container Platform. While all of them can be statically provisioned by an administrator, some types of storage are created dynamically using the built-in provider and plugin APIs.
			</p></section><section class="section" id="available-plug-ins_dynamic-provisioning"><div class="titlepage"><div><div><h2 class="title">8.2. Available dynamic provisioning plugins</h2></div></div></div><p>
				OpenShift Container Platform provides the following provisioner plugins, which have generic implementations for dynamic provisioning that use the cluster’s configured provider’s API to create new storage resources:
			</p><div class="informaltable"><table class="lt-4-cols lt-7-rows"><colgroup><col style="width: 33%; " class="col_1"><!--Empty--></col><col style="width: 33%; " class="col_2"><!--Empty--></col><col style="width: 33%; " class="col_3"><!--Empty--></col></colgroup><thead><tr><th align="left" valign="top" id="idm140001855266064" scope="col">Storage type</th><th align="left" valign="top" id="idm140001855264976" scope="col">Provisioner plugin name</th><th align="left" valign="top" id="idm140001855263888" scope="col">Notes</th></tr></thead><tbody><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								Red Hat OpenStack Platform (RHOSP) Cinder
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">kubernetes.io/cinder</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								RHOSP Manila Container Storage Interface (CSI)
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">manila.csi.openstack.org</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> <p>
								Once installed, the OpenStack Manila CSI Driver Operator and ManilaDriver automatically create the required storage classes for all available Manila share types needed for dynamic provisioning.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								Amazon Elastic Block Store (Amazon EBS)
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">kubernetes.io/aws-ebs</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> <p>
								For dynamic provisioning when using multiple clusters in different zones, tag each node with <code class="literal">Key=kubernetes.io/cluster/&lt;cluster_name&gt;,Value=&lt;cluster_id&gt;</code> where <code class="literal">&lt;cluster_name&gt;</code> and <code class="literal">&lt;cluster_id&gt;</code> are unique per cluster.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								Azure Disk
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">kubernetes.io/azure-disk</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								Azure File
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">kubernetes.io/azure-file</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> <p>
								The <code class="literal">persistent-volume-binder</code> service account requires permissions to create and get secrets to store the Azure storage account and keys.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								GCE Persistent Disk (gcePD)
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">kubernetes.io/gce-pd</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> <p>
								In multi-zone configurations, it is advisable to run one OpenShift Container Platform cluster per GCE project to avoid PVs from being created in zones where no node in the current cluster exists.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								IBM Power Virtual Server Block
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">powervs.csi.ibm.com</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> <p>
								After installation, the IBM Power Virtual Server Block CSI Driver Operator and IBM Power Virtual Server Block CSI Driver automatically create the required storage classes for dynamic provisioning.
							</p>
							 </td></tr><tr><td align="left" valign="top" headers="idm140001855266064"> <p>
								<a class="link" href="https://www.vmware.com/support/vsphere.html">VMware vSphere</a>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855264976"> <p>
								<code class="literal">kubernetes.io/vsphere-volume</code>
							</p>
							 </td><td align="left" valign="top" headers="idm140001855263888"> </td></tr></tbody></table></div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					Any chosen provisioner plugin also requires configuration for the relevant cloud, host, or third-party provider as per the relevant documentation.
				</p></div></div></section><section class="section" id="defining-storage-classes_dynamic-provisioning"><div class="titlepage"><div><div><h2 class="title">8.3. Defining a storage class</h2></div></div></div><p>
				<code class="literal">StorageClass</code> objects are currently a globally scoped object and must be created by <code class="literal">cluster-admin</code> or <code class="literal">storage-admin</code> users.
			</p><div class="admonition important"><div class="admonition_header">Important</div><div><p>
					The Cluster Storage Operator might install a default storage class depending on the platform in use. This storage class is owned and controlled by the Operator. It cannot be deleted or modified beyond defining annotations and labels. If different behavior is desired, you must define a custom storage class.
				</p></div></div><p>
				The following sections describe the basic definition for a <code class="literal">StorageClass</code> object and specific examples for each of the supported plugin types.
			</p><section class="section" id="basic-storage-class-definition_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.1. Basic StorageClass object definition</h3></div></div></div><p>
					The following resource shows the parameters and default values that you use to configure a storage class. This example uses the AWS ElasticBlockStore (EBS) object definition.
				</p><div class="formalpara"><p class="title"><strong>Sample <code class="literal">StorageClass</code> definition</strong></p><p>
						
<pre class="programlisting language-yaml">kind: StorageClass <span id="CO108-1"><!--Empty--></span><span class="callout">1</span>
apiVersion: storage.k8s.io/v1 <span id="CO108-2"><!--Empty--></span><span class="callout">2</span>
metadata:
  name: &lt;storage-class-name&gt; <span id="CO108-3"><!--Empty--></span><span class="callout">3</span>
  annotations: <span id="CO108-4"><!--Empty--></span><span class="callout">4</span>
    storageclass.kubernetes.io/is-default-class: 'true'
    ...
provisioner: kubernetes.io/aws-ebs <span id="CO108-5"><!--Empty--></span><span class="callout">5</span>
parameters: <span id="CO108-6"><!--Empty--></span><span class="callout">6</span>
  type: gp3
...</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO108-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							(required) The API object type.
						</div></dd><dt><a href="#CO108-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							(required) The current apiVersion.
						</div></dd><dt><a href="#CO108-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							(required) The name of the storage class.
						</div></dd><dt><a href="#CO108-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							(optional) Annotations for the storage class.
						</div></dd><dt><a href="#CO108-5"><span class="callout">5</span></a> </dt><dd><div class="para">
							(required) The type of provisioner associated with this storage class.
						</div></dd><dt><a href="#CO108-6"><span class="callout">6</span></a> </dt><dd><div class="para">
							(optional) The parameters required for the specific provisioner, this will change from plugin to plug-iin.
						</div></dd></dl></div></section><section class="section" id="storage-class-annotations_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.2. Storage class annotations</h3></div></div></div><p>
					To set a storage class as the cluster-wide default, add the following annotation to your storage class metadata:
				</p><pre class="programlisting language-yaml">storageclass.kubernetes.io/is-default-class: "true"</pre><p>
					For example:
				</p><pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    storageclass.kubernetes.io/is-default-class: "true"
...</pre><p>
					This enables any persistent volume claim (PVC) that does not specify a specific storage class to automatically be provisioned through the default storage class. However, your cluster can have more than one storage class, but only one of them can be the default storage class.
				</p><div class="admonition note"><div class="admonition_header">Note</div><div><p>
						The beta annotation <code class="literal">storageclass.beta.kubernetes.io/is-default-class</code> is still working; however, it will be removed in a future release.
					</p></div></div><p>
					To set a storage class description, add the following annotation to your storage class metadata:
				</p><pre class="programlisting language-yaml">kubernetes.io/description: My Storage Class Description</pre><p>
					For example:
				</p><pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  annotations:
    kubernetes.io/description: My Storage Class Description
...</pre></section><section class="section" id="openstack-cinder-storage-class_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.3. RHOSP Cinder object definition</h3></div></div></div><div class="formalpara"><p class="title"><strong>cinder-storageclass.yaml</strong></p><p>
						
<pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;storage-class-name&gt; <span id="CO109-1"><!--Empty--></span><span class="callout">1</span>
provisioner: kubernetes.io/cinder
parameters:
  type: fast  <span id="CO109-2"><!--Empty--></span><span class="callout">2</span>
  availability: nova <span id="CO109-3"><!--Empty--></span><span class="callout">3</span>
  fsType: ext4 <span id="CO109-4"><!--Empty--></span><span class="callout">4</span></pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO109-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.
						</div></dd><dt><a href="#CO109-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							Volume type created in Cinder. Default is empty.
						</div></dd><dt><a href="#CO109-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							Availability Zone. If not specified, volumes are generally round-robined across all active zones where the OpenShift Container Platform cluster has a node.
						</div></dd><dt><a href="#CO109-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							File system that is created on dynamically provisioned volumes. This value is copied to the <code class="literal">fsType</code> field of dynamically provisioned persistent volumes and the file system is created when the volume is mounted for the first time. The default value is <code class="literal">ext4</code>.
						</div></dd></dl></div></section><section class="section" id="openstack-manila-csi-definition_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.4. RHOSP Manila Container Storage Interface (CSI) object definition</h3></div></div></div><p>
					Once installed, the OpenStack Manila CSI Driver Operator and ManilaDriver automatically create the required storage classes for all available Manila share types needed for dynamic provisioning.
				</p></section><section class="section" id="aws-definition_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.5. AWS Elastic Block Store (EBS) object definition</h3></div></div></div><div class="formalpara"><p class="title"><strong>aws-ebs-storageclass.yaml</strong></p><p>
						
<pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;storage-class-name&gt; <span id="CO110-1"><!--Empty--></span><span class="callout">1</span>
provisioner: kubernetes.io/aws-ebs
parameters:
  type: io1 <span id="CO110-2"><!--Empty--></span><span class="callout">2</span>
  iopsPerGB: "10" <span id="CO110-3"><!--Empty--></span><span class="callout">3</span>
  encrypted: "true" <span id="CO110-4"><!--Empty--></span><span class="callout">4</span>
  kmsKeyId: keyvalue <span id="CO110-5"><!--Empty--></span><span class="callout">5</span>
  fsType: ext4 <span id="CO110-6"><!--Empty--></span><span class="callout">6</span></pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO110-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							(required) Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.
						</div></dd><dt><a href="#CO110-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							(required) Select from <code class="literal">io1</code>, <code class="literal">gp3</code>, <code class="literal">sc1</code>, <code class="literal">st1</code>. The default is <code class="literal">gp3</code>. See the <a class="link" href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">AWS documentation</a> for valid Amazon Resource Name (ARN) values.
						</div></dd><dt><a href="#CO110-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							Optional: Only for <span class="strong strong"><strong>io1</strong></span> volumes. I/O operations per second per GiB. The AWS volume plugin multiplies this with the size of the requested volume to compute IOPS of the volume. The value cap is 20,000 IOPS, which is the maximum supported by AWS. See the <a class="link" href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">AWS documentation</a> for further details.
						</div></dd><dt><a href="#CO110-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							Optional: Denotes whether to encrypt the EBS volume. Valid values are <code class="literal">true</code> or <code class="literal">false</code>.
						</div></dd><dt><a href="#CO110-5"><span class="callout">5</span></a> </dt><dd><div class="para">
							Optional: The full ARN of the key to use when encrypting the volume. If none is supplied, but <code class="literal">encypted</code> is set to <code class="literal">true</code>, then AWS generates a key. See the <a class="link" href="http://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">AWS documentation</a> for a valid ARN value.
						</div></dd><dt><a href="#CO110-6"><span class="callout">6</span></a> </dt><dd><div class="para">
							Optional: File system that is created on dynamically provisioned volumes. This value is copied to the <code class="literal">fsType</code> field of dynamically provisioned persistent volumes and the file system is created when the volume is mounted for the first time. The default value is <code class="literal">ext4</code>.
						</div></dd></dl></div></section><section class="section" id="azure-disk-definition_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.6. Azure Disk object definition</h3></div></div></div><div class="formalpara"><p class="title"><strong>azure-advanced-disk-storageclass.yaml</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <span id="CO111-1"><!--Empty--></span><span class="callout">1</span>
provisioner: kubernetes.io/azure-disk
volumeBindingMode: WaitForFirstConsumer <span id="CO111-2"><!--Empty--></span><span class="callout">2</span>
allowVolumeExpansion: true
parameters:
  kind: Managed <span id="CO111-3"><!--Empty--></span><span class="callout">3</span>
  storageaccounttype: Premium_LRS <span id="CO111-4"><!--Empty--></span><span class="callout">4</span>
reclaimPolicy: Delete</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO111-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.
						</div></dd><dt><a href="#CO111-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							Using <code class="literal">WaitForFirstConsumer</code> is strongly recommended. This provisions the volume while allowing enough storage to schedule the pod on a free worker node from an available zone.
						</div></dd><dt><a href="#CO111-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							Possible values are <code class="literal">Shared</code> (default), <code class="literal">Managed</code>, and <code class="literal">Dedicated</code>.
						</div><div class="admonition important"><div class="admonition_header">Important</div><div><p>
								Red Hat only supports the use of <code class="literal">kind: Managed</code> in the storage class.
							</p><p>
								With <code class="literal">Shared</code> and <code class="literal">Dedicated</code>, Azure creates unmanaged disks, while OpenShift Container Platform creates a managed disk for machine OS (root) disks. But because Azure Disk does not allow the use of both managed and unmanaged disks on a node, unmanaged disks created with <code class="literal">Shared</code> or <code class="literal">Dedicated</code> cannot be attached to OpenShift Container Platform nodes.
							</p></div></div></dd><dt><a href="#CO111-4"><span class="callout">4</span></a> </dt><dd><div class="para">
							Azure storage account SKU tier. Default is empty. Note that Premium VMs can attach both <code class="literal">Standard_LRS</code> and <code class="literal">Premium_LRS</code> disks, Standard VMs can only attach <code class="literal">Standard_LRS</code> disks, Managed VMs can only attach managed disks, and unmanaged VMs can only attach unmanaged disks.
						</div><div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">
									If <code class="literal">kind</code> is set to <code class="literal">Shared</code>, Azure creates all unmanaged disks in a few shared storage accounts in the same resource group as the cluster.
								</li><li class="listitem">
									If <code class="literal">kind</code> is set to <code class="literal">Managed</code>, Azure creates new managed disks.
								</li><li class="listitem"><p class="simpara">
									If <code class="literal">kind</code> is set to <code class="literal">Dedicated</code> and a <code class="literal">storageAccount</code> is specified, Azure uses the specified storage account for the new unmanaged disk in the same resource group as the cluster. For this to work:
								</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
											The specified storage account must be in the same region.
										</li><li class="listitem">
											Azure Cloud Provider must have write access to the storage account.
										</li></ul></div></li><li class="listitem">
									If <code class="literal">kind</code> is set to <code class="literal">Dedicated</code> and a <code class="literal">storageAccount</code> is not specified, Azure creates a new dedicated storage account for the new unmanaged disk in the same resource group as the cluster.
								</li></ol></div></dd></dl></div></section><section class="section" id="azure-file-definition_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.7. Azure File object definition</h3></div></div></div><p>
					The Azure File storage class uses secrets to store the Azure storage account name and the storage account key that are required to create an Azure Files share. These permissions are created as part of the following procedure.
				</p><div class="orderedlist"><p class="title"><strong>Procedure</strong></p><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
							Define a <code class="literal">ClusterRole</code> object that allows access to create and view secrets:
						</p><pre class="programlisting language-yaml">apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
#  name: system:azure-cloud-provider
  name: &lt;persistent-volume-binder-role&gt; <span id="CO112-1"><!--Empty--></span><span class="callout">1</span>
rules:
- apiGroups: ['']
  resources: ['secrets']
  verbs:     ['get','create']</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO112-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									The name of the cluster role to view and create secrets.
								</div></dd></dl></div></li><li class="listitem"><p class="simpara">
							Add the cluster role to the service account:
						</p><pre class="programlisting language-terminal">$ oc adm policy add-cluster-role-to-user &lt;persistent-volume-binder-role&gt; system:serviceaccount:kube-system:persistent-volume-binder</pre></li><li class="listitem"><p class="simpara">
							Create the Azure File <code class="literal">StorageClass</code> object:
						</p><pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;azure-file&gt; <span id="CO113-1"><!--Empty--></span><span class="callout">1</span>
provisioner: kubernetes.io/azure-file
parameters:
  location: eastus <span id="CO113-2"><!--Empty--></span><span class="callout">2</span>
  skuName: Standard_LRS <span id="CO113-3"><!--Empty--></span><span class="callout">3</span>
  storageAccount: &lt;storage-account&gt; <span id="CO113-4"><!--Empty--></span><span class="callout">4</span>
reclaimPolicy: Delete
volumeBindingMode: Immediate</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO113-1"><span class="callout">1</span></a> </dt><dd><div class="para">
									Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.
								</div></dd><dt><a href="#CO113-2"><span class="callout">2</span></a> </dt><dd><div class="para">
									Location of the Azure storage account, such as <code class="literal">eastus</code>. Default is empty, meaning that a new Azure storage account will be created in the OpenShift Container Platform cluster’s location.
								</div></dd><dt><a href="#CO113-3"><span class="callout">3</span></a> </dt><dd><div class="para">
									SKU tier of the Azure storage account, such as <code class="literal">Standard_LRS</code>. Default is empty, meaning that a new Azure storage account will be created with the <code class="literal">Standard_LRS</code> SKU.
								</div></dd><dt><a href="#CO113-4"><span class="callout">4</span></a> </dt><dd><div class="para">
									Name of the Azure storage account. If a storage account is provided, then <code class="literal">skuName</code> and <code class="literal">location</code> are ignored. If no storage account is provided, then the storage class searches for any storage account that is associated with the resource group for any accounts that match the defined <code class="literal">skuName</code> and <code class="literal">location</code>.
								</div></dd></dl></div></li></ol></div><section class="section" id="azure-file-considerations_dynamic-provisioning"><div class="titlepage"><div><div><h4 class="title">8.3.7.1. Considerations when using Azure File</h4></div></div></div><p>
						The following file system features are not supported by the default Azure File storage class:
					</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
								Symlinks
							</li><li class="listitem">
								Hard links
							</li><li class="listitem">
								Extended attributes
							</li><li class="listitem">
								Sparse files
							</li><li class="listitem">
								Named pipes
							</li></ul></div><p>
						Additionally, the owner user identifier (UID) of the Azure File mounted directory is different from the process UID of the container. The <code class="literal">uid</code> mount option can be specified in the <code class="literal">StorageClass</code> object to define a specific user identifier to use for the mounted directory.
					</p><p>
						The following <code class="literal">StorageClass</code> object demonstrates modifying the user and group identifier, along with enabling symlinks for the mounted directory.
					</p><pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: azure-file
mountOptions:
  - uid=1500 <span id="CO114-1"><!--Empty--></span><span class="callout">1</span>
  - gid=1500 <span id="CO114-2"><!--Empty--></span><span class="callout">2</span>
  - mfsymlinks <span id="CO114-3"><!--Empty--></span><span class="callout">3</span>
provisioner: kubernetes.io/azure-file
parameters:
  location: eastus
  skuName: Standard_LRS
reclaimPolicy: Delete
volumeBindingMode: Immediate</pre><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO114-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								Specifies the user identifier to use for the mounted directory.
							</div></dd><dt><a href="#CO114-2"><span class="callout">2</span></a> </dt><dd><div class="para">
								Specifies the group identifier to use for the mounted directory.
							</div></dd><dt><a href="#CO114-3"><span class="callout">3</span></a> </dt><dd><div class="para">
								Enables symlinks.
							</div></dd></dl></div></section></section><section class="section" id="gce-persistentdisk-storage-class_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.8. GCE PersistentDisk (gcePD) object definition</h3></div></div></div><div class="formalpara"><p class="title"><strong>gce-pd-storageclass.yaml</strong></p><p>
						
<pre class="programlisting language-yaml">apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: &lt;storage-class-name&gt; <span id="CO115-1"><!--Empty--></span><span class="callout">1</span>
provisioner: kubernetes.io/gce-pd
parameters:
  type: pd-standard <span id="CO115-2"><!--Empty--></span><span class="callout">2</span>
  replication-type: none
volumeBindingMode: WaitForFirstConsumer
allowVolumeExpansion: true
reclaimPolicy: Delete</pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO115-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.
						</div></dd><dt><a href="#CO115-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							Select either <code class="literal">pd-standard</code> or <code class="literal">pd-ssd</code>. The default is <code class="literal">pd-standard</code>.
						</div></dd></dl></div></section><section class="section" id="vsphere-definition_dynamic-provisioning"><div class="titlepage"><div><div><h3 class="title">8.3.9. VMware vSphere object definition</h3></div></div></div><div class="formalpara"><p class="title"><strong>vsphere-storageclass.yaml</strong></p><p>
						
<pre class="programlisting language-yaml">kind: StorageClass
apiVersion: storage.k8s.io/v1
metadata:
  name: &lt;storage-class-name&gt; <span id="CO116-1"><!--Empty--></span><span class="callout">1</span>
provisioner: kubernetes.io/vsphere-volume <span id="CO116-2"><!--Empty--></span><span class="callout">2</span>
parameters:
  diskformat: thin <span id="CO116-3"><!--Empty--></span><span class="callout">3</span></pre>

					</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO116-1"><span class="callout">1</span></a> </dt><dd><div class="para">
							Name of the storage class. The persistent volume claim uses this storage class for provisioning the associated persistent volumes.
						</div></dd><dt><a href="#CO116-2"><span class="callout">2</span></a> </dt><dd><div class="para">
							For more information about using VMware vSphere with OpenShift Container Platform, see the <a class="link" href="https://vmware.github.io/vsphere-storage-for-kubernetes/documentation/index.html">VMware vSphere documentation</a>.
						</div></dd><dt><a href="#CO116-3"><span class="callout">3</span></a> </dt><dd><div class="para">
							<code class="literal">diskformat</code>: <code class="literal">thin</code>, <code class="literal">zeroedthick</code> and <code class="literal">eagerzeroedthick</code> are all valid disk formats. See vSphere docs for additional details regarding the disk format types. The default value is <code class="literal">thin</code>.
						</div></dd></dl></div></section></section><section class="section" id="change-default-storage-class_dynamic-provisioning"><div class="titlepage"><div><div><h2 class="title">8.4. Changing the default storage class</h2></div></div></div><p>
				Use the following procedure to change the default storage class.
			</p><p>
				For example, if you have two defined storage classes, <code class="literal">gp3</code> and <code class="literal">standard</code>, and you want to change the default storage class from <code class="literal">gp3</code> to <code class="literal">standard</code>.
			</p><div class="itemizedlist"><p class="title"><strong>Prerequisites</strong></p><ul class="itemizedlist" type="disc"><li class="listitem">
						Access to the cluster with cluster-admin privileges.
					</li></ul></div><div class="formalpara"><p class="title"><strong>Procedure</strong></p><p>
					To change the default storage class:
				</p></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p class="simpara">
						List the storage classes:
					</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
							
<pre class="programlisting language-terminal">NAME                 TYPE
gp3 (default)        kubernetes.io/aws-ebs <span id="CO117-1"><!--Empty--></span><span class="callout">1</span>
standard             kubernetes.io/aws-ebs</pre>

						</p></div><div class="calloutlist"><dl class="calloutlist"><dt><a href="#CO117-1"><span class="callout">1</span></a> </dt><dd><div class="para">
								<code class="literal">(default)</code> indicates the default storage class.
							</div></dd></dl></div></li><li class="listitem"><p class="simpara">
						Make the desired storage class the default.
					</p><p class="simpara">
						For the desired storage class, set the <code class="literal">storageclass.kubernetes.io/is-default-class</code> annotation to <code class="literal">true</code> by running the following command:
					</p><pre class="programlisting language-terminal">$ oc patch storageclass standard -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "true"}}}'</pre><div class="admonition note"><div class="admonition_header">Note</div><div><p>
							You can have multiple default storage classes for a short time. However, you should ensure that only one default storage class exists eventually.
						</p><p>
							With multiple default storage classes present, any persistent volume claim (PVC) requesting the default storage class (<code class="literal">pvc.spec.storageClassName</code>=nil) gets the most recently created default storage class, regardless of the default status of that storage class, and the administrator receives an alert in the alerts dashboard that there are multiple default storage classes, <code class="literal">MultipleDefaultStorageClasses</code>.
						</p></div></div></li><li class="listitem"><p class="simpara">
						Remove the default storage class setting from the old default storage class.
					</p><p class="simpara">
						For the old default storage class, change the value of the <code class="literal">storageclass.kubernetes.io/is-default-class</code> annotation to <code class="literal">false</code> by running the following command:
					</p><pre class="programlisting language-terminal">$ oc patch storageclass gp3 -p '{"metadata": {"annotations": {"storageclass.kubernetes.io/is-default-class": "false"}}}'</pre></li><li class="listitem"><p class="simpara">
						Verify the changes:
					</p><pre class="programlisting language-terminal">$ oc get storageclass</pre><div class="formalpara"><p class="title"><strong>Example output</strong></p><p>
							
<pre class="programlisting language-terminal">NAME                 TYPE
gp3                  kubernetes.io/aws-ebs
standard (default)   kubernetes.io/aws-ebs</pre>

						</p></div></li></ol></div></section></section><div><div xml:lang="en-US" class="legalnotice" id="idm140001865540400"><h1 class="legalnotice">Legal Notice</h1><div class="para">
		Copyright <span class="trademark"><!--Empty--></span>© 2023 Red Hat, Inc.
	</div><div class="para">
		The text of and illustrations in this document are licensed by Red Hat under a Creative Commons Attribution–Share Alike 3.0 Unported license ("CC-BY-SA"). An explanation of CC-BY-SA is available at <a class="uri" href="http://creativecommons.org/licenses/by-sa/3.0/">http://creativecommons.org/licenses/by-sa/3.0/</a>. In accordance with CC-BY-SA, if you distribute this document or an adaptation of it, you must provide the URL for the original version.
	</div><div class="para">
		Red Hat, as the licensor of this document, waives the right to enforce, and agrees not to assert, Section 4d of CC-BY-SA to the fullest extent permitted by applicable law.
	</div><div class="para">
		Red Hat, Red Hat Enterprise Linux, the Shadowman logo, the Red Hat logo, JBoss, OpenShift, Fedora, the Infinity logo, and RHCE are trademarks of Red Hat, Inc., registered in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Linux</span>® is the registered trademark of Linus Torvalds in the United States and other countries.
	</div><div class="para">
		<span class="trademark">Java</span>® is a registered trademark of Oracle and/or its affiliates.
	</div><div class="para">
		<span class="trademark">XFS</span>® is a trademark of Silicon Graphics International Corp. or its subsidiaries in the United States and/or other countries.
	</div><div class="para">
		<span class="trademark">MySQL</span>® is a registered trademark of MySQL AB in the United States, the European Union and other countries.
	</div><div class="para">
		<span class="trademark">Node.js</span>® is an official trademark of Joyent. Red Hat is not formally related to or endorsed by the official Joyent Node.js open source or commercial project.
	</div><div class="para">
		The <span class="trademark">OpenStack</span>® Word Mark and OpenStack logo are either registered trademarks/service marks or trademarks/service marks of the OpenStack Foundation, in the United States and other countries and are used with the OpenStack Foundation's permission. We are not affiliated with, endorsed or sponsored by the OpenStack Foundation, or the OpenStack community.
	</div><div class="para">
		All other trademarks are the property of their respective owners.
	</div></div></div></div>


  <nav class="pvof-doc__book-nav">
  <ol class="book-nav__list">
              </ol>
</nav>


          </div>
              </div>
              <div id="comments-footer" class="book-comments">
          

  

        </div>
          </div>
  </article>
<meta itemscope="" itemref="md1">



    </div>
      <!-- CP_PRIMER_FOOTER -->            </div>
        </main>
    </div>
    <!--googleoff: all-->
    <div id="to-top"><a class="btn_slideto" href="#masthead" aria-label="Back to Top"><span class="web-icon-upload"></span></a></div>
    <footer class="footer-main">
        <div class="footer-top">
            <div class="container">

              <div class="brand">
                <a href="https://redhat.com">
                  <svg class="rh-logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 613 145">
                    <defs>
                      <style>
                        .rh-logo-hat {
                          fill: #e00;
                        }
                        .rh-logo-type {
                          fill: #fff;
                        }
                      </style>
                    </defs>
                    <title>Red Hat</title>
                    <path
                      class="rh-logo-hat"
                      d="M127.47,83.49c12.51,0,30.61-2.58,30.61-17.46a14,14,0,0,0-.31-3.42l-7.45-32.36c-1.72-7.12-3.23-10.35-15.73-16.6C124.89,8.69,103.76.5,97.51.5,91.69.5,90,8,83.06,8c-6.68,0-11.64-5.6-17.89-5.6-6,0-9.91,4.09-12.93,12.5,0,0-8.41,23.72-9.49,27.16A6.43,6.43,0,0,0,42.53,44c0,9.22,36.3,39.45,84.94,39.45M160,72.07c1.73,8.19,1.73,9.05,1.73,10.13,0,14-15.74,21.77-36.43,21.77C78.54,104,37.58,76.6,37.58,58.49a18.45,18.45,0,0,1,1.51-7.33C22.27,52,.5,55,.5,74.22c0,31.48,74.59,70.28,133.65,70.28,45.28,0,56.7-20.48,56.7-36.65,0-12.72-11-27.16-30.83-35.78"/>
                      <path class="rh-logo-band"
                      d="M160,72.07c1.73,8.19,1.73,9.05,1.73,10.13,0,14-15.74,21.77-36.43,21.77C78.54,104,37.58,76.6,37.58,58.49a18.45,18.45,0,0,1,1.51-7.33l3.66-9.06A6.43,6.43,0,0,0,42.53,44c0,9.22,36.3,39.45,84.94,39.45,12.51,0,30.61-2.58,30.61-17.46a14,14,0,0,0-.31-3.42Z"/>
                      <path
                      class="rh-logo-type"
                      d="M579.74,92.8c0,11.89,7.15,17.67,20.19,17.67a52.11,52.11,0,0,0,11.89-1.68V95a24.84,24.84,0,0,1-7.68,1.16c-5.37,0-7.36-1.68-7.36-6.73V68.3h15.56V54.1H596.78v-18l-17,3.68V54.1H568.49V68.3h11.25Zm-53,.32c0-3.68,3.69-5.47,9.26-5.47a43.12,43.12,0,0,1,10.1,1.26v7.15a21.51,21.51,0,0,1-10.63,2.63c-5.46,0-8.73-2.1-8.73-5.57m5.2,17.56c6,0,10.84-1.26,15.36-4.31v3.37h16.82V74.08c0-13.56-9.14-21-24.39-21-8.52,0-16.94,2-26,6.1l6.1,12.52c6.52-2.74,12-4.42,16.83-4.42,7,0,10.62,2.73,10.62,8.31v2.73a49.53,49.53,0,0,0-12.62-1.58c-14.31,0-22.93,6-22.93,16.73,0,9.78,7.78,17.24,20.19,17.24m-92.44-.94h18.09V80.92h30.29v28.82H506V36.12H487.93V64.41H457.64V36.12H439.55ZM370.62,81.87c0-8,6.31-14.1,14.62-14.1A17.22,17.22,0,0,1,397,72.09V91.54A16.36,16.36,0,0,1,385.24,96c-8.2,0-14.62-6.1-14.62-14.09m26.61,27.87h16.83V32.44l-17,3.68V57.05a28.3,28.3,0,0,0-14.2-3.68c-16.19,0-28.92,12.51-28.92,28.5a28.25,28.25,0,0,0,28.4,28.6,25.12,25.12,0,0,0,14.93-4.83ZM320,67c5.36,0,9.88,3.47,11.67,8.83H308.47C310.15,70.3,314.36,67,320,67M291.33,82c0,16.2,13.25,28.82,30.28,28.82,9.36,0,16.2-2.53,23.25-8.42l-11.26-10c-2.63,2.74-6.52,4.21-11.14,4.21a14.39,14.39,0,0,1-13.68-8.83h39.65V83.55c0-17.67-11.88-30.39-28.08-30.39a28.57,28.57,0,0,0-29,28.81M262,51.58c6,0,9.36,3.78,9.36,8.31S268,68.2,262,68.2H244.11V51.58Zm-36,58.16h18.09V82.92h13.77l13.89,26.82H292l-16.2-29.45a22.27,22.27,0,0,0,13.88-20.72c0-13.25-10.41-23.45-26-23.45H226Z"/>
                  </svg>
                </a>
              </div>

              <div role="navigation" aria-label="quick">
                  <h3>Quick Links</h3>
                  <ul>
                      <li><a class="download-software" href="https://access.redhat.com/downloads/">Downloads</a></li>
                      <li><a class="manage-subscriptions" href="https://access.redhat.com/management">Subscriptions</a></li>
                      <li><a class="support-cases" href="https://access.redhat.com/support">Support Cases</a></li>
                      <li><a class="customer-service" href="https://access.redhat.com/support/customer-service">Customer Service</a></li>
                      <li><a class="quick-docs" href="https://access.redhat.com/documentation">Product Documentation</a></li>
                  </ul>
              </div>

              <div role="navigation" aria-label="help">
                  <h3>Help</h3>
                  <ul>
                      <li><a class="contact-us" href="https://access.redhat.com/support/contact/">Contact Us</a></li>
                      <li><a class="cp-faqs" href="https://access.redhat.com/articles/33844">Customer Portal FAQ</a></li>
                      <li><a class="login-problems" href="https://access.redhat.com/help/login_assistance">Log-in Assistance</a></li>
                  </ul>
              </div>

              <div role="navigation" aria-label="site">
                  <h3>Site Info</h3>
                  <ul>
                      <li><a class="trust-red-hat" href="https://www.redhat.com/en/trust">Trust Red Hat</a></li>
                      <li><a class="browser-support-policy" href="https://www.redhat.com/en/about/browser-support">Browser Support Policy</a></li>
                      <li><a class="accessibility" href="https://www.redhat.com/en/about/digital-accessibility">Accessibility</a></li>
                      <li><a class="recognition" href="https://access.redhat.com/recognition/">Awards and Recognition</a></li>
                      <li><a class="colophon" href="https://access.redhat.com/help/colophon/">Colophon</a></li>
                  </ul>
              </div>

              <div role="navigation" aria-label="other">
                  <h3>Related Sites</h3>
                  <ul>
                      <li><a href="https://www.redhat.com/" class="red-hat-com">redhat.com</a></li>
                      <li><a href="http://developers.redhat.com/" class="red-hat-developers">developers.redhat.com</a></li>
                      <li><a href="https://connect.redhat.com/" class="partner-connect">connect.redhat.com</a></li>
                      <li><a href="https://cloud.redhat.com/" class="cloud-com">cloud.redhat.com</a></li>
                  </ul>
              </div>

              <div role="navigation" aria-label="about">
                  <h3>About</h3>
                  <ul>
                      <li><a href="https://access.redhat.com/subscription-value" class="subscription-value">Red Hat Subscription Value</a></li>
                      <li><a href="https://www.redhat.com/about/" class="about-red-hat">About Red Hat</a></li>
                      <li><a href="http://jobs.redhat.com" class="about-jobs">Red Hat Jobs</a></li>
                  </ul>
              </div>

            </div>
        </div>

        <div class="anchor">
            <div class="container">
                <div class="status-legal">
                    <a hidden href="https://status.redhat.com" class="status-page-widget">
                        <span class="status-description"></span>
                        <span class="status-dot shape-circle"></span>
                    </a>
                    <div class="legal-copyright">
                        <div class="copyright">Copyright © 2023 Red Hat, Inc.</div>
                        <div role="navigation" aria-label="legal" class="legal">
                            <ul>
                                <li><a href="http://www.redhat.com/en/about/privacy-policy" class="privacy-policy">Privacy Statement</a></li>
                                <li><a href="https://www.redhat.com/en/about/terms-use" class="terms-of-use">Terms of Use</a></li>
                                <li><a href="http://www.redhat.com/en/about/all-policies-guidelines" class="all-policies">All Policies and Guidelines</a></li>
                                <li><a id="teconsent"></a></li>
                            </ul>
                            <div id="privacy_policy">We've updated our <a href='http://www.redhat.com/en/about/privacy-policy' class='privacy-policy'>Privacy Statement</a> effective September 15, 2023.
                            </div>
                          </div>
                        </div>
                </div>
                <div class="social">
                    <a href="http://www.redhat.com/summit/" class="summit">
                        <img src="https://access.redhat.com/chrome_themes/nimbus/img/rh-summit-red-a.svg" alt="Red Hat Summit" /> <span class="offscreen">Red Hat Summit</span>
                    </a>

                    <div class="social-media">
                        <a href="https://twitter.com/RedHat" class="sm-icon twitter"><span class="nicon-twitter"></span><span class="offscreen">Twitter</span></a>                        
                    </div>
                </div>
            </div>
        </div>
    </footer>
    <!-- TrustArc -->
    <div id="consent_blackbar"></div> 
    <!--googleon: all-->
</div>
<!-- /CP_PRIMER_FOOTER -->


  </div>

    
  </body>
</html>
